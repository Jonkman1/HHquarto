[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Harrie’s Hoekje",
    "section": "",
    "text": "Dr. Harrie Jonkman studeerde sociologie en onderwijskunde en werkte aan de Rijksuniversiteit Groningen, in het onderwijs, het Nationaal Comité 4 en 5 mei en het Nederlands Jeugdinstituut (NJi). Sinds 2008 is hij verbonden aan het Verwey-Jonker Instituut. Zijn werk richt zich op de sociale en cognitieve ontwikkeling van kinderen en jongeren, sociale determinanten en preventie van ontwikkelings- en gedragsproblemen. In 2012 ontving hij van het National Institute on Drug Abuse (VS) een beurs als ‘Distinguished Researcher’. Hij was landelijk projectleider van de Community that Care strategie in Nederland, ondersteunde deze ook in andere landen en schreef zijn promotieonderzoek naar de effecten van de preventiestrategie Communities that Care. Bij het VerweyJonker Instituut is hij betrokken bij experimenten en evaluaties van sociale programma’s, longitudinale studies, en internationaal vergelijkende studies. Hij ondersteunt preventiewerk in verschillende landen, was adviseur van de International Task Force on Prevention van de Society of Prevention Research en werkte tientallen jaren als supervisor in stuurgroepen van onderwijsinstellingen. De laatste jaren specialiseerde hij zich in moderne data-analyse. Zijn interesse gaat daarbij uit naar multilevel-analyse, effectonderzoek en, sinds kort, machine-learning, zowel frequentisch als Bayesiaans. Maar ook vormgeving en visualisatie heeft zijn interesse. Hij ziet zichzelf meer als liefhebber dan als expert.\nDit zijn blogs die hij graag volgt:\nSimply Statistics\nRbloggers\nR4stats\nDataCamp\nJASP\nMLwiN\nSTATA\nIndividuen die hij graag volgt zijn onder andere:\nKieran Healey\nRens van de Schoot\nDavid Spiegelhalter\nAlison Hill\nHier boeken die op dit moment voor hem belangrijk zijn:\nJohnson, A.A., Ott, M., Dogucu, M. (2021). Bayes Rules! Introduction to Bayesian Modeling with R. https://www.bayesrulesbook.com/\nBatra, N. (ed, 2021). The Epidemiologist R Handbook. https://epirhandbook.com/index.html\nBaumer, B.S., Kaplan, D.T. & Horton, N.J. (2018). Modern Data Science with R. Boca Raton: CRC Press.\nFreeman, M. & Ross, J. (2019). Programming Skills for Data Science. Start writing code to wrangle, analyze, and visualize data with R. Boston: Addison Wesley.\nGillespie, C. & Lovelace, R. (2017). Efficient R Programming. (https://csgillespie.github.io/efficientR/)\nGrolemund, G. & Wickham, H. (2019). R for Data Science. (https://r4ds.had.co.nz/)\nHealey, K. (2019). Data Visualization: A Practical Introduction. Princeton: Princeton University Press.\nIrizarry, R.A. (2019). Introduction to Data Science. Data Analysis and Prediction Algorithms with R. (https://rafalab.github.io/dsbook/)\nLovelace, R., Nowosad, J. & Muenchow, J. (2019). Geocomputation with R. (https://geocompr.robinlovelace.net/)\nMcElreath, R. (2019). Statistical Rethinking. A Bayesian Course with Examples in R and Stan. (Second edition). Boca Raton: Chapman and Hall/CRC Vooral met brms, ggplot2 and the tidyverse https://bookdown.org/connect/#/apps/1850/access\nPoldrack, R.A. (2021). Statistical Thinking for the 21st Century.https://statsthinking21.github.io/statsthinking21-core-site/\nSpiegelhalter, D. (2019). The Art of Statistics. Learning from Data. https://github.com/dspiegel29/ArtofStatistics\nXie, Y., Allaire, J.J. & Grolemund, G.(2019). R Markdown: The Definitive Guide. https://bookdown.org/yihui/rmarkdown/\nXie, Y., Dervieux, C. & Riederer, E. (2021). RMarkdown Cookbook. https://bookdown.org/yihui/rmarkdown-cookbook/"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Harrie’s Hoekje",
    "section": "",
    "text": "Een korte bespreking van Bayes Rules!\n\n\n\n\n\n\nJul 6, 2022\n\n\nHarrie Jonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nEen GGPLOT2 handleiding om mooi te kunnen plotten in R.\n\n\n\n\n\n\nJun 27, 2022\n\n\nCédric Scherer, bewerking Harrie Jonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nEen blog maken met quarto.\n\n\n\n\n\n\nMay 31, 2022\n\n\nDanielle Navarro bewerking HarrieJonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nOver het pakket mice en missende waarden\n\n\n\n\n\n\nMay 8, 2022\n\n\nMichy Allice, bewerking HarrieJonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nHieronder een korte introductie op hoe je kaarten maakt met R, met name met het pakket sf.\n\n\n\n\n\n\nMay 5, 2022\n\n\nEuginio Petrovich, bewerking Harrie Jonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nIn deze blog wordt getoond hoe Naïeve Bayesiaanse classificatieanalyse werkt.\n\n\n\n\n\n\nMar 29, 2022\n\n\nHarrie Jonkman en Mr.X\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nIn deze blog wordt getoond wat je met Bayes wetenschappelijk kunt: schatten, testen en voorspellen.\n\n\n\n\n\n\nMar 29, 2022\n\n\nJohnson e.a. en Harrie Jonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nDeze blog is een inleiding op de workflow van Machine Learning.\n\n\n\n\n\n\nMar 25, 2022\n\n\nHarrie Jonkman en Mr.X\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nEen blog over de principes van de Bayesiaanse theorie\n\n\n\n\n\n\nMar 7, 2022\n\n\nJohnson e.a. en Harrie Jonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nDit is een blog naar aanleiding van Gelman/Hill/Vehtari nieuwe boek Regresion and other stories\n\n\n\n\n\n\nFeb 10, 2022\n\n\nHarrie Jonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nIntroductie op multilevel modelleren met gebruik van rstanarm: Een tutorial voor onderwijsonderzoekers\n\n\n\n\n\n\nFeb 6, 2022\n\n\nJoonHo Lee, Nicholas Sim, Feng Ji, and Sophia Rabe-Hesketh, vertaling HarrieJonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nDit is een post over multilevel analyse van longitudinale data met betrekking tot alcoholgebruik van jongeren.\n\n\n\n\n\n\nJan 4, 2022\n\n\nAlexander Cernat, bewerking Harrie Jonkman\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nanalyse\n\n\n\n\nDit is een blog over Latente Groei Modeling van longitudinale data van alcoholgebruik van jongeren\n\n\n\n\n\n\nJan 3, 2022\n\n\nAlexander Cernat, bewerking Harrie Jonkman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2022-01-03-latente-groei-modeling/latente-groei-modeling.html",
    "href": "posts/2022-01-03-latente-groei-modeling/latente-groei-modeling.html",
    "title": "Latente Groei Modeling",
    "section": "",
    "text": "Longitudinale gegevens zijn zo interessant omdat ze ons in staat stellen te kijken naar verandering in de tijd, je krijgt er een beter inzicht mee in causale verbanden en je kunt gebeurtenissen en hun timing ermee verklaren. Om gebruik te maken van dit soort gegevens, moeten we verder gaan dan de klassieke statistische methoden, zoals OLS regressie en ANOVA. Dan moeten we gebruik maken van modellen die de extra complexiteit van de gegevens ook echt aan kunnen. Alexandru Cernat schreef ook hier een duidelijke blog over dat ik heb bewerkt en waarbij ik ook de alcoholdata van Singer en Willet heb gebruik.\nEen populair model voor de analyse van longitudinale gegevens is het Latente Groei Model (Latent Growth Model, LGM). Hiermee kan de verandering in de tijd worden geschat, terwijl rekening wordt gehouden met de hiërarchische aard van de gegevens (meerdere punten in de tijd die genest zijn binnen individuen). Het is vergelijkbaar met het multilevel model van verandering, maar hier wordt de schatting gedaan met behulp van het Structural Equation Modeling (SEM)-raamwerk. Dit raamwerk maakt gebruik van gegevens in het brede formaat (elke rij is een individu en de diverse metingen in de tijd verschijnen als verschillende kolommen).\nMeer in het bijzonder kan het LGM helpen\n- te begrijpen hoe verandering in de tijd verloopt;\n- verandering verklaren met behulp van tijdvariërende en tijdconstante voorspellers;\n- variantie ontleden in tussen- en binnenvariatie;\n- en het model kan makkelijk worden uitgebreid naar andere analysemodellen.\nHieronder volgt een korte inleiding op LGM, hoe de uitkomsten zijn te schatten en hoe de schattingen van verandering zijn te visualiseren.\nLaten we eerst de benodigde pakketten eens laden. We zullen tidyverse gebruiken voor het opschonen en visualiseren van de gegevens en lavaan voor het uitvoeren van de LGM in R.\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.1.3\n\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv ggplot2 3.3.6     v purrr   0.3.4\nv tibble  3.1.7     v dplyr   1.0.9\nv tidyr   1.2.0     v stringr 1.4.1\nv readr   2.1.2     v forcats 0.5.1\n\n\nWarning: package 'ggplot2' was built under R version 4.1.3\n\n\nWarning: package 'tibble' was built under R version 4.1.3\n\n\nWarning: package 'tidyr' was built under R version 4.1.3\n\n\nWarning: package 'readr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\nWarning: package 'stringr' was built under R version 4.1.3\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\nlibrary(lavaan)\n\nWarning: package 'lavaan' was built under R version 4.1.3\n\n\nThis is lavaan 0.6-11\nlavaan is FREE software! Please report any bugs.\n\n\nLaten we, voordat we aan de LGM beginnen, eens kijken naar het soort gegevens dat we zouden willen analyseren. Hier gebruik ik alcoholdata van jongeren met de drie metingen van Singer en Willet voor die vrij toegankelijk zijn op internet.\nStel dat we geïnteresseerd zijn in hoe alcoholscore in de tijd verandert. Om het preciezer te formuleren willen laten zien hoe alcoholgebruik onder jongeren gemiddeld verandert, en tegelijk willen we een onderscheid maken tussen variatie, hoe jongeren veranderen ten opzichte van anderen. Maar tegelijk willen we ook iets zeggen over binnenvariatie en hoe jongeren veranderen ten opzichte van hun eigen gemiddelde/trend.\nLaten we eerst eens kijken hoe de gegevens eruit zien. Laten we eens kijken naar de brede gegevens, dit zijn de gegevens die gebruikt worden om LGM uit te voeren en laten we ook maar meteen het lange bestand bekijken:\n\nalcohol1 <- read.table(\"https://stats.idre.ucla.edu/stat/r/examples/alda/data/alcohol1_pp.txt\", header=T, sep=\",\")\nattach(alcohol1)\n\nWe beginnen met het lange formaat, waar elke rij een combinatie is van individu en tijd. Dit is het formaat dat we nodig hebben voor visualisatie met ggplot2, en voor andere modellen (zoals het multilevel model voor verandering).\n\nhead(alcohol1)\n\n  id age coa male age_14   alcuse      peer      cpeer  ccoa\n1  1  14   1    0      0 1.732051 1.2649111  0.2469111 0.549\n2  1  15   1    0      1 2.000000 1.2649111  0.2469111 0.549\n3  1  16   1    0      2 2.000000 1.2649111  0.2469111 0.549\n4  2  14   1    1      0 0.000000 0.8944272 -0.1235728 0.549\n5  2  15   1    1      1 0.000000 0.8944272 -0.1235728 0.549\n6  2  16   1    1      2 1.000000 0.8944272 -0.1235728 0.549\n\n\nOm een idee te krijgen van wat we gaan modelleren, maken we een eenvoudige grafiek met de gemiddelde verandering in de tijd en de trend voor elk individu.\n\nggplot(alcohol1, aes(age_14, alcuse, group = id)) + \n  geom_line(alpha = 0.1) + # add individual line with transparency\n  stat_summary( # add average line\n    aes(group = 1),\n    fun = mean,\n    geom = \"line\",\n    size = 1.5,\n    color = \"red\"\n  ) +\n  theme_bw() + # nice theme\n  labs(x = \"Leeftijd\", y = \"Alcoholgebruik\") # nice labels\n\n\n\n\nWe zien hier een gemiddelde verandering in de tijd. Tegelijk willen we ook zichtbaar maken wat variatie is in de manier waarop mensen veranderen. LGM is in staat beide tegelijk te schatten!"
  },
  {
    "objectID": "posts/2022-01-03-latente-groei-modeling/latente-groei-modeling.html#wat-is-latente-groei-modellering",
    "href": "posts/2022-01-03-latente-groei-modeling/latente-groei-modeling.html#wat-is-latente-groei-modellering",
    "title": "Latente Groei Modeling",
    "section": "Wat is Latente Groei Modellering?",
    "text": "Wat is Latente Groei Modellering?\nNu we een idee hebben van de gegevens en het soort onderzoeksvragen dat we zouden kunnen hebben, kunnen we overgaan tot de uitvoering van LGM. De formule voor het LGM is eigenlijk zeer gelijkaardig aan die voor het multilevel model van verandering:\n\\(Y_j=\\alpha_0 + \\alpha_1*\\gamma_j + \\zeta_{00} + \\zeta_{11}*\\gamma_j + \\epsilon_j\\)\nWaarbij:\n\n\\(Y_j\\) is de variabele van belang (alcuse, alchoholgebruik van jongeren) die verandert in tijd, j.\n\n\\(\\alpha_0\\) is de gemiddelde waarde bij het begin van de gegevensverzameling (het beginpunt van de rode lijn hierboven).\n\n\\(\\alpha_1*\\gamma_j\\) is de gemiddelde snelheid van verandering in de tijd (de helling van de rode lijn in de grafiek hierboven). Hier is \\(gamma_j\\) gewoon een maat voor de tijd.\n\n\\(\\zeta_{00}\\) is de tussenvariatie aan het begin van de gegevens. Het vat samen hoe verschillend de individuele startpunten zijn ten opzichte van het gemiddelde startpunt.\n\n\\(\\zeta_{11}\\gamma_j\\) is de tussen variatie in de snelheid van verandering. Samenvattend hoe verschillend de individuele veranderingsversnellingen zijn ten opzichte van de gemiddelde verandering (rode lijn hierboven).\n\nDe \\(\\epsilon_j\\) is de binnenvariatie of hoeveel individuen variëren rond hun voorspelde trend. Met de onderstaande grafiek kunnen we een beter idee krijgen van de verschillende variatiebronnen:\n\n\nalcohol1 %>% \n  filter(id %in% 1:2) %>% # selecteer twee individuen\n  ggplot(aes(age_14, alcuse, color = id)) +\n  geom_point() + # punten voor VeerkrachtTotaal\n  geom_smooth(method = lm, se = FALSE) + # liniaire lijn\n  theme_bw() + # mooi thema\n  labs(x = \"Leeftijd\", y = \"Alcoholgebruik\") # nice labels\n\n`geom_smooth()` using formula 'y ~ x'\n\n\n\n\n\nDe interne variatie wordt weergegeven door de afstand tussen de lijn en de punten. Dit wordt voor elk individu afzonderlijk gedaan (door de kleur in de grafiek). De tussenvariatie verwijst naar hoe verschillend de lijnen zijn. Dit kan zowel het beginpunt als de helling zijn.\nOmdat deze techniek met brede databestanden werkt, zetten we de data over van lang naar wijd\n\nlibrary(tidyr)\nlibrary(dplyr)\n\nalcwide<-alcohol1 %>%\n  select(id, alcuse, age_14) %>%\n  pivot_wider(names_from = age_14, \n              values_from = alcuse) %>%\n  rename(\n    \"age_14\"=\"0\",\n    \"age_15\"=\"1\",         \n    \"age_16\"=\"2\"\n    )\n\n i =~ 1*Meting.0 +  1*Meting.1 +  1*Meting.2 \n  s =~ 0*Meting.0 +  1*Meting.1 +  2*Meting.2 \n  i ~~ s\nStructural Equation Modeling heeft zijn eigen manier om deze statistische relaties weer te geven. Hieronder is afgebeeld hoe we ons het hierboven beschreven model zouden moeten voorstellen:\n\n\n\nFig.1, LGM grafisch verbeeld\n\n\nIn de figuur worden de latente variabelen voorgesteld door cirkels (de twee \\(\\eta\\)-variabelen, intercept en slope), terwijl de waargenomen variabelen worden voorgesteld door vierkanten (de vier y-variabelen). Wij krijgen ook de residuen (kleine cirkels die \\(\\epsilon\\) voorstellen). Voor de latente variabelen hebben wij gemiddelden (\\(\\alpha\\)) en varianties (\\(\\zeta\\)). Deze zijn geschat en hebben de hierboven beschreven interpretatie. De pijlen tussen de latente en de geobserveerde variabelen (die gewoon regressiehellingen of ladingen zijn) liggen van tevoren vast. Voor de latente interceptvariabele (weergegeven door \\(\\eta_0\\)) zijn de ladingen vastgesteld op 1 (daarom is er in bovenstaande formule niets vermenigvuldigd met \\(\\alpha_0\\) en \\(\\eta_{00}\\)). De ladingen voor de hellende latente variabele (weergegeven door \\(\\eta_1\\)) worden vastgesteld naar gelang van de verandering in tijd (\\(\\gamma_j\\) in bovenstaande formule). In dit geval gaat het eenvoudig van 0 naar 2. Er is ook een correlatie tussen het beginpunt en de verandering in tijd, weergegeven door de dubbele pijl \\(\\zeta_{01}\\). Dit wordt niet vaak geïnterpreteerd, maar het geeft je in feite een idee of mensen convergeren (of meer op elkaar gaan lijken in de tijd) of divergeren (meer van elkaar gaan verschillen).\nNu het technische deel duidelijk is gemaakt, kunnen we wat modelleren en meer grafieken maken!\n\n# first LGM \nmodel <- 'i =~ 1*age_14 + 1*age_15 + 1*age_16\n          s =~ 0*age_14 + 1*age_15 + 2*age_16 '\n                  \n\nfit1 <- growth(model, data = alcwide)\n\nsummary(fit1, standardized = TRUE)\n\nlavaan 0.6-11 ended normally after 22 iterations\n\n  Estimator                                         ML\n  Optimization method                           NLMINB\n  Number of model parameters                         8\n                                                      \n  Number of observations                            82\n                                                      \nModel Test User Model:\n                                                      \n  Test statistic                                 0.636\n  Degrees of freedom                                 1\n  P-value (Chi-square)                           0.425\n\nParameter Estimates:\n\n  Standard errors                             Standard\n  Information                                 Expected\n  Information saturated (h1) model          Structured\n\nLatent Variables:\n                   Estimate  Std.Err  z-value  P(>|z|)   Std.lv  Std.all\n  i =~                                                                  \n    age_14            1.000                               0.898    0.963\n    age_15            1.000                               0.898    0.862\n    age_16            1.000                               0.898    0.796\n  s =~                                                                  \n    age_14            0.000                               0.000    0.000\n    age_15            1.000                               0.484    0.464\n    age_16            2.000                               0.967    0.857\n\nCovariances:\n                   Estimate  Std.Err  z-value  P(>|z|)   Std.lv  Std.all\n  i ~~                                                                  \n    s                -0.187    0.102   -1.841    0.066   -0.431   -0.431\n\nIntercepts:\n                   Estimate  Std.Err  z-value  P(>|z|)   Std.lv  Std.all\n   .age_14            0.000                               0.000    0.000\n   .age_15            0.000                               0.000    0.000\n   .age_16            0.000                               0.000    0.000\n    i                 0.634    0.103    6.163    0.000    0.706    0.706\n    s                 0.277    0.062    4.481    0.000    0.573    0.573\n\nVariances:\n                   Estimate  Std.Err  z-value  P(>|z|)   Std.lv  Std.all\n   .age_14            0.064    0.147    0.436    0.663    0.064    0.073\n   .age_15            0.420    0.094    4.463    0.000    0.420    0.387\n   .age_16            0.280    0.180    1.556    0.120    0.280    0.220\n    i                 0.807    0.193    4.177    0.000    1.000    1.000\n    s                 0.234    0.083    2.803    0.005    1.000    1.000\n\n\nEr zijn in principe zes soorten coëfficiënten die hier interessant zijn:\n\nintercept i: de waarde 0.634 staat voor de gemiddelde verwachte alcoholgebruik aan het begin van het onderzoek voor alle respondenten wanneer ze 14 jaar zijn.\n\nslope s: de waarde 0.277 vertegenwoordigt de gemiddelde verandering voor alle respondenten. Dus bij elke meting stijgt het gebruik van alcohol met met 0.277.\n\nvariantie i: de waarde 0.807 vertegenwoordigt de tussenvariatie aan het begin van het onderzoek. Dus hoe verschillend zijn mensen vergeleken met het gemiddelde.\n\nvariantie s: de waarde 0.234 staat voor de tussenvariatie in de veranderingssnelheid. Het laat zien hoe verschillend veranderingshellingen zijn voor verschillende mensen.\n\nVariantie alcoholgebruik: de waarden tussen 0.064 en 0.420 geven de interne variatie op elk punt in de tijd weer.\n\ncorrelatie tussen i en s: de waarde -0.187 laat zien dat het alcohol niet in de tijd convergeert (althans niet significant).\n\n\nHoe kunnen we de verandering visualiseren?\nEen goede manier om te begrijpen wat je modelleert, is de voorspelde scores van het model visualiseren. We zullen het predict() commando gebruiken om een nieuw object op te slaan met de voorspelde scores op individueel niveau voor het intercept en de helling.\n\n# voorspellen van twee latente variabelen\npred_lgm <- predict(fit1) \n\nDit heeft de voorspelde score voor het intercept en de helling voor elk individu:\n\nhead(pred_lgm)\n\n              i          s\n[1,] 1.67339200 0.15061147\n[2,] 0.01577357 0.41987762\n[3,] 1.03717373 0.89157072\n[4,] 0.15472328 0.80763226\n[5,] 0.01182452 0.09588422\n[6,] 2.85697940 0.05794456\n\n\nDeze zijn gebaseerd op ons model. Wij zouden dus bijvoorbeeld het gemiddelde van deze variabelen kunnen schatten en dat gemiddelde voor intercept en slope zou achtereenvolgens dezelfde resultaten moeten geven als hierboven:\n\n# gemiddelde van het intercept (eerste kolom)\nmean(pred_lgm[, 1]) \n\n[1] 0.634417\n\n\n\n# gemiddelde slope (tweede kolom)\nmean(pred_lgm[, 2])\n\n[1] 0.2773233\n\n\nOm de resultaten te plotten, willen wij deze gegevens (intercept (\\(\\zeta_0\\)) en helling (\\(\\zeta_1\\))) omzetten in verwachte scores bij elke meting (\\(\\gamma_j\\)j). We kunnen deze transformatie doen op basis van het padmodel dat we hierboven hebben gezien:\n\\(Y_1=\\eta_0 + \\eta_1\\gamma_j\\)\nVoor de eerste meting (time=0) is de verwachte waarde dus alleen het intercept (\\(\\eta_0\\)) omdat \\(\\gamma_j\\) gelijk is aan 0. Voor de meting zou de verwachte waarde het intercept (\\(\\eta_0\\)) en de helling (\\(\\eta_1\\)) zijn. Voor meting drie zou het intercept + 2*helling zijn, enzovoort.\nIn R zouden we al deze metingen met de hand kunnen berekenen of we zouden het automatisch kunnen doen met behulp van functioneel programmeren. Op basis van de bovenstaande formule kunnen we een tegenhanger in R maken:\npred_lgm[, 1] + x*pred_lgm[, 2]\nVoor de eerste meting (alc_14=0) krijgen we deze scores\n\npred_lgm[, 1] + 0*pred_lgm[, 2]\n\n [1] 1.67339200 0.01577357 1.03717373 0.15472328 0.01182452 2.85697940\n [7] 1.70002148 0.01182452 0.09353383 0.95999586 0.02431252 0.89485737\n[13] 0.01972262 2.74652531 1.69122663 0.98981031 0.07985392 1.88598973\n[19] 0.01182452 3.16706021 1.01268775 2.68643747 0.96288677 0.07985392\n[25] 2.71888080 0.08543872 2.64724315 0.01182452 0.01577357 1.03091617\n[31] 1.77626546 1.62959225 0.08543872 0.08380297 0.95604681 0.96394491\n[37] 1.09292161 0.13755300 0.01182452 0.01182452 1.25884647 0.01182452\n[43] 0.01182452 0.11987977 2.13501694 0.01740932 0.07985392 0.01182452\n[49] 0.01182452 0.01182452 0.01182452 0.07985392 0.01182452 0.01577357\n[55] 0.01182452 0.11848083 0.01182452 0.99389867 0.02227273 0.08543872\n[61] 1.92422677 0.01182452 0.01182452 0.15671367 0.08543872 1.49845628\n[67] 0.88801741 0.07985392 0.01182452 1.83223971 0.01182452 0.01182452\n[73] 0.01182452 0.13848524 0.01182452 0.01182452 0.11920222 0.01182452\n[79] 1.04572058 0.96288677 0.01182452 0.11198167\n\n\nVoor de tweede meting (alc_14=1) ziet het er zo uit\n\npred_lgm[, 1] + 1*pred_lgm[, 2]\n\n [1] 1.8240035 0.4356512 1.9287445 0.9623555 0.1077087 2.9149240 1.5604805\n [8] 0.1077087 1.3870516 1.0257079 1.1447539 1.1224615 0.7635937 2.8155774\n[15] 2.0052428 1.2209099 0.2510256 1.5773629 0.1077087 2.4340560 1.3706937\n[22] 2.1045835 1.2657784 0.2510256 2.4588992 0.7148063 2.0159411 0.1077087\n[29] 0.4356512 1.4090953 2.3055104 1.4121079 0.7148063 0.5789681 0.6977654\n[36] 1.3536504 1.9968551 1.0118258 0.1077087 0.1077087 1.3953791 0.1077087\n[43] 0.1077087 1.2942168 2.4109430 0.5714894 0.2510256 0.1077087 0.1077087\n[50] 0.1077087 0.1077087 0.2510256 0.1077087 0.4356512 0.1077087 1.1780436\n[57] 0.1077087 1.5604210 0.9753629 0.7148063 1.9775396 0.1077087 0.1077087\n[64] 1.1276442 0.7148063 2.2197859 0.5544485 0.2510256 0.1077087 1.1445052\n[71] 0.1077087 0.1077087 0.1077087 1.0892425 0.1077087 0.1077087 1.2379508\n[78] 0.1077087 1.3386955 1.2657784 0.1077087 0.6383319\n\n\nBij de derde meting ziet het alcoholgebruik er zo uit.\n\npred_lgm[, 1] + 2*pred_lgm[, 2]\n\n [1] 1.9746149 0.8555288 2.8203152 1.7699878 0.2035930 2.9728685 1.4209395\n [8] 0.2035930 2.6805694 1.0914199 2.2651952 1.3500657 1.5074647 2.8846296\n[15] 2.3192590 1.4520095 0.4221974 1.2687361 0.2035930 1.7010517 1.7286996\n[22] 1.5227296 1.5686701 0.4221974 2.1989176 1.3441739 1.3846391 0.2035930\n[29] 0.8555288 1.7872745 2.8347553 1.1946236 1.3441739 1.0741332 0.4394841\n[36] 1.7433558 2.9007885 1.8860986 0.2035930 0.2035930 1.5319118 0.2035930\n[43] 0.2035930 2.4685539 2.6868691 1.1255695 0.4221974 0.2035930 0.2035930\n[50] 0.2035930 0.2035930 0.4221974 0.2035930 0.8555288 0.2035930 2.2376064\n[57] 0.2035930 2.1269432 1.9284531 1.3441739 2.0308524 0.2035930 0.2035930\n[64] 2.0985747 1.3441739 2.9411155 0.2208797 0.4221974 0.2035930 0.4567708\n[71] 0.2035930 0.2035930 0.2035930 2.0399998 0.2035930 0.2035930 2.3566993\n[78] 0.2035930 1.6316705 1.5686701 0.2035930 1.1646821\n\n\nwaarbij x onze codering van tijd voorstelt (of \\(\\gamma_j\\)). We kunnen deze functie meerdere keren toepassen met het map() commando. De onderstaande syntaxis past deze formule toe voor de getallen 0, 1, 2 (onze codering van meting (variabele alc_14).\n\nmap(0:2, # loop over, in ons geval 1,2,3\n    function(x) pred_lgm[, 1] + x * pred_lgm[, 2]) # formule die gebruikt wordt\n\n[[1]]\n [1] 1.67339200 0.01577357 1.03717373 0.15472328 0.01182452 2.85697940\n [7] 1.70002148 0.01182452 0.09353383 0.95999586 0.02431252 0.89485737\n[13] 0.01972262 2.74652531 1.69122663 0.98981031 0.07985392 1.88598973\n[19] 0.01182452 3.16706021 1.01268775 2.68643747 0.96288677 0.07985392\n[25] 2.71888080 0.08543872 2.64724315 0.01182452 0.01577357 1.03091617\n[31] 1.77626546 1.62959225 0.08543872 0.08380297 0.95604681 0.96394491\n[37] 1.09292161 0.13755300 0.01182452 0.01182452 1.25884647 0.01182452\n[43] 0.01182452 0.11987977 2.13501694 0.01740932 0.07985392 0.01182452\n[49] 0.01182452 0.01182452 0.01182452 0.07985392 0.01182452 0.01577357\n[55] 0.01182452 0.11848083 0.01182452 0.99389867 0.02227273 0.08543872\n[61] 1.92422677 0.01182452 0.01182452 0.15671367 0.08543872 1.49845628\n[67] 0.88801741 0.07985392 0.01182452 1.83223971 0.01182452 0.01182452\n[73] 0.01182452 0.13848524 0.01182452 0.01182452 0.11920222 0.01182452\n[79] 1.04572058 0.96288677 0.01182452 0.11198167\n\n[[2]]\n [1] 1.8240035 0.4356512 1.9287445 0.9623555 0.1077087 2.9149240 1.5604805\n [8] 0.1077087 1.3870516 1.0257079 1.1447539 1.1224615 0.7635937 2.8155774\n[15] 2.0052428 1.2209099 0.2510256 1.5773629 0.1077087 2.4340560 1.3706937\n[22] 2.1045835 1.2657784 0.2510256 2.4588992 0.7148063 2.0159411 0.1077087\n[29] 0.4356512 1.4090953 2.3055104 1.4121079 0.7148063 0.5789681 0.6977654\n[36] 1.3536504 1.9968551 1.0118258 0.1077087 0.1077087 1.3953791 0.1077087\n[43] 0.1077087 1.2942168 2.4109430 0.5714894 0.2510256 0.1077087 0.1077087\n[50] 0.1077087 0.1077087 0.2510256 0.1077087 0.4356512 0.1077087 1.1780436\n[57] 0.1077087 1.5604210 0.9753629 0.7148063 1.9775396 0.1077087 0.1077087\n[64] 1.1276442 0.7148063 2.2197859 0.5544485 0.2510256 0.1077087 1.1445052\n[71] 0.1077087 0.1077087 0.1077087 1.0892425 0.1077087 0.1077087 1.2379508\n[78] 0.1077087 1.3386955 1.2657784 0.1077087 0.6383319\n\n[[3]]\n [1] 1.9746149 0.8555288 2.8203152 1.7699878 0.2035930 2.9728685 1.4209395\n [8] 0.2035930 2.6805694 1.0914199 2.2651952 1.3500657 1.5074647 2.8846296\n[15] 2.3192590 1.4520095 0.4221974 1.2687361 0.2035930 1.7010517 1.7286996\n[22] 1.5227296 1.5686701 0.4221974 2.1989176 1.3441739 1.3846391 0.2035930\n[29] 0.8555288 1.7872745 2.8347553 1.1946236 1.3441739 1.0741332 0.4394841\n[36] 1.7433558 2.9007885 1.8860986 0.2035930 0.2035930 1.5319118 0.2035930\n[43] 0.2035930 2.4685539 2.6868691 1.1255695 0.4221974 0.2035930 0.2035930\n[50] 0.2035930 0.2035930 0.4221974 0.2035930 0.8555288 0.2035930 2.2376064\n[57] 0.2035930 2.1269432 1.9284531 1.3441739 2.0308524 0.2035930 0.2035930\n[64] 2.0985747 1.3441739 2.9411155 0.2208797 0.4221974 0.2035930 0.4567708\n[71] 0.2035930 0.2035930 0.2035930 2.0399998 0.2035930 0.2035930 2.3566993\n[78] 0.2035930 1.6316705 1.5686701 0.2035930 1.1646821\n\n\n\n\nConclusies\nHopelijk geeft dit je een idee over wat LGM is, hoe je het kan schatten in R en hoe je deze verandering kan visualiseren.\n[Met dank aan Alexandru Cernat}(https://www.alexcernat.com/estimating-and-visualizing-change-in-time-using-latent-growth-models-with-r/)"
  },
  {
    "objectID": "posts/2022-01-03-multilevel-modeling/multilevel-modeling.html",
    "href": "posts/2022-01-03-multilevel-modeling/multilevel-modeling.html",
    "title": "Multilevel modeling",
    "section": "",
    "text": "Longitudinale gegevens zijn heel boeiend omdat je ermee kunt kijken naar verandering in de tijd, een beter begrip krijgt van causale verbanden en gebeurtenissen en hun timing ermee kunt verklaren. Om dit te kunnen doen, moeten we verder gaan dan de klassieke statistische methoden, zoals OLS regressie en ANOVA, en modellen gebruiken die beter kunnen omgaan met complexiteit van de gegevens. Alexander Cernat schreef er een blog over hier die ik hier in het Nederlands overzet en waarbij ik alcoholdata van Willet en Singer gebruik/\nEen populair model voor de analyse van longitudinale gegevens is het Multilevel Model voor Verandering; MultiLevel Model for Change (MLMC). Dit model maakt de schatting van verandering in de tijd mogelijk, terwijl rekening wordt gehouden met de hiërarchische aard van de gegevens (meerdere punten in de tijd genest binnen individuen). Het is vergelijkbaar met het Latente Groei Model; Latent Growth Model zie deze post, maar hier wordt geschat met behulp van het multilevel model raamwerk (ook bekend als hiërarchische modellering of random effecten). Deze techniek maakt gebruik van het lange dataformaat (elke rij is is een rij gegevens op een specifiek tijdstip voor een individu).\nMeer in het bijzonder kan het MLMC helpen:\n- te begrijpen hoe de individuele en geaggregeerde verandering in de tijd verlopen;\n- verandering te verklaren met behulp van tijdsvariërende (bv. tijd) en tijdsconstante (b.v. geslacht) voorspellers;\n- variantie te ontleden in tussen- en binnen- variatie;\n- gemakkelijk om te gaan met continue tijd, onevenwichtige gegevens (niet alle individuen zijn op alle tijdstippen aanwezig) en verschillende timings (niet iedereen geeft gegevens op precies hetzelfde moment).\nHier volgt een korte inleiding op MLMC, hoe hiermee te werken in R en hoe veranderingen zijn te visualiseren.\nLaten we eerst de R-pakketten laden (deze moeten dus wel geïnstalleerd zijn). We zullen tidyverse gebruiken voor het opschonen en visualiseren van de data, lme4 voor het uitvoeren van de MLMC in R en sjstats voor het schatten van intra class correlation (icc)\nJe kunt pakketten installeren met het install.packages() commando.\nLaten we vervolgens de pakketten binnenhalen die wij bij deze analyse zullen gebruiken.\n\n# pakket voor dataopschonen en visualiseren\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.1.3\n\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv ggplot2 3.3.6     v purrr   0.3.4\nv tibble  3.1.7     v dplyr   1.0.9\nv tidyr   1.2.0     v stringr 1.4.1\nv readr   2.1.2     v forcats 0.5.1\n\n\nWarning: package 'ggplot2' was built under R version 4.1.3\n\n\nWarning: package 'tibble' was built under R version 4.1.3\n\n\nWarning: package 'tidyr' was built under R version 4.1.3\n\n\nWarning: package 'readr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\nWarning: package 'stringr' was built under R version 4.1.3\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\n# pakket voor multilevel-modeleren\nlibrary(lme4)\n\nWarning: package 'lme4' was built under R version 4.1.3\n\n\nLoading required package: Matrix\n\n\n\nAttaching package: 'Matrix'\n\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, pack, unpack\n\n# pakket om intra class correlation makkelijk vast te stellen\nlibrary(sjstats)\n\nLaten we, voordat we aan de MLMC beginnen, eerst kijken naar de data die we willen analyseren. Hier gebruik ik alcuse (alcoholgebruik) met drie metingen. Dit is een longitudinale dataset van 82 jongeren.\nWe willen weten hoe alcoholgebruik in de tijd verandert en we willen die verandering begrijpen. Hierbij maken we een onderscheid tussen tussenvariatie (hoe de jongeren ten opzichte van elkaar veranderen) en binnenvariatie (hoe jongeren veranderen ten opzichte van hun eigen gemiddelde/trend).\nLaten we deze gegevens eens onderzoeken. We kijken hiervoor naar de gegevens in lang formaat, die we zullen gebruiken voor de modellering en de grafieken. Hieronder zie je de eerste tien gegevens:\n\nalcohol1 <- read.table(\"https://stats.idre.ucla.edu/stat/r/examples/alda/data/alcohol1_pp.txt\", header=T, sep=\",\")\nattach(alcohol1)\nhead(alcohol1, n=10)\n\n   id age coa male age_14   alcuse      peer      cpeer  ccoa\n1   1  14   1    0      0 1.732051 1.2649111  0.2469111 0.549\n2   1  15   1    0      1 2.000000 1.2649111  0.2469111 0.549\n3   1  16   1    0      2 2.000000 1.2649111  0.2469111 0.549\n4   2  14   1    1      0 0.000000 0.8944272 -0.1235728 0.549\n5   2  15   1    1      1 0.000000 0.8944272 -0.1235728 0.549\n6   2  16   1    1      2 1.000000 0.8944272 -0.1235728 0.549\n7   3  14   1    1      0 1.000000 0.8944272 -0.1235728 0.549\n8   3  15   1    1      1 2.000000 0.8944272 -0.1235728 0.549\n9   3  16   1    1      2 3.316625 0.8944272 -0.1235728 0.549\n10  4  14   1    1      0 0.000000 1.7888544  0.7708544 0.549\n\n\nWe zien dat elke rij een combinatie is van een jongere (variabele id (van 1 tot en met 4, die we in de analyse gebruiken)) en tijd (variabele age_14, alcoholgebruik op 14-jarige leeftijd). Dit is ook het formaat dat we nodig hebben voor een visualisatie met ggplot2.\nOm te zien wat we gaan modelleren, kunnen we een eenvoudige grafiek maken met een gemiddelde veranderingslijn in tijd voor de hele dataset en een wirwar van lijnen voor de verandering van elk individu:\n\nggplot(alcohol1, aes(age, alcuse, group = id)) +\n  geom_line(alpha = 0.1) + # voeg individuele lijn met transparantie toe\n  stat_summary( # voeg gemiddelde lijn toe\n    aes(group = 1),\n    fun = mean,\n    geom = \"line\",\n    size = 1.0,\n    color = \"red\"\n  ) +\n  theme_bw() + # goed theme voor visualisatie\n  labs(x = \"Leeftijd\", y = \"Alcoholgebrui\") # de labels\n\n\n\n\nWe zien dus een hele lichte positieve en constante verandering in de tijd, maar vooral ook heel wat variatie in de manier waarop jongeren alcohol gebruiken (grijze lijnen). MLMC is in staat om beide dingen (het structurele en individuele) tegelijk te schatten!"
  },
  {
    "objectID": "posts/2022-01-03-multilevel-modeling/multilevel-modeling.html#wat-is-multilevel-modellering",
    "href": "posts/2022-01-03-multilevel-modeling/multilevel-modeling.html#wat-is-multilevel-modellering",
    "title": "Multilevel modeling",
    "section": "Wat is multilevel modellering?",
    "text": "Wat is multilevel modellering?\nMultilevel modellering is een uitbreiding van regressie modellering (‘just regression’) waarin we als het ware verschillende bronnen van variatie uit elkaar trekken. Waarom is dit belangrijk?\nTraditioneel gaat OLS-regressie er vanuit dat alle gevallen onafhankelijk zijn. Dit impliceert dat er geen correlatie is tussen de geobserveerde metingen als gevolg van zaken als clustering. Dit is vaak niet waar bij sociaal-wetenschappelijke gegevens. Individuen zijn bijvoorbeeld genest in huishoudens, klassen, buurten, regio’s en landen. Studenten zijn genest in klassen, scholen, regio’s en landen. Deze geneste structuur zorgt ervoor dat individuen op elkaar lijken. Zo zullen de gezondheidsuitkomsten waarschijnlijk vergelijkbaar zijn voor mensen die in dezelfde buurt wonen, vanwege bijvoorbeeld zelfselectie (vergelijkbaar inkomen en opleiding), kwaliteit van de gezondheidszorg of luchtkwaliteit. Als dit waar is, dan kunnen we mensen die uit dezelfde buurt komen niet als onafhankelijk behandelen.\nMultilevel modellering lost dit probleem op door willekeurige effecten (d.w.z. variatie) te schatten voor de verschillende niveaus die in de gegevens aanwezig zijn. Op die manier worden de regressiecoëfficiënten (zoals standaardfouten) gecorrigeerd voor deze geneste structuur. Bovendien kan met dit soort modellen worden geschat hoeveel variatie van elk niveau afkomstig is. Dit kan zeer informatief zijn. Door bijvoorbeeld de variatie van de leerlingresultaten uit elkaar te halen op leerlingniveau, klasniveau en schoolniveau, kunnen we begrijpen wat de belangrijkste factoren zijn die de uitkomsten van de leerlingen beïnvloeden. Dit kan informatie opleveren voor theorie en beleid.\n\nMultilevel modellering en longitudinale data\nLongitudinale data zijn ook genest. Metingen op verschillende tijdstippen zijn genest binnen een individu. Deze waarnemingen zijn niet onafhankelijk, omdat stabiele individuele kenmerken (zoals genen, persoonlijkheid of context) leiden tot consistente uitkomsten binnen de individuen en over de tijd. Multilevel modellering kan dus helpen corrigeren voor dit geklusterd karakter, maar helpt ons ook om twee belangrijke bronnen van variatie in longitudinale gegevens uit elkaar te halen: tussen-variatie (tussen individuen) en binnen-variatie (binnen het individu).\nTussen-variatie heeft betrekking op de manier waarop individuen van elkaar verschillen wat de belangrijke uitkomst betreft (bv. in dit geval dat het ene individu gemiddeld een hoger alcuse score heeft dan het andere individu). Terwijl binnen-variatie, de tweede vorm van variatie, betrekking heeft op de manier waarop alcuse op een bepaalde meting verschilt van het individuele gemiddelde (bv. hebben zij een lager of hoger score op alcoholgebruik in vergelijking met hun normale inkomen).\nLaten we, om deze vormen van variatie beter te begrijpen, eens naar de onderstaande grafieken kijken (een voor individu met idn=1 en de ander met idn=10).\n\nggplot(alcohol1, aes(age_14, alcuse)) +\n  stat_summary( # voeg gemiddelde lijn toe\n    aes(id = 1),\n    fun = mean,\n    geom = \"line\",\n    size = 1.0,\n    color = \"red\"\n  ) +\n  theme_bw() + # nice theme\n  labs(x = \"Leeftijd\", y = \"Alcoholgebruik_14\") # nice labels\n\nWarning: Ignoring unknown aesthetics: id\n\n\n\n\n\n\nggplot(alcohol1, aes(age_14, alcuse)) +\n  aes(id=10) + \n  stat_summary( # voeg gemiddelde lijn toe, Harrie: deze klopt nog niet\n    fun = mean,\n    geom = \"line\",\n    size = 1.0,\n    color = \"blue\"\n  ) +\n  theme_bw() + # nice theme\n  labs(x = \"Leeftijd\", y = \"Alcoholgebruik_14\") # nice labels\n\n\n\n\nHier zien we de twee alcuse-scores van twee individuen en de individuele trends over de tijd (drie metingen). We kunnen de variatie tussen de lijnen zien als het verschil tussen de lijnen. Dit vertelt ons of de trend voor het ene individu anders is dan voor het andere. Als deze bron van variatie 0 zou zijn, dan zouden alle lijnen gelijk zijn. Als individuen zeer verschillende lijnen hebben, dan zal dit een belangrijke bron van variatie zijn. Met interne variatie wordt het verschil bedoeld tussen de individuele trend en de bijbehorende waargenomen scores. Als deze bron van variatie 0 zou zijn, zouden we alcuse bij elke meting perfect voorspellen en zou er geen interne variatie zijn. variatie zijn. Hoe groter deze bron van variatie, hoe meer de individuele waarden buiten hun eigen trend schommelen.\n\n\nHet onvoorwaardelijke verandermodel (ook wel random effects genoemd)\nNu we wat basiskennis hebben van multilevel modellering en longitudinale gegevens kunnen we het uitproberen. Wij gaan gewoonlijk uit van een eenvoudig model dat enkel de binnen- en tussenvariatie wil scheiden. We kunnen het model definiëren als:\n\\(Y_ij=\\gamma_{00}+u_{01}+e_{ij}\\)\nWaarbij:\n\n\\(Y_{ij}\\) is de variabele van belang (bijvoorbeeld alcuse) en varieert per individu (i) en tijd (j)\n\n\\(\\gamma_{00}\\) is het intercept in de regressie. We kunnen dit interpreteren als het grote gemiddelde of het gemiddelde van de uitkomst over alle individuen en tijdstippen.\n\n\\(u_{0i}\\) is de tussenvariatie en vertelt ons hoe verschillend jongeren van elkaar zijn in hun alcoholgebruik-score. Als iedereen hetzelfde scoort op alcuse, zou dit 0 zijn. Hoe groter de verschillen, hoe groter deze coëfficiënt zal zijn en dus de variatie is.\n\n\\(e_{ij}\\) dit is het residu, maar heeft ook hier de interpretatie van binnenvariatie en vertelt ons hoeveel elk individu varieert rond zijn eigen gemiddelde. Hoe groter deze coëfficiënt, hoe meer individuen in hun uitkomsten op alcoholgebruik schommelen.\n\nNu we weten wat we willen modelleren, laten we eens kijken hoe we dat kunnen doen in R en met het pakket lme4. Voor het schatten van multilevel modellen zullen we het lmer()commando gebruiken. We moeten de data en de formule opgeven. Onze uitkomst is alcuse, dus dat staat aan de linkerkant van ~. Aan de rechterkant hebben we “1”, dat staat voor het intercept. Tussen haakjes definiëren we de willekeurige effecten. Hier zeggen we dat we het intercept (“1”) willen laten variëren per individu (| id). Dit alles leidt tot deze syntaxis:\n\n# random intercept model \nm0 <- lmer(data = alcohol1, alcuse ~ 1 + (1 | id))\n\n# resultaten checken\nsummary(m0)\n\nLinear mixed model fit by REML ['lmerMod']\nFormula: alcuse ~ 1 + (1 | id)\n   Data: alcohol1\n\nREML criterion at convergence: 673\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.8892 -0.3079 -0.3029  0.6111  2.8562 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n id       (Intercept) 0.5731   0.7571  \n Residual             0.5617   0.7495  \nNumber of obs: 246, groups:  id, 82\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)   0.9220     0.0963   9.574\n\n\nLaten we de belangrijkste coëfficienten eens interpreteren:\n\nonder “Fixed effects” hebben we het “(Intercept)”, dat het grote gemiddelde is (\\(\\gamma_{00}\\) en ons vertelt dat over alle tijdstippen en individuen de gemiddelde score 0.922 is.\n\n“Random effects” vertegenwoordigt alles dat varieert met id, de tussen-variatie. In dit geval is de tussenvariatie voor het intercept (\\(\\beta_{0i}\\)) 0.573\n\nonder “Random effects” vertegenwoordigt de “Residual”-coëfficiënt de binnen-variatie. In dit geval is de binnen variatie voor het intercept \\(e_{ij}\\) 0.562\n\nOm de tussen en binnen-variantie beter te begrijpen, berekenen we InterClass Coefficient (ICC), dat is de tussen-variatie gedeeld door de totale variatie (tussen en binnen-variatie opgeteld). Dit berekenen we met het sjstats-pakket waarmee we het percentage tussenvariatie berekenen van het m0-model (51%), het percentage variatie dat door de groep kan worden verklaard.\n\nicc(m0)\n\nWarning: 'icc' is deprecated.\nUse 'performance::icc()' instead.\nSee help(\"Deprecated\")\n\n\n# Intraclass Correlation Coefficient\n\n    Adjusted ICC: 0.505\n  Unadjusted ICC: 0.505\n\n\nDit is dus gewoon een verhouding van de tussen-variatie op de totale variatie en vertelt ons welk deel van de variatie tussen individuen is. In ons geval blijkt dat ongeveer 51% van de variatie in alcuse tussen jongeren komt, terwijl de resterende (~ 49%) binnen jongeren ligt. In wezen zou dit erop wijzen dat de verschillen op alcoholgebruik tussen jongeren net iets belangrijker zijn dan de verschillen op alcoholgebruik binnen jongeren.\nOm beter te begrijpen wat het model doet, kunnen we de scores voorspellen en een grafiek maken met de voorspelde individuele score (lijnen) en de waargenomen scores (punten) voor vijf individuen:\n\n# basis voor voorspelling\nalcohol1$pred_m0 <- predict(m0)\n\n\nalcohol1 %>% \n  filter(id %in% 1:5) %>% # haal er vijf jongeren uit, kunnen ook andere jongeren zijn\n  ggplot(aes(age, pred_m0, color = id)) +\n  geom_point(aes(age, alcuse)) + # punten voor de geobserveerde alcgebruik-Totaal-scores\n  geom_smooth(method = lm, se = FALSE) + # liniaire lijn voor voorspellen\n  theme_bw() + # mooi thema\n  labs(x = \"Leeftijd\", y = \"Alcoholgebruik\") + # Labels toevoegen\n  theme(legend.position = \"none\") # geen legenda\n\n`geom_smooth()` using formula 'y ~ x'\n\n\n\n\n\n\n\nHet model van onvoorwaardelijke verandering\nHet vorige model is nuttig om ons een idee te geven van hoeveel variatie we op elk niveau hebben, maar we willen ook kijken naar verandering in de tijd! Laten we het model dus uitbreiden:\n\\(Y_{ij}=\\gamma_{00}+ \\gamma_{10}*Meting_{ij}+ u_{0i}+e_{ij}\\)\nIn dit model voegen we tijd (metingen van veertienjarige leeftijd gemeten) toe als voorspeller. Nu stelt \\(\\gamma_{00}\\) de gemiddelde score op alcoholgebruik voor wanneer de tijd 0 (alcoholgebruik op veertien jarige leeftijd) is, terwijl \\(\\gamma_{10}\\) het veranderingspercentage van alcoholgebruik voorstelt wanneer de tijd met 1 toeneemt.\nOm de zaken gemakkelijker te interpreteren, is het belangrijk te beginnen bij 0 zodat de \\(\\gamma_{00}\\) de mooie interpretatie heeft van verwacht alcoholgebruik aan het begin van de studie. De tijdsvariabele ‘age_14’ (alcoholgebruik op 14-jarige leeftijd) kent al de waarden 0, 1 en 2\nNu kunnen we ons model uitvoeren. We voegen gewoon de nieuwe tijdsvariabele toe als een fixed effect:\n\n# unconditionele veranderings model nu (a.k.a. MLMC)\nm1 <- lmer(data = alcohol1, alcuse ~ 1 + age_14 + (1 | id))\nsummary(m1)\n\nLinear mixed model fit by REML ['lmerMod']\nFormula: alcuse ~ 1 + age_14 + (1 | id)\n   Data: alcohol1\n\nREML criterion at convergence: 654.1\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-2.19816 -0.66940  0.03001  0.44728  2.66167 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n id       (Intercept) 0.5966   0.7724  \n Residual             0.4915   0.7011  \nNumber of obs: 246, groups:  id, 82\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)  0.65130    0.11077   5.880\nage_14       0.27065    0.05474   4.944\n\nCorrelation of Fixed Effects:\n       (Intr)\nage_14 -0.494\n\n\nEen belangrijk verschil met het vorig model zit in het fixed effects-deel. Nu interpreteren wij het intercept (0.651) als het verwachte alcoholgebruik-score aan het begin van de studie (wanneer ze veertien jaar zijn, age_14=0). Het effect van een jaar extra, 0.271, vertelt ons de gemiddelde veranderingssnelheid bij ieder van de twee metingen. De score op alcoholgebruik neemt dus elk jaar met 0.271 toe.\nLaten we de resultaten opnieuw visualiseren op basis van het nieuwe model:\n\n# De basis voor voorspelling van dit model\nalcohol1$pred_m1 <- predict(m1)\n\n\nalcohol1 %>% \n  filter(id %in% 1:5) %>% # selecteer weer 5 individuen\n  ggplot(aes(age_14, pred_m1, color = id)) +\n  geom_point(aes(age_14, alcuse)) + # observatiepunten voor VeerkrachtTotaal\n  geom_smooth(method = lm, se = FALSE) + # lineaire lijn gebaseerd op voorspelling\n  theme_bw() + # mooi thema\n  labs(x = \"Leeftijd\", y = \"Alcoholgebruik\") + # goede labels\n  theme(legend.position = \"none\") # legenda verstoppen\n\n`geom_smooth()` using formula 'y ~ x'\n\n\n\n\n\nNu zien we dat we twee vormen van tussenvariatie hebben. De coëfficiënt \\(u_{0i}\\) vertegenwoordigt de tussenvariatie aan het begin van het onderzoek terwijl \\(u_{1i}\\) de tussenvariatie in het tempo van de verandering vertegenwoordigt. Dit betekent dat we toestaan dat individuen verschillende alcoholgebruik-scores aan het begin hebben (age_14=0), maar ook verschillende trends laten zien.\nDit model willen we met lme4 uitvoeren. We kunnen eenvoudigweg “meting” of in dit geval “jaartal” toevoegen aan het willekeurige deel van het model:\nWe zien nu dus een positieve trend die te wijten is aan de tijdscoëfficiënt. De individuele lijnen lopen, algemeen gezegd, hier parallel aan. We nemen nu aan dat de verandering in de tijd voor alle individuen gelijk is. In meer technische termen nemen we aan dat er geen tussenvariatie is in de snelheid van verandering. Dat is een vrij sterke veronderstelling. In ons geval zouden we dat niet verwachten gezien de eerste grafiek die we hebben gemaakt (en die individuele lijnen die verschillende kanten opgingen). Laten we het model dus uitbreiden met de tussenvariatie in de veranderingssnelheid:\n\\(Y_{ij}=\\gamma_{00}+\\gamma_{10}*Meting_{ij}+u_{0i}+u_{1i}*Meting_{ij}+e{ij}\\)\nNu zien we dat we twee bronnen van tussenvariatie hebben. De coëfficiënt \\(u_0i\\) vertegenwoordigt de tussenvariatie aan het begin van de studie terwijl \\(u_1i\\) de tussenvariatie in het tempo van verandering vertegenwoordigt. Dit betekent dat we toestaan dat individuen verschillen in alcoholgebruik aan het begin, maar ook verschillende trends kunnen kunnen laten zien.\nOm een dergelijk model in lme4 uit te voeren. We kunnen eenvoudigweg “tijd” (age_14) toevoegen aan het willekeurige deel van het model:\n\n# unconditional change model (a.k.a. MLMC) with re for change\nm2 <- lmer(data = alcohol1, alcuse ~ 1 + age_14 + (1 + age_14 | id))\nsummary(m2)\n\nLinear mixed model fit by REML ['lmerMod']\nFormula: alcuse ~ 1 + age_14 + (1 + age_14 | id)\n   Data: alcohol1\n\nREML criterion at convergence: 643.2\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-2.48287 -0.37933 -0.07858  0.38876  2.49284 \n\nRandom effects:\n Groups   Name        Variance Std.Dev. Corr \n id       (Intercept) 0.6355   0.7972        \n          age_14      0.1552   0.3939   -0.23\n Residual             0.3373   0.5808        \nNumber of obs: 246, groups:  id, 82\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)  0.65130    0.10573   6.160\nage_14       0.27065    0.06284   4.307\n\nCorrelation of Fixed Effects:\n       (Intr)\nage_14 -0.441\n\n\nIn de resultaten zien we dat het random deel van het model nu twee coëfficiënten heeft die variëren naar id. Het “(Intercept)”, 0.65130, staat voor de variatie tussen het beginpunt van het onderzoek (\\(\\gamma_{0i})\\), terwijl de coëfficiënt voor age_14, 0.271, staat voor de variatie tussen de veranderingssnelheden ( \\(\\gamma_{1i}\\) ).\nAls wij nu de voorspellingen onderzoeken, zien wij dat individuen zowel verschillende beginpunten als verschillende trends mogen hebben:\n\n# laten we basis voor voorspelling definieren\nalcohol1$pred_m2 <- predict(m2)\n\n\nalcohol1 %>% \n  filter(id %in% 1:5) %>% # selecteer enkele individuen\n  ggplot(aes(age_14, pred_m2, color = id)) +\n  geom_point(aes(age_14, alcuse)) + # punten van geobserveerde VeerkrachtTotaal\n  geom_smooth(method = lm, se = FALSE) + # liniaire lijn voor voorspelling\n  theme_bw() + # mooi thema\n  labs(x = \"Leeftijd\", y = \"Alcoholgebruik\") + # goede labels\n  theme(legend.position = \"none\") # legenda verbergen\n\n`geom_smooth()` using formula 'y ~ x'\n\n\n\n\n\nHoe groter de \\(e_{0i}\\)-coëfficiënt, hoe groter het verschil tussen de mensen aan het begin van het onderzoek, terwijl een grotere \\(e_{1i}\\) op meer uiteenlopende veranderingssnelheden wijst.\n\n\nConclusies\nDit geeft een idee wat multilevel model voor verandering ons in onderzoek kan bieden, hoe je het kunt schatten in R en hoe je deze verandering kunt visualiseren. Dit model is vergelijkbaar met het Latent Growth Model (Latent Groei Model) en daar zal ik ook een stukje over schrijven.\nMet dank aan Alexander Cernat"
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#data-voorbeeld",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#data-voorbeeld",
    "title": "Multilevel modeling met STAN",
    "section": "Data voorbeeld",
    "text": "Data voorbeeld\nZe analyseren de Gcsemv dataset (Rasbash et al. 2000) uit het mlmRev pakket in R. De gegevens omvatten de GCSE-examenscores (General Certificate of Secondary Education) van 1.905 leerlingen van 73 scholen in Engeland op een natuurwetenschappelijk vak. De Gcsemv-dataset bestaat uit de volgende 5 variabelen:\n\nschool: schoolidentificatiecode\n\nstudent: identificatiecode student\n\ngender: geslacht van een leerling (M: Man, F: Vrouw)\n\nwritten: totaalscore op schriftelijk werkstuk\ncourse: totaalscore op schriftelijk werkstuk\n\n\n# Use example dataset from mlmRev package: GCSE exam score\ndata(Gcsemv, package = \"mlmRev\")\nsummary(Gcsemv)\n\n     school        student     gender      written          course      \n 68137  : 104   77     :  14   F:1128   Min.   : 0.60   Min.   :  9.25  \n 68411  :  84   83     :  14   M: 777   1st Qu.:37.00   1st Qu.: 62.90  \n 68107  :  79   53     :  13            Median :46.00   Median : 75.90  \n 68809  :  73   66     :  13            Mean   :46.37   Mean   : 73.39  \n 22520  :  65   27     :  12            3rd Qu.:55.00   3rd Qu.: 86.10  \n 60457  :  54   110    :  12            Max.   :90.00   Max.   :100.00  \n (Other):1446   (Other):1827            NA's   :202     NA's   :180     \n\n\nTwee onderdelen van het examen werden geregistreerd als uitkomstvariabelen: schriftelijk werkstuk (written) en cursuswerkstuk (course). In deze tutorial wordt alleen de totaalscore op het cursuswerkstuk (course) geanalyseerd. Zoals hierboven te zien is, ontbreken er bij sommige waarnemingen waarden voor bepaalde covariaten. Hoewel we de data niet subsetten om alleen volledige gevallen op te nemen om aan te tonen dat rstanarm deze waarnemingen automatisch laat vallen, is het over het algemeen een goed gebruik om dit handmatig te doen indien nodig.\n\n# Maak Male dereferentiecategorie en hernoem de variabele\nGcsemv$female <- relevel(Gcsemv$gender, \"M\")\n\n\n# Gebruik alleen de totaalscore op course \nGCSE <- subset(x = Gcsemv, \n               select = c(school, student, female, course))\n\n# Tel unieke scholen en studenten\nJ <- length(unique(GCSE$school))\nN <- nrow(GCSE)\n\nHet pakket rstanarm automatiseert verschillende stappen van datavoorbewerking, waardoor het gebruik ervan sterk lijkt op dat van lme4 en wel op de volgende manier.\n\nInput - rstanarm kan een dataframe als input nemen2.\nOntbrekende gegevens - rstanarm verwijdert automatisch waarnemingen met NA waarden voor elke variabele gebruikt in het model3.\nIdentifiers - rstanarm vereist niet dat identifiers opeenvolgend zijn4. We stellen voor dat het een goede gewoonte is om alle cluster- en unit-identifiers, evenals categorische variabelen als factoren op te slaan. Dit geldt evenzeer voor lme4 als voor rstanarm. Men kan de structuur van de variabelen controleren met behulp van de str() functie.\n\n\n# Check structure of data frame\nstr(GCSE)\n\n'data.frame':   1905 obs. of  4 variables:\n $ school : Factor w/ 73 levels \"20920\",\"22520\",..: 1 1 1 1 1 1 1 1 1 2 ...\n $ student: Factor w/ 649 levels \"1\",\"2\",\"3\",\"4\",..: 16 25 27 31 42 62 101 113 146 1 ...\n $ female : Factor w/ 2 levels \"M\",\"F\": 1 2 2 2 1 2 2 1 1 2 ...\n $ course : num  NA 71.2 76.8 87.9 44.4 NA 89.8 17.5 32.4 84.2 ..."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-1-variërend-intercept-model-zonder-voorspellers-variantiecomponentenmodel",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-1-variërend-intercept-model-zonder-voorspellers-variantiecomponentenmodel",
    "title": "Multilevel modeling met STAN",
    "section": "Model 1: Variërend intercept model zonder voorspellers (Variantiecomponentenmodel)",
    "text": "Model 1: Variërend intercept model zonder voorspellers (Variantiecomponentenmodel)\nBeschouw het eenvoudigste multilevel model voor leerlingen \\(i=1,...,n\\) genest binnen scholen \\(j=1,...,J\\) en voor wie we examenresultaten als respons hebben. We kunnen een variabel interceptmodel met twee niveaus zonder voorspellers schrijven met de gebruikelijke tweedelige formulering als\n\\[Y_{ij}=\\alpha_{j} + \\epsilon_{ij}, \\text{ where } \\epsilon{ij} \\sim N(0,\\sigma^2_{y}) \\] \\[\\alpha{_j}=u_{\\alpha} + u_{j}, \\text { where } \\epsilon{ij} \\sim N(0,\\sigma^2_{y})\\]\nwaarin \\(yij\\) de examenscore is voor de \\(ith\\) leerling op de \\(jth\\) school, \\(\\alpha_{j}\\) de variërende intercept voor de jde school, en \\(u_{a}\\) het algemene gemiddelde voor alle scholen. Als alternatief kan het model in verkorte vorm worden uitgedrukt als\n\\[y_{ij}=u_{a} + u_{j} = \\epsilon_{ij}\\] Als we verder aannemen dat de fouten op leerlingniveau \\(\\epsilon_{ij}\\) normaal verdeeld zijn met gemiddelde 0 en variantie \\(\\sigma^2_{y}\\), en dat de variërende intercepten op schoolniveau \\(\\alpha_j\\) normaal verdeeld zijn met gemiddelde \\(u_{a}\\) en variantie \\(\\sigma^2_{a}\\), dan kan het model worden uitgedrukt als\n\\[y_{ij}∼ N(\\alpha_{j},\\sigma^2_{y})\\]\n\\[a_{j}∼ N(u_{a},\\sigma^2_{a})\\]\nDit model kan dan worden aangepast met lmer(). We specificeren een intercept (de voorspeller “1”) en laten deze variëren met de niveau-2-identifier (school). We specificeren ook de REML = FALSE optie om maximum likelihood (ML) schattingen te krijgen in plaats van de standaard restricted maximum likelihood (REML) schattingen.\n\nM1 <- lmer(formula = course ~ 1 + (1 | school), \n           data = GCSE, \n           REML = FALSE)\nsummary(M1)\n\nLinear mixed model fit by maximum likelihood  ['lmerMod']\nFormula: course ~ 1 + (1 | school)\n   Data: GCSE\n\n     AIC      BIC   logLik deviance df.resid \n 14111.4  14127.7  -7052.7  14105.4     1722 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-4.9693 -0.5101  0.1116  0.6741  2.7613 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n school   (Intercept)  75.24    8.674  \n Residual             190.77   13.812  \nNumber of obs: 1725, groups:  school, 73\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)    73.72       1.11    66.4\n\n\n\n\n\n\n\n\nOnder Fixed effects zien we dat het intercept \\(u_{a}\\), gemiddeld over de populatie van scholen, wordt geschat op 73,72. Onder Random-effects zien we dat de standaardafwijking tussen de scholen \\(\\sigma_{a}\\) wordt geschat op \\(8.67\\) en de standaardafwijking binnen de scholen \\(\\sigma_{y}\\) op \\(13.81\\)."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-2-variërend-intercept-model-met-een-enkele-voorspeller",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-2-variërend-intercept-model-met-een-enkele-voorspeller",
    "title": "Multilevel modeling met STAN",
    "section": "Model 2: Variërend intercept model met een enkele voorspeller",
    "text": "Model 2: Variërend intercept model met een enkele voorspeller\nHet variërende interceptmodel5 met een indicatorvariabele voor het vrouwzijn xij kan worden geschreven als\n\\[Y_{ij}∼N(a_{j}+\\beta x{ij}, \\sigma^2_{y}),\\]\n\\[a_{j}∼N(u_{a}, \\sigma^2_{a})\\].\nDe vergelijking van de gemiddelde regressielijn voor alle scholen is \\(u_{ij}=u_{α}+βxij\\). De regressielijnen voor specifieke scholen zullen evenwijdig zijn aan de gemiddelde regressielijn (met dezelfde helling β), maar verschillen wat betreft het intercept \\(a_{j}\\). Dit model kan geschat worden door vrouwelijk toe te voegen aan de formule in de lmer() functie, waardoor alleen het intercept per school varieert en de “helling” voor vrouwelijkheid constant blijft voor alle scholen\n\nM2 <- lmer(formula = course ~ 1 + female + (1 | school), \n           data = GCSE, \n           REML = FALSE)\nsummary(M2)\n\nLinear mixed model fit by maximum likelihood  ['lmerMod']\nFormula: course ~ 1 + female + (1 | school)\n   Data: GCSE\n\n     AIC      BIC   logLik deviance df.resid \n 14017.4  14039.2  -7004.7  14009.4     1721 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-4.7809 -0.5401  0.1259  0.6795  2.6753 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n school   (Intercept)  76.65    8.755  \n Residual             179.96   13.415  \nNumber of obs: 1725, groups:  school, 73\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)   69.730      1.185   58.87\nfemaleF        6.739      0.678    9.94\n\nCorrelation of Fixed Effects:\n        (Intr)\nfemaleF -0.338\n\n\n\n\n\nDe gemiddelde regressielijn over de scholen wordt dus geschat als \\(\\hat{\\mu}_{ij}=69.73+ 6.74 x_{ij}\\), waarbij \\(\\sigma_\\_alpha\\) en \\(\\sigma_y\\) worden geschat als respectievelijk \\(8.76\\) en \\(13.41\\). Als we deze schattingen van \\(\\mu_alpha\\), \\(\\beta\\), \\(\\sigma^2_{y}\\), en \\(\\sigma^2_{alpha}\\) als de ware parameterwaarden beschouwen, kunnen we de **Best Linear Unbiased Predictions (BLUPs) voor de fouten op schoolniveau \\(\\hat{u}_j = \\hat{\\alpha}_{j} - \\hat{\\mu}_{\\alpha}\\) verkrijgen.\nDe BLUPs zijn equivalent met de zogenaamde Empirical Bayes (EB)-voorspelling, die het gemiddelde is van de posterieure verdeling van \\(u_{j}\\) gegeven alle geschatte parameters, alsmede de willekeurige variabelen \\(y_{ij}\\) en \\(x_{ij}\\) voor het cluster. Deze voorspellingen worden “Bayes” genoemd omdat ze gebruik maken van de vooraf gespecificeerde prioriteitsverdeling1 \\(u_j \\sim N(\\mu_\\alpha, \\sigma^2_\\alpha)\\), en bij uitbreiding \\(u_j \\sim N(0, \\sigma^2_\\alpha)\\), en “Empirisch” genoemd omdat de parameters van deze prior, \\(\\mu_\\alpha\\) en \\(\\sigma^2_{\\alpha}\\), naast \\(\\beta\\) en \\(\\sigma^2_{y}\\), geschat worden uit de data.\nIn vergelijking met de ML-benadering (Maximum Likelihood - maximale waarschijnlijkheid), waarbij waarden voor \\(u_j\\) worden voorspeld door alleen de geschatte parameters en gegevens van cluster \\(j\\) te gebruiken, houdt de EB-benadering bovendien rekening met de voorafgaande verdeling van \\(u_{j}\\), en levert zij voorspelde waarden op die dichter bij \\(0\\) liggen (een verschijnsel dat wordt beschreven als shrinkage of partial pooling). Om te zien waarom dit verschijnsel shrinkage wordt genoemd, drukken we de uit EB voorspelling verkregen schattingen voor \\(u_j\\) gewoonlijk uit als \\(\\hat{u}_j^{text{EB}} = \\hat{R}_j\\hat{u}_j^{\\text{ML}}\\) waarbij \\(\\hat{u}_j^{\\text{ML}}\\) de ML schattingen zijn, en \\(\\hat{R}_j = \\frac{\\sigma_alpha^2}{n_j}\\) de zogenaamde Shrinkage factor is.\n\nhead(ranef(M2)$school)\n\n      (Intercept)\n20920 -10.1702110\n22520 -17.0578149\n22710   7.8007260\n22738   0.4871012\n22908  -8.1940346\n23208   4.4304453\n\n\nDeze waarden schatten hoeveel het intercept naar boven of beneden verschoven is in bepaalde scholen. Bijvoorbeeld, in de eerste school in de dataset is het geschatte intercept ongeveer 10.17 lager dan gemiddeld, zodat de schoolspecifieke regressielijn \\((69.73 - 10.17) + 6.74 x_{ij}\\) is.\nGelman&Hill (2006) karakteriseren multilevel modellering als partial pooling (ook wel shrinkage genoemd), wat een compromis is tussen twee uitersten: complete pooling, waarbij de clustering helemaal niet in het model wordt meegenomen, en no pooling, waarbij voor elke school aparte intercepten worden geschat als coëfficiënten van dummy-variabelen. De geschatte schoolspecifieke regressielijnen in het bovenstaande model zijn gebaseerd op partial pooling schattingen. Om dit aan te tonen, schatten we eerst de intercept en de helling voor elke school op drie manieren:\n\n# Complete-pooling regression\npooled <- lm(formula = course ~ female,\n             data = GCSE)\na_pooled <- coef(pooled)[1]   # complete-pooling intercept\nb_pooled <- coef(pooled)[2]   # complete-pooling slope\n\n# No-pooling regression\nnopooled <- lm(formula = course ~ 0 + school + female,\n               data = GCSE)\na_nopooled <- coef(nopooled)[1:J]   # 73 no-pooling intercepts              \nb_nopooled <- coef(nopooled)[J+1]\n\n# Partial pooling (multilevel) regression\na_part_pooled <- coef(M2)$school[, 1]\nb_part_pooled <- coef(M2)$school[, 2]\n\nVervolgens plotten we de gegevens en schoolspecifieke regressielijnen voor een selectie van acht scholen met behulp van de volgende commando’s.2:\n\n# (0) Assen plaatsen & scholen kiezen\ny <- GCSE$course\nx <- as.numeric(GCSE$female) - 1 + runif(N, -.05, .05)\nschid <- GCSE$school\nsel.sch <- c(\"65385\",\n             \"68207\",\n             \"60729\",\n             \"67051\",\n             \"50631\",\n             \"60427\",\n             \"64321\",\n             \"68137\")\n\n# (1) Subset 8 van de scholen; genereer data frame\ndf <- data.frame(y, x, schid)\ndf8 <- subset(df, schid %in% sel.sch)\n\n# (2) Aangeven van schattingen van volledige-pooling, geen-pooling, gedeeltelijke pooling \ndf8$a_pooled <- a_pooled \ndf8$b_pooled <- b_pooled\ndf8$a_nopooled <- a_nopooled[df8$schid]\ndf8$b_nopooled <- b_nopooled\ndf8$a_part_pooled <- a_part_pooled[df8$schid]\ndf8$b_part_pooled <- b_part_pooled[df8$schid]\n\n# (3) Plot van hoe regressie fit voor de 8 scholen\nggplot(data = df8, \n       aes(x = x, y = y)) + \n  facet_wrap(facets = ~ schid, \n             ncol = 4) + \n  theme_bw() +\n  geom_jitter(position = position_jitter(width = .05, \n                                         height = 0)) +\n  geom_abline(aes(intercept = a_pooled, \n                  slope = b_pooled), \n              linetype = \"solid\", \n              color = \"blue\", \n              size = 0.5) +\n  geom_abline(aes(intercept = a_nopooled, \n                  slope = b_nopooled), \n              linetype = \"longdash\", \n              color = \"red\", \n              size = 0.5) + \n  geom_abline(aes(intercept = a_part_pooled, \n                  slope = b_part_pooled), \n              linetype = \"dotted\", \n              color = \"purple\", \n              size = 0.7) + \n  scale_x_continuous(breaks = c(0, 1), \n                     labels = c(\"male\", \"female\")) + \n  labs(title = \"Schatting van Volledige-pooling, Geen-pooling en Gedeeltelijke pooling\",\n       x = \"\", \n       y = \"Totale score op cursuswerk paper\")+theme_bw( base_family = \"serif\")\n\n\n\n\nDe blauw-gestreepte, rood-gestreepte en paars-gestippelde lijnen geven respectievelijk de volledige pooling, no-pooling en gedeeltelijke pooling schattingen weer. We zien dat de geschatte schoolspecifieke regressielijn van de gedeeltelijke pooling-schattingen tussen de volledige pooling- en de geenpooling-regressielijn ligt. Er is meer pooling (paarse stippellijn dichter bij blauwe ononderbroken lijn) op scholen met een kleine steekproefomvang."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-3-variërend-intercept-en-slope-model-met-een-enkele-voorspeller",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-3-variërend-intercept-en-slope-model-met-een-enkele-voorspeller",
    "title": "Multilevel modeling met STAN",
    "section": "Model 3: Variërend intercept en slope model met een enkele voorspeller",
    "text": "Model 3: Variërend intercept en slope model met een enkele voorspeller\nWe breiden nu het variërende interceptmodel met één voorspeller uit om zowel het intercept als de helling willekeurig te laten variëren tussen scholen met behulp van het volgende model \\[y_{ij} = \\alpha_j + \\beta_j x_{ij} +\\epsilon_{ij},\\] \\[\\alpha_j = \\mu_\\alpha + u_j,\\] \\[\\beta_j = \\mu_\\beta + v_j,\\] or in a reduced form as \\[y_{ij} = \\mu_\\alpha + \\mu_\\beta x_{ij} + u_j + v_j x_{ij} + \\epsilon_{ij}\\] where \\(\\epsilon_{ij} \\sim N(0, \\sigma_{y}^{2})\\) and \\(\\left( \\begin{matrix} u_j \\\\ v_j \\end{matrix} \\right) \\sim N\\left( \\left( \\begin{matrix} 0 \\\\ 0 \\end{matrix} \\right) ,\\left( \\begin{matrix} { \\sigma }_{ \\alpha }^{ 2 } & \\rho { \\sigma }_{ \\alpha }{ \\sigma }_{ \\beta } \\\\ \\rho { \\sigma }_{ \\alpha }{ \\sigma }_{ \\beta } & { \\sigma }_{ \\beta }^{ 2 } \\end{matrix} \\right) \\right)\\).]:\n\\[y_{ij}\\sim N(\\alpha_{j}+\\beta_{j}x_{ij} , \\sigma_y ^2 ),\\] \\[\\left( \\begin{matrix} \\alpha _{ j } \\\\ \\beta _{ j } \\end{matrix} \\right) \\sim N\\left( \\left( \\begin{matrix} { \\mu  }_{ \\alpha  } \\\\ { \\mu  }_{ \\beta  } \\end{matrix} \\right) , \\left( \\begin{matrix} { \\sigma  }_{ \\alpha  }^{ 2 } & \\rho { \\sigma  }_{ \\alpha  }{ \\sigma  }_{ \\beta  } \\\\ \\rho { \\sigma  }_{ \\alpha  }{ \\sigma  }_{ \\beta  } & { \\sigma  }_{ \\beta  }^{ 2 } \\end{matrix} \\right)  \\right).\\]\nMerk op dat we nu variatie hebben in de \\(\\alpha_{j}\\)’s en de \\(\\beta_{j}\\)’s, en ook een correlatie parameter \\(\\rho\\) tussen \\(\\alpha_{j}\\) en \\(\\beta_{j}\\). Dit model kan gefit worden met gebruik van lmer() en wel als volgt:\n\nM3 <- lmer(formula = course ~ 1 + female + (1 + female | school), \n           data = GCSE, \n           REML = FALSE)\nsummary(M3) \n\nLinear mixed model fit by maximum likelihood  ['lmerMod']\nFormula: course ~ 1 + female + (1 + female | school)\n   Data: GCSE\n\n     AIC      BIC   logLik deviance df.resid \n 13983.4  14016.2  -6985.7  13971.4     1719 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-4.6886 -0.5222  0.1261  0.6529  2.6729 \n\nRandom effects:\n Groups   Name        Variance Std.Dev. Corr \n school   (Intercept) 102.93   10.146        \n          femaleF      47.94    6.924   -0.52\n Residual             169.79   13.030        \nNumber of obs: 1725, groups:  school, 73\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)   69.425      1.352  51.338\nfemaleF        7.128      1.131   6.302\n\nCorrelation of Fixed Effects:\n        (Intr)\nfemaleF -0.574\n\n\n\n\n\nIn dit model wordt de residuele standaardafwijking binnen de school geschat als \\(\\hat{\\sigma}_{y}=\\) 13.03. De geschatte standaardafwijkingen van de schoolintercepten en de schoolhellingen zijn respectievelijk \\(\\hat{\\sigma}_{\\alpha}= 10.15\\) en \\(\\hat{\\sigma}_{\\beta}= 6.92\\). De geschatte correlatie tussen variërende intercepts en hellingen is \\(\\hat{\\rho} = -0.52\\). We kunnen een soortgelijke code als die in paragraaf 2.2 gebruiken om de gegevens en de schoolspecifieke regressielijnen voor een selectie van acht scholen te plotten."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#gebruik-van-het-rstanarm-pakket",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#gebruik-van-het-rstanarm-pakket",
    "title": "Multilevel modeling met STAN",
    "section": "Gebruik van het rstanarm pakket",
    "text": "Gebruik van het rstanarm pakket\nVeel relatief eenvoudige modellen kunnen worden aangepast met behulp van het rstanarm pakket zonder enige code te schrijven in de Stan taal. Het rstanarm pakket is een “wrapper” voor het rstan pakket waarmee de meest gebruikte regressiemodellen kunnen worden geschat met behulp van Markov Chain Monte Carlo (MCMC) en toch kunnen worden gespecificeerd met de gebruikelijke R modelleersyntaxis. Onderwijs onderzoekers kunnen Bayesiaanse schatting gebruiken voor multilevel modellen met slechts minimale veranderingen in hun bestaande code met lmer().\nBijvoorbeeld, Model 1 met standaard prior verdelingen voor \\(\\mu_{\\alpha}\\), \\(\\sigma_{\\alpha}\\), en \\(\\sigma_{y}\\) kan worden gespecificeerd met het rstanarm pakket door stan_ toe te voegen aan de lmer aanroep:\n\nM1_stanlmer <- stan_lmer(formula = course ~ 1 + (1 | school), \n                         data = GCSE,\n                         seed = 349)\n\nDeze stan_lmer() functie is qua syntax gelijk aan lmer(), maar in plaats van een maximum likelihood schatting uit te voeren, wordt een Bayesiaanse schatting uitgevoerd via MCMC. Omdat elke stap in de MCMC schatting random trekkingen uit de parameter ruimte inhoudt, voegen we een seed optie toe om ervoor te zorgen dat stan_lmer elke keer dat de code wordt uitgevoerd, dezelfde resultaten geeft."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#prior-distributies",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#prior-distributies",
    "title": "Multilevel modeling met STAN",
    "section": "Prior distributies",
    "text": "Prior distributies\nModel 1 is een variabel interceptiemodel met normaal verdeelde leerlingresiduen en intercepten op schoolniveau: \\(y_{ij} \\sim N(\\alpha_{j}, \\sigma_{y}^{2}),\\) en \\(\\alpha_{j},\\sim N(\\mu_{alpha}, \\sigma_{alpha}^{2})\\). De normale verdeling voor de \\(\\alpha{j}\\)’s kan worden beschouwd als een prioriteitsverdeling voor deze variërende intercepten. De parameters van deze prior verdeling, \\(\\mu_{\\alpha}\\) en \\(\\sigma_{\\alpha}\\), worden geschat uit de gegevens bij gebruik van maximum likelihood schatting. Bij volledige Bayesiaanse inferentie hebben alle hyperparameters (\\(\\mu_{\\alpha}\\) en \\(\\sigma_{\\alpha}\\)), samen met de andere niet-gemodelleerde parameters (in dit geval, \\(\\sigma_{y}\\)) ook een priorverdeling nodig.\nHier gebruiken we de standaard prior verdelingen voor de hyperparameters in stan_lmer door geen prior opties op te geven in stan_lmer() functie. De standaard priors zijn bedoeld als zwak informatief in de zin dat ze gematigde regularisatie bieden [Regularisatie kan worden beschouwd als een techniek om ervoor te zorgen dat schattingen binnen een acceptabel bereik van waarden worden begrensd] en helpen bij het stabiliseren van de berekening. Opgemerkt moet worden dat de auteurs van rstanarm suggereren om niet te vertrouwen op rstanarm om de standaard prior voor een model te specificeren, maar eerder om de priors expliciet te specificeren, zelfs als ze inderdaad de huidige standaard zijn, aangezien updates van het pakket andere defaults mee kunnen krijgen.\nTen eerste wordt, alvorens rekening te houden met de schaal van de variabelen, \\(\\mu_{alpha}\\) een normale priorverdeling gegeven met gemiddelde 0 en standaardafwijking 10. Dat wil zeggen, \\(mu_{alpha} \\sim N(0, 10^2)\\). De standaardafwijking van deze prioriteitsverdeling, 10, is vijf keer zo groot als de standaardafwijking van de respons indien deze gestandaardiseerd zou zijn. Dit zou een dichte benadering moeten zijn van een niet-informatieve prior over het door de waarschijnlijkheid ondersteunde bereik, die in gevolgtrekkingen zou moeten geven die vergelijkbaar zijn met die verkregen met maximale waarschijnlijkheidsmethoden indien even zwakke priors worden gebruikt voor de andere parameters.\nTen tweede wordt de (ongeschaalde) prior voor \\(\\sigma_{y}\\) ingesteld op een exponentiële verdeling met de ‘rate’-parameter op 1.\nTen derde, om een prior voor de varianties en covarianties van de variërende (of “willekeurige”) effecten te specificeren, zal rstanarm deze matrix ontbinden in een correlatiematrix van de variërende effecten en een functie van hun varianties. Omdat er in dit voorbeeld slechts één variërend effect is, reduceert de standaard (ongeschaalde) prior voor \\(\\sigma_{\\alpha}\\) die rstanarm gebruikt tot een exponentiële verdeling met de rate parameter op 1.\nOok moet worden opgemerkt dat rstanarm de priors zal schalen tenzij de autoscale = FALSE optie wordt gebruikt. Na het fitten van een model met stan_lmer, kunnen we de gebruikte priors controleren door de prior_summary() functie op te roepen.\n\n# Een samenvatting krijgen van de priors die gebruikt worden \nprior_summary(object = M1_stanlmer)\n\nPriors for model 'M1_stanlmer' \n------\nIntercept (after predictors centered)\n  Specified prior:\n    ~ normal(location = 73, scale = 2.5)\n  Adjusted prior:\n    ~ normal(location = 73, scale = 41)\n\nAuxiliary (sigma)\n  Specified prior:\n    ~ exponential(rate = 1)\n  Adjusted prior:\n    ~ exponential(rate = 0.061)\n\nCovariance\n ~ decov(reg. = 1, conc. = 1, shape = 1, scale = 1)\n------\nSee help('prior_summary.stanreg') for more details\n\n\n\n# Hiermee krijgen we de SD van de uitkomst \nsd(GCSE$course, na.rm = TRUE)\n\n[1] 16.32096\n\n\nZoals hierboven te zien is, worden de schalen van de priors voor \\(\\mu_{\\alpha}\\) en \\(\\sigma_y\\) op respectievelijk \\(163,21\\) en \\(16,32\\) gezet na herschaling. Aangezien de standaard prior voor het intercept normaal is met een schaalparameter van \\(10\\), is de herschaalde prior ook normaal maar met een schaalparameter van \\(\\text{scale} \\times \\text{SD}(y) = 10 \\times 16.321= 163.21\\). Aangezien de standaard prior voor \\(\\sigma_y\\) exponentieel is met een snelheidsparameter van \\(1\\) (of gelijkwaardig, de schaalparameter \\(\\text{scale} = \\frac{1}{text{rate} = 1\\)), is de herschaalde prior eveneens exponentieel met een schaalparameter van \\(\\text{scale} \\maal \\text{SD}(y) = 1 maal 16,321= 16,32\\)."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#directe-output-van-stan_lmer",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#directe-output-van-stan_lmer",
    "title": "Multilevel modeling met STAN",
    "section": "Directe output van stan_lmer",
    "text": "Directe output van stan_lmer\n\nPosterior medianen en posterior mediaan absolute deviaties\nWe kunnen een snelle samenvatting van de fit van Model 1 weergeven door de print methode op de volgende manier te gebruiken:\n\nprint(M1_stanlmer, digits = 2)\n\nstan_lmer\n family:       gaussian [identity]\n formula:      course ~ 1 + (1 | school)\n observations: 1725\n------\n            Median MAD_SD\n(Intercept) 73.68   1.14 \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 13.82   0.24 \n\nError terms:\n Groups   Name        Std.Dev.\n school   (Intercept)  8.87   \n Residual             13.82   \nNum. levels: school 73 \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n\n\n\n\n\nHier is de puntschatting van \\(\\mu_{\\alpha}\\) uit stan_lmer \\(73.75\\) en dit komt overeen met de mediaan van de posterior trekkingen. Dit is vergelijkbaar met de ML schatting uit lmer. De puntschatting voor \\(`sigma_{_alpha}\\) van stan_lmer is \\(8.87\\), die groter is dan de ML schatting (\\(8.67\\)). Dit verschil kan deels komen doordat de ML benadering in lmer() geen rekening houdt met de onzekerheid in \\(\\mu_{\\alpha}\\) bij het schatten van \\(\\sigma_{\\alpha}\\). De REML benadering (\\(8.75\\)) in lmer() houdt, zoals eerder vermeld, wel rekening met deze onzekerheid.\nBij gebruik van stan_lmer worden standaardfouten verkregen door de mediaan absolute afwijking (MAD) van elke trekking ten opzichte van de mediaan van die trekkingen te beschouwen. Het is bekend dat ML de neiging heeft om onzekerheden te onderschatten, omdat het gebaseerd is op puntschattingen van hyperparameters. Full Bayes daarentegen propageert de onzekerheid in de hyperparameters over alle niveaus van het model en levert adequatere onzekerheidsschattingen op. Zie ook Brown e.a. (2006) voor verdere discussie.\n\n\nPosterior gemiddelden, posterior standaard deviaties, 95% credible interval en Monte Carlo fouten\n\nsummary(M1_stanlmer, \n        pars = c(\"(Intercept)\", \"sigma\", \"Sigma[school:(Intercept),(Intercept)]\"),\n        probs = c(0.025, 0.975),\n        digits = 2)\n\n\nModel Info:\n function:     stan_lmer\n family:       gaussian [identity]\n formula:      course ~ 1 + (1 | school)\n algorithm:    sampling\n sample:       4000 (posterior sample size)\n priors:       see help('prior_summary')\n observations: 1725\n groups:       school (73)\n\nEstimates:\n                                        mean   sd     2.5%   97.5%\n(Intercept)                            73.67   1.12  71.49  75.92 \nsigma                                  13.82   0.24  13.36  14.30 \nSigma[school:(Intercept),(Intercept)]  78.67  15.55  53.46 114.10 \n\nMCMC diagnostics\n                                      mcse Rhat n_eff\n(Intercept)                           0.05 1.01  572 \nsigma                                 0.00 1.00 4579 \nSigma[school:(Intercept),(Intercept)] 0.61 1.00  641 \n\nFor each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).\n\n\nHet is de moeite waard om op te merken dat bij gebruik van de summary methode, de schatting voor de standaardafwijking \\(sigma_y\\) het gemiddelde is van de posterior trekkingen van de parameter. Dit in tegenstelling tot de mediaan van de posterior trekkingen die we krijgen bij gebruik van de print methode. Een voordeel van het gebruik van de mediaan is dat de schatting voor \\(\\sigma_y^2\\) gewoon het kwadraat is van de schatting voor \\(\\sigma_y\\) als het aantal steekproeven oneven is. Dit is niet het geval bij gebruik van het gemiddelde. In dit geval, en meer algemeen wanneer we andere functies van de parameters moeten evalueren, moeten we de posterior trekkingen rechtstreeks benaderen. Dit wordt beschreven in het volgende deel.\nOnder Diagnostics, verwijzen we de lezer naar Paragraaf 5 voor meer informatie over Rhat en n_eff. De waarden onder mcse vertegenwoordigen schattingen voor de Monte Carlo standaardfouten, die de willekeurigheid vertegenwoordigen die geassocieerd is met elke MCMC schattingsrun. Dat wil zeggen, met dezelfde dataset, herhaaldelijk gebruik van een MCMC benadering om een parameter te schatten levert schattingen op met een standaardafwijking gelijk aan de Monte Carlo standaardfout."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#andere-output-van-stan_lmer",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#andere-output-van-stan_lmer",
    "title": "Multilevel modeling met STAN",
    "section": "Andere output van stan_lmer",
    "text": "Andere output van stan_lmer\nZoals gezegd, kunnen gebruikers er de voorkeur aan geven om direct met de posterior trekkingen te werken om schattingen van meer complexe parameters te verkrijgen. Om dit te doen, moeten gebruikers ze handmatig benaderen vanuit het stan_lmer object. We laten zien hoe dit moet in de context van het maken van vergelijkingen tussen individuele scholen.\n\nToegang tot de simulaties en samenvattende resultaten\nGebaseerd op de standaard instellingen, genereert stan_lmer 4 MCMC-ketens van 2.000 iteraties elk. De helft van deze iteraties in elke keten wordt gebruikt als warming-up/burn-in (om de keten te laten convergeren naar de posterior verdeling), en daarom gebruiken we slechts 1.000 steekproeven per keten. Deze door MCMC gegenereerde steekproeven worden geacht getrokken te zijn uit de posterior verdelingen van de parameters in het model. Wij kunnen deze steekproeven gebruiken voor voorspellingen, om de onzekerheid samen te vatten en ‘çredible intervals’ (geloofwaardige intervallen) te schatten voor elke functie van de parameters.\nOm toegang te krijgen tot de posterior trekkingen voor alle parameters, passen we de methode as.matrix() toe op het stanreg object M1_stanlmer. Dit geeft een \\(S\\) bij \\(P\\) matrix, waarbij \\(S\\) de grootte is van de posterior steekproef (of gelijkwaardig, het aantal MCMC iteraties na warm-up) en \\(P\\) het aantal parameters/kwantiteiten. Door deze matrix te manipuleren kunnen we een matrix genereren voor de variërende intercepts \\(\\alpha_{j}\\) en vectoren met de trekkingen voor de within standaardafwijking en de between variantie. Merk op dat om de juiste kolommen voor de parameter van belang te selecteren, het nuttig is om de kolomnamen van de matrix sims te onderzoeken.\nEen meer directe benadering voor het verkrijgen van de posterior trekkingen voor specifieke parameters is gebruik te maken van de ingebouwde functionaliteit van de as.matrix methode voor stanreg objecten. Wanneer de as.matrix methode wordt toegepast op een stanreg object, kan de gebruiker ofwel een optionele karaktervector van parameternamen specificeren, of een optionele karaktervector van reguliere expressies3 om de posterior trekkingen van alleen de parameters waarin ze geïnteresseerd zijn te extraheren. Bijvoorbeeld, omdat de parameter die het totale gemiddelde representeert is gelabeld met (Intercept), kunnen we de posterior trekkingen van alleen deze parameter extraheren door de optie pars = \"(Intercept)\" op te nemen. En omdat de parameters die de 73 schoolfouten representeren allemaal de string b[(Intercept) school: bevatten, kunnen we alle parameters die deze string bevatten extraheren door de optie regex_pars = \"b[(Intercept) school:” te gebruiken.\n\n# Extraheren van de posterior trekkingen voor alle parameters\nsims <- as.matrix(M1_stanlmer)\ndim(sims)\n\n[1] 4000   76\n\npara_name <- colnames(sims)\npara_name\n\n [1] \"(Intercept)\"                          \n [2] \"b[(Intercept) school:20920]\"          \n [3] \"b[(Intercept) school:22520]\"          \n [4] \"b[(Intercept) school:22710]\"          \n [5] \"b[(Intercept) school:22738]\"          \n [6] \"b[(Intercept) school:22908]\"          \n [7] \"b[(Intercept) school:23208]\"          \n [8] \"b[(Intercept) school:25241]\"          \n [9] \"b[(Intercept) school:30474]\"          \n[10] \"b[(Intercept) school:35270]\"          \n[11] \"b[(Intercept) school:37224]\"          \n[12] \"b[(Intercept) school:47627]\"          \n[13] \"b[(Intercept) school:50627]\"          \n[14] \"b[(Intercept) school:50631]\"          \n[15] \"b[(Intercept) school:60421]\"          \n[16] \"b[(Intercept) school:60427]\"          \n[17] \"b[(Intercept) school:60437]\"          \n[18] \"b[(Intercept) school:60439]\"          \n[19] \"b[(Intercept) school:60441]\"          \n[20] \"b[(Intercept) school:60455]\"          \n[21] \"b[(Intercept) school:60457]\"          \n[22] \"b[(Intercept) school:60501]\"          \n[23] \"b[(Intercept) school:60729]\"          \n[24] \"b[(Intercept) school:60741]\"          \n[25] \"b[(Intercept) school:63619]\"          \n[26] \"b[(Intercept) school:63833]\"          \n[27] \"b[(Intercept) school:64251]\"          \n[28] \"b[(Intercept) school:64321]\"          \n[29] \"b[(Intercept) school:64327]\"          \n[30] \"b[(Intercept) school:64343]\"          \n[31] \"b[(Intercept) school:64359]\"          \n[32] \"b[(Intercept) school:64428]\"          \n[33] \"b[(Intercept) school:65385]\"          \n[34] \"b[(Intercept) school:66365]\"          \n[35] \"b[(Intercept) school:67051]\"          \n[36] \"b[(Intercept) school:67105]\"          \n[37] \"b[(Intercept) school:67311]\"          \n[38] \"b[(Intercept) school:68107]\"          \n[39] \"b[(Intercept) school:68111]\"          \n[40] \"b[(Intercept) school:68121]\"          \n[41] \"b[(Intercept) school:68125]\"          \n[42] \"b[(Intercept) school:68133]\"          \n[43] \"b[(Intercept) school:68137]\"          \n[44] \"b[(Intercept) school:68201]\"          \n[45] \"b[(Intercept) school:68207]\"          \n[46] \"b[(Intercept) school:68217]\"          \n[47] \"b[(Intercept) school:68227]\"          \n[48] \"b[(Intercept) school:68233]\"          \n[49] \"b[(Intercept) school:68237]\"          \n[50] \"b[(Intercept) school:68241]\"          \n[51] \"b[(Intercept) school:68255]\"          \n[52] \"b[(Intercept) school:68271]\"          \n[53] \"b[(Intercept) school:68303]\"          \n[54] \"b[(Intercept) school:68321]\"          \n[55] \"b[(Intercept) school:68329]\"          \n[56] \"b[(Intercept) school:68405]\"          \n[57] \"b[(Intercept) school:68411]\"          \n[58] \"b[(Intercept) school:68417]\"          \n[59] \"b[(Intercept) school:68531]\"          \n[60] \"b[(Intercept) school:68611]\"          \n[61] \"b[(Intercept) school:68629]\"          \n[62] \"b[(Intercept) school:68711]\"          \n[63] \"b[(Intercept) school:68723]\"          \n[64] \"b[(Intercept) school:68805]\"          \n[65] \"b[(Intercept) school:68809]\"          \n[66] \"b[(Intercept) school:71927]\"          \n[67] \"b[(Intercept) school:74330]\"          \n[68] \"b[(Intercept) school:74862]\"          \n[69] \"b[(Intercept) school:74874]\"          \n[70] \"b[(Intercept) school:76531]\"          \n[71] \"b[(Intercept) school:76631]\"          \n[72] \"b[(Intercept) school:77207]\"          \n[73] \"b[(Intercept) school:84707]\"          \n[74] \"b[(Intercept) school:84772]\"          \n[75] \"sigma\"                                \n[76] \"Sigma[school:(Intercept),(Intercept)]\"\n\n# Verkrijgen van school-niveau varyiërende intercept a_j\n# trekking voor het algemeen gemiddelde\nmu_a_sims <- as.matrix(M1_stanlmer, \n                       pars = \"(Intercept)\")\n# trekkingen voor 73 scholen van de school-niveua fouten \nu_sims <- as.matrix(M1_stanlmer, \n                    regex_pars = \"b\\\\[\\\\(Intercept\\\\) school\\\\:\")\n# trekkingen van alle 73 school variërende intercepten               \na_sims <- as.numeric(mu_a_sims) + u_sims          \n\n# Verkrijgen van sigma_y en sigma_alpha^2\n# trekkingen van sigma_y\ns_y_sims <- as.matrix(M1_stanlmer, \n                       pars = \"sigma\")\n# trekkingen van sigma_alpha^2\ns__alpha_sims <- as.matrix(M1_stanlmer, \n                       pars = \"Sigma[school:(Intercept),(Intercept)]\")\n\n\n\nVerkrijgen van gemiddelden, standaard deviaties, medianen en 95% geloofwaardigheids intervallen\nIn a_sims hebben we 4.000 posterior trekkingen (van alle 4 ketens) voor de variërende intercepten \\(\\alpha_{j}\\) van de 73 scholen opgeslagen. De eerste kolom van de matrix van 4.000 bij 73 is bijvoorbeeld een vector van 4.000 posterior simulatietrekkingen voor de variërende intercept van de eerste school (School 20920). Een kwantitatieve manier om de posterior kansverdeling van deze 4.000 schattingen voor \\(1,1pha_{1}\\) samen te vatten is het onderzoeken van hun quantielen.\n\n# Computeer gemiddelde, SD, mediaan en 95% geloofwaardigheids interval van de varyiërende intercepten\n\n# Posterior gemiddelde en SD van elke alpha\na_mean <- apply(X = a_sims,     # posterior gemiddelde\n                MARGIN = 2,\n                FUN = mean)\na_sd <- apply(X = a_sims,       # posterior SD\n              MARGIN = 2,\n              FUN = sd)\n\n# Posterior mediaan en 95% geloofwaardigheids interval\na_quant <- apply(X = a_sims, \n                 MARGIN = 2, \n                 FUN = quantile, \n                 probs = c(0.025, 0.50, 0.975))\na_quant <- data.frame(t(a_quant))\nnames(a_quant) <- c(\"Q2.5\", \"Q50\", \"Q97.5\")\n\n# Combineer samenvattende statistieken van posterior simulatie trekkingen\na_df <- data.frame(a_mean, a_sd, a_quant)\nround(head(a_df), 2)\n\n                            a_mean a_sd  Q2.5   Q50 Q97.5\nb[(Intercept) school:20920]  63.63 4.40 54.97 63.57 72.17\nb[(Intercept) school:22520]  57.15 1.79 53.72 57.15 60.60\nb[(Intercept) school:22710]  81.64 3.15 75.47 81.64 87.78\nb[(Intercept) school:22738]  73.03 4.27 64.48 73.11 81.50\nb[(Intercept) school:22908]  66.51 5.28 56.47 66.47 76.70\nb[(Intercept) school:23208]  79.23 2.81 73.60 79.22 85.02\n\n\nWij kunnen een rupsplot maken om de volledige Bayes-schattingen voor de schoolafhankelijke intercepts in rangorde te tonen, samen met hun 95% credible intervallen.\n\n# Sorteer dataframe die een geschatte alfa gemiddelde en sd voor elke school omvatten\na_df <- a_df[order(a_df$a_mean), ]\na_df$a_rank <- c(1 : dim(a_df)[1])  # een vector van de schoolranking \n\n# Plot school-niveau alfas posterior gemiddelde en 95% credible interval\nggplot(data = a_df, \n       aes(x = a_rank, \n           y = a_mean)) +\n  geom_pointrange(aes(ymin = Q2.5, \n                      ymax = Q97.5),\n                  position = position_jitter(width = 0.1, \n                                             height = 0)) + \n  geom_hline(yintercept = mean(a_df$a_mean), \n             size = 0.5, \n             col = \"red\") + \n  scale_x_continuous(\"Rank\", \n                     breaks = seq(from = 0, \n                                  to = 80, \n                                  by = 5)) + \n  scale_y_continuous(expression(paste(\"varying intercept, \", alpha[j]))) + \n  theme_bw( base_family = \"serif\")\n\n\n\n\nDezelfde aanpak kan natuurlijk worden gevolgd om 95% geloofwaardige intervallen te genereren voor \\(\\sigma_y\\) en \\(\\sigma_\\alpha\\).\n\n\nVergelijkingen maken tussen individuele scholen\nHet hebben van steekproeven van alle parameters en variërende intercepten uit hun gezamenlijke posterior verdeling maakt het gemakkelijk om inferenties te trekken over functies van deze parameters.\nIn onderwijsonderzoek en in de onderwijspraktijk is het vaak interessant om de scholen in de data met elkaar te vergelijken. Relevante vragen zijn bijvoorbeeld (1) wat is het verschil tussen de gemiddelden van school A en school B, (2) presteert school A beter dan school B en (3) wat is de rangorde van deze scholen binnen de steekproef. Wanneer niet-Bayesiaanse methoden worden gebruikt, kunnen wij proberen dergelijke vergelijkingen te maken op basis van empirische Bayes- (of Best Linear Unbiased-) voorspellingen van de variërende intercepten. Maar het zal in het algemeen onmogelijk zijn om de onzekerheid uit te drukken voor niet-lineaire functies zoals rangschikkingen. Zie ook Goldstein en Spiegelhalter (2006) voor verdere discussie.\nHier zullen we twee scholen vergelijken als voorbeeld: Scholen 60501 (de 21ste school) en 68271 (de 51ste school). We hebben al 4.000 posterior simulatietrekkingen voor beide scholen. Om conclusies te trekken over het verschil tussen de gemiddelde scores van de twee scholen, kunnen we eenvoudigweg het verschil nemen tussen de twee vectoren van trekkingen \\(\\alpha_{51} - \\alpha_{21}\\).\n\n# Het verschil tussen de twee schoolgemiddelden (school #21 en #51)\nschool_diff <- a_sims[, 21] - a_sims[, 51]\n\nWij kunnen de posterior verdeling van het verschil als volgt onderzoeken met beschrijvende statistieken en een histogram:\n\n# Onderzoek verschillen van twee distributies \nmean <- mean(school_diff)\nsd <- sd(school_diff)\nquantile <- quantile(school_diff, probs = c(0.025, 0.50, 0.975))\nquantile <- data.frame(t(quantile))\nnames(quantile) <- c(\"Q2.5\", \"Q50\", \"Q97.5\")\ndiff_df <- data.frame(mean, sd, quantile)\nround(diff_df, 2)\n\n  mean   sd  Q2.5  Q50 Q97.5\n1 5.12 4.48 -3.53 5.12 14.02\n\n\n\n# Histogram van de verschillen \nggplot(data = data.frame(school_diff), \n       aes(x = school_diff)) + \n  geom_histogram(color = \"black\", \n                 fill = \"gray\", \n                 binwidth = 0.75) + \n  scale_x_continuous(\"Score verschil tussen twee scholen: #21, #51\",\n                     breaks = seq(from = -20, \n                                  to = 20, \n                                  by = 10)) + \n  geom_vline(xintercept = c(mean(school_diff),\n                            quantile(school_diff, \n                                     probs = c(0.025, 0.975))),\n             colour = \"red\", \n             linetype = \"longdash\") + \n  geom_text(aes(5.11, 20, label = \"mean = 5.11\"), \n            color = \"red\", \n            size = 4) + \n  geom_text(aes(9, 50, label = \"SD = 4.46\"), \n            color = \"blue\", \n            size = 4) + \n  theme_bw( base_family = \"serif\") \n\n\n\n\n\nprop.table(table(a_sims[, 21] > a_sims[, 51]))\n\n\n  FALSE    TRUE \n0.12425 0.87575 \n\n\nHet verwachte verschil komt uit op 5,11 met een standaardafwijking van 4,46 en een grote bandbreedte van onzekerheid. Het 95% geloofwaardigheidsinterval is [-3.64, 13.66], dus we zijn er 95% zeker van dat de ware waarde van het verschil tussen de twee scholen binnen het bereik ligt, gegeven de gegevens.\nWe kunnen ook het deel van de tijd bepalen dat School 60501 een hoger gemiddelde heeft dan School 68271:\n\nprop.table(table(a_sims[, 21] > a_sims[, 51]))\n\n\n  FALSE    TRUE \n0.12425 0.87575 \n\n\n\n\n\nDit betekent dat de posterior waarschijnlijkheid dat School 60501 beter is dan School 68271 87.6% is. Elk paar scholen binnen de steekproef van scholen kan op deze manier vergeleken worden."
  },
  {
    "objectID": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-2-een-voorspeller-op-studentenniveau-toevoegen",
    "href": "posts/2022-02-11-multilevelrstan/multilevelrstan.html#model-2-een-voorspeller-op-studentenniveau-toevoegen",
    "title": "Multilevel modeling met STAN",
    "section": "Model 2: Een voorspeller op studentenniveau toevoegen",
    "text": "Model 2: Een voorspeller op studentenniveau toevoegen\nOnderzoekers zouden de variërende interceptmodellen kunnen uitbreiden met waargenomen verklarende variabelen op het niveau van de leerling \\(x_{ij}\\), in dit voorbeeld een indicatorvariabele voor vrouw. Een eenvoudig variërend interceptmodel met één voorspeller op het niveau van de leerling kan worden geschreven als \\(y_{ij} \\N(\\alpha_{j} + \\beta x_{ij}, \\sigma_{y}^{2})\\) en \\(\\alpha_{j} \\N(\\mu_{alpha}, \\sigma_{alpha}^{2})\\). We gebruiken niet-informatieve prioriteitsverdelingen voor de hyperparameters (\\(\\mu_{\\alpha}\\) en \\(\\sigma_{\\alpha}\\)) zoals gespecificeerd in het variërende interceptmodel zonder voorspellers. Bovendien krijgt de regressiecoëfficiënt \\(\\beta\\) een normale prioriteitsverdeling met gemiddelde 0 en standaardafwijking 100. Dit betekent, ruwweg, dat we verwachten dat deze coëfficiënt in het bereik \\((-100, 100)\\) ligt, en als de ML schatting in dit bereik ligt, geeft de prior verdeling zeer weinig informatie voor de inferentie.\nHet bovenstaande model kan als volgt worden gefit met de stan_lmer() functie in het rstanarm pakket:\n\nM2_stanlmer <- stan_lmer(formula = course ~ female + (1 | school), \n                         data = GCSE, \n                         prior = normal(location = 0, \n                                        scale = 100,\n                                        autoscale = FALSE),\n                         prior_intercept = normal(location = 0, \n                                                  scale = 100, \n                                                  autoscale = FALSE),\n                         seed = 349)\n\n\nprior_summary(object = M2_stanlmer)\n\nPriors for model 'M2_stanlmer' \n------\nIntercept (after predictors centered)\n ~ normal(location = 0, scale = 100)\n\nCoefficients\n ~ normal(location = 0, scale = 100)\n\nAuxiliary (sigma)\n  Specified prior:\n    ~ exponential(rate = 1)\n  Adjusted prior:\n    ~ exponential(rate = 0.061)\n\nCovariance\n ~ decov(reg. = 1, conc. = 1, shape = 1, scale = 1)\n------\nSee help('prior_summary.stanreg') for more details\n\n\n\nM2_stanlmer\n\nstan_lmer\n family:       gaussian [identity]\n formula:      course ~ female + (1 | school)\n observations: 1725\n------\n            Median MAD_SD\n(Intercept) 69.7    1.3  \nfemaleF      6.7    0.7  \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 13.4    0.2  \n\nError terms:\n Groups   Name        Std.Dev.\n school   (Intercept)  9      \n Residual             13      \nNum. levels: school 73 \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n\n\nMerk op dat in plaats van de standaard priors in stan_lmer, \\(\\mu_{\\alpha}\\) en \\(\\beta\\) normale prior verdelingen krijgen met gemiddelde 0 en standaardafwijking 100 door de argumenten prior en prior_intercept op te geven als normal(location = 0, scale = 100, autoscale = FALSE). Om te voorkomen dat stan_lmer de prior schaalt, moeten we ervoor zorgen dat het argument autoscale = FALSE wordt toegevoegd.\nDe puntschattingen van \\(_mu_{alpha}\\), \\(\\beta\\), en \\(\\sigma_{y}\\) zijn bijna identiek aan de ML-schattingen van de lmer() fit. Echter, deels omdat ML de onzekerheid over \\(\\mu_{alpha}\\) negeert bij het schatten van \\(\\sigma_{alpha}\\), is de Bayesiaanse schatting voor \\(\\sigma_{alpha}\\) (\\(9,0\\)) groter dan de ML-schatting (\\(8,8\\)), net als bij model 1.\n\nModel 3: Variërende slopes over scholen toevoegen\nWe also use stan_lmer to fit Model 3 using the command below. Note that here, we use the default priors which are mostly similar to what was done in Model 1. Additionally, we are also required to specify a prior for the covariance matrix \\(\\Sigma\\) for \\(\\alpha_j\\) and \\(\\beta_j\\) in this Model. stan_lmer decomposes this covariance matrix (up to a factor of \\(\\sigma_y\\)) into (i) a correlation matrix \\(R\\) and (ii) a matrix of variances \\(V\\), and assigns them separate priors as shown below.\n$$\n\\[\\begin{aligned}\n\\Sigma &=\n\\left(\\begin{matrix}\n\\sigma_\\alpha^2 & \\rho\\sigma_\\alpha \\sigma_\\beta \\\\\n\\rho\\sigma_\\alpha\\sigma_\\beta&\\sigma_\\beta^2\n\\end{matrix} \\right)\\\\ &=\n\\sigma_y^2\\left(\\begin{matrix}\n\\sigma_\\alpha^2/\\sigma_y^2 & \\rho\\sigma_\\alpha \\sigma_\\beta/\\sigma_y^2 \\\\\n\\rho\\sigma_\\alpha\\sigma_\\beta/\\sigma_y^2 & \\sigma_\\beta^2/\\sigma_y^2\n\\end{matrix} \\right)\\\\ &=\n\\sigma_y^2\\left(\\begin{matrix}\n\\sigma_\\alpha/\\sigma_y & 0 \\\\\n0&\\sigma_\\beta/\\sigma_y\n\\end{matrix} \\right)\n\\left(\\begin{matrix}\n1 & \\rho\\\\\n\\rho&1\n\\end{matrix} \\right)\n\\left(\\begin{matrix}\n\\sigma_\\alpha/\\sigma_y & 0 \\\\\n0&\\sigma_\\beta/\\sigma_y\n\\end{matrix} \\right)\\\\\n&= \\sigma_y^2VRV.\n\\end{aligned}\\]\n$$\nDe correlatiematrix \\(R\\) is een 2 bij 2 matrix met 1-en op de diagonaal en \\(rho\\)’s op de off-diagonaal. stan_lmer kent er een LKJ^[Voor meer details over de LKJ verdeling, zie hier en hier prior aan toe, met regularisatieparameter 1 (Lewandowski et all., 2009). Dit komt overeen met het toekennen van een uniforme prior voor \\(rho\\). Hoe groter de regularisatieparameter is dan 1, hoe meer de verdeling voor \\(\\rho\\) de waarde 0 aanneemt.\nDe matrix van (geschaalde) varianties \\(V\\) kan eerst worden samengevat in een vector van (geschaalde) varianties, en vervolgens ontleed in drie delen, \\(J\\), \\(\\tau^2\\) en \\(\\pi\\) zoals hieronder getoond. $$\n(\n\\[\\begin{matrix}\n\\sigma_\\alpha^2/\\sigma_y^2 \\\\\n\\sigma_\\beta^2/\\sigma_y^2\n\\end{matrix}\\]\n) = 2()(\n\\[\\begin{matrix}\n\\frac{\\sigma_\\alpha^2/\\sigma_y^2}{\\sigma_\\alpha^2/\\sigma_y^2 + \\sigma_\\beta^2/\\sigma_y^2} \\\\\n\\frac{\\sigma_\\beta^2/\\sigma_y^2}{\\sigma_\\alpha^2/\\sigma_y^2 + \\sigma_\\beta^2/\\sigma_y^2}\n\\end{matrix}\\]\n)= J^2 .\n$$\nIn deze formulering is \\(J\\) het aantal variërende effecten in het model (hier \\(J=2\\)), kan \\(Jtau^2\\) worden beschouwd als een gemiddelde (geschaalde) variantie over de variërende effecten \\(Jalpha_j\\) en \\(Jbeta_j\\), en is \\(Jpi\\) een niet-negatieve vector die sommeert tot 1 (een zogenaamde simplex/probabiliteitsvector). Een symmetrische Dirichlet4 verdeling met concentratieparameter ingesteld op 1 wordt dan gebruikt als de prior voor \\(\\pi\\). Standaard impliceert dit een gezamenlijk uniforme prior over alle simplexvectoren van dezelfde grootte. Een schaalinvariante Gamma-voorrang met vorm- en schaalparameters beide op 1 wordt dan toegekend voor \\(\\tau\\). Dit komt overeen met het toekennen van de exponentiële verdeling met de snelheidsparameter op 1 die consistent is met de prioriteit toegekend aan \\(\\sigma_y\\) als prioriteit.\n\nM3_stanlmer <- stan_lmer(formula = course ~ female + (1 + female | school), \n                         data = GCSE,\n                         seed = 349)\nprior_summary(object = M3_stanlmer)\n\nPriors for model 'M3_stanlmer' \n------\nIntercept (after predictors centered)\n  Specified prior:\n    ~ normal(location = 73, scale = 2.5)\n  Adjusted prior:\n    ~ normal(location = 73, scale = 41)\n\nCoefficients\n  Specified prior:\n    ~ normal(location = 0, scale = 2.5)\n  Adjusted prior:\n    ~ normal(location = 0, scale = 83)\n\nAuxiliary (sigma)\n  Specified prior:\n    ~ exponential(rate = 1)\n  Adjusted prior:\n    ~ exponential(rate = 0.061)\n\nCovariance\n ~ decov(reg. = 1, conc. = 1, shape = 1, scale = 1)\n------\nSee help('prior_summary.stanreg') for more details\n\nM3_stanlmer\n\nstan_lmer\n family:       gaussian [identity]\n formula:      course ~ female + (1 + female | school)\n observations: 1725\n------\n            Median MAD_SD\n(Intercept) 69.4    1.3  \nfemaleF      7.1    1.1  \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 13.0    0.2  \n\nError terms:\n Groups   Name        Std.Dev. Corr \n school   (Intercept) 10.3          \n          femaleF      7.2     -0.49\n Residual             13.0          \nNum. levels: school 73 \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n\n\n\n\n\nHier zien we dat de puntschattingen voor \\(\\mu_{\\alpha}\\) en \\(\\sigma_{y}\\) identiek zijn aan de ML-schattingen uit lmer() fit. De puntschatting voor $\\(_bèta\\) is iets anders in dit model (7.14 vergeleken met 7.13). Verder is, net als bij de vorige twee modellen, de Bayesiaanse schatting voor \\(\\sigma_{\\alpha}\\) (10.3) groter dan de ML schatting (10.15). Daarnaast zijn de Bayesiaanse schattingen voor \\(\\sigma_{\\beta}\\) (7.2) en \\(\\rho\\) (-0.49) groter dan de overeenkomstige ML schattingen (respectievelijk 6.92 en -0.52)."
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html",
    "title": "Regressie en nog zo iets",
    "section": "",
    "text": "Vijftien jaar geleden schreven Gelman en Hill Data analysis using regression and multilevel/hierarchical models, een klassieker over moderne data-analyse. Ze gebruikte R en WinBugs voor lineaire en logistische, hierarchische regressieanalyse en causale inferentie. Ze lieten zien hoe je dat op de frequentistische en Bayesiaanse manier kunt doen. Het boek werd voor mij een naslagwerk dat ik steeds maar weer uit de kast trok. Vorig jaar dacht ik, laat ik eens zien of Gelman al weer iets nieuws heeft geschreven en toen zag ik dat Regression and other stories hiernet uit was is. Dat heeft Andrew Gelman weer met Jennifer Hill geschreven maar nu ook met de Fin Aki Vehtari. Ik was er nog niet aan toe gekomen om het te lezen. Dat heb ik deze maand gedaan. Ook dit boek zal ik vaker uit de kast trekken. Dit boek gaat over allerlei aspecten van regressie. Het is een theoretisch én praktisch boek. Je leert, wat ze noemen, voorspellende modellen beter begrijpen, toepassen in verschillende praktische problemen en je leert het simuleren. Je leert het opbouwen vanaf de basis en daarna kun je het in verschillende situaties toepassen. Het wil kritisch zijn, zonder nihilistisch te worden en vooral laten zien dat je van statistische analyse kunt leren. Ook dit boek staat op twee benen: frequentisch en Bayesiaans en laat zien hoe informatie wordt gebruikt in het schattingsproces, de assumpties die eraan ten grondslag liggen en hoe schattingen en voorspellingen kunnen worden geïnterpreteerd in beide raamwerken. Beide kunnen worden gebruikt, maar het is ook duidelijk dat de voorkeur bij Bayesiaanse benadering ligt. Dan kun je ook andere informatie gebruiken om te schatten of te voorspellen. En omdat je simuleert (het model duizenden keren draait) kunt je met de Bayesiaanse techniek meer zeggen over onzekerheid. Dat maakt deze techniek zeer geschikt voor regressieanalyses zoals in dit boek gepresenteerd. Wat ik zelf van dit boek heb geleerd zijn de mogelijkheden om op basis van gegevens te voorspellen. Vooral hoofdstuk 9 (Voorspellen en Bayesiaanse inferentie) vond ik interessant. Maar het boek zit vol informatie en kennis en laat zich amper samenvatten. Het lijkt erop dat het een eerste deel is en ik verwacht dat er later nog een tweede deel komt dat de nadruk legt op multilevel analyse. We zullen zien Bij het boek zit ook nog een website met data en scripts om zelf uit te proberen, prachtig onderwijsmateriaal opgesteld door Aki Vehtari hier."
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#interssante-blog",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#interssante-blog",
    "title": "Regressie en nog zo iets",
    "section": "Interssante blog",
    "text": "Interssante blog\nToen ik het boek uit had kwam ik een een blog tegen op R-bloggers. Het verscheen op 1 september 2021 hier, maar ik kon niet zien van wie het is (Mister X, sorry. Hij of zij schreef het nadat deze persoon Regression and other stories had gelezen. Het vat heel goed samen hoe moderne regressieanalyse werkt en daarom heb ik het voor hier vertaald.\n\n# Eerst de pakketten inladen die we nodig hebben\nlibrary(plyr); library(dplyr)\n\nWarning: package 'plyr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:plyr':\n\n    arrange, count, desc, failwith, id, mutate, rename, summarise,\n    summarize\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(rstanarm)\n\nWarning: package 'rstanarm' was built under R version 4.1.3\n\n\nLoading required package: Rcpp\n\n\nWarning: package 'Rcpp' was built under R version 4.1.3\n\n\nThis is rstanarm version 2.21.3\n\n\n- See https://mc-stan.org/rstanarm/articles/priors for changes to default priors!\n\n\n- Default priors may change, so it's safest to specify priors, even if equivalent to the defaults.\n\n\n- For execution on a local, multicore CPU with excess RAM we recommend calling\n\n\n  options(mc.cores = parallel::detectCores())\n\nlibrary(bayesplot)\n\nWarning: package 'bayesplot' was built under R version 4.1.3\n\n\nThis is bayesplot version 1.9.0\n\n\n- Online documentation and vignettes at mc-stan.org/bayesplot\n\n\n- bayesplot theme set to bayesplot::theme_default()\n\n\n   * Does _not_ affect other ggplot2 plots\n\n\n   * See ?bayesplot_theme_set for details on theme setting\n\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.1.3\n\nlibrary(readr)\n\nWarning: package 'readr' was built under R version 4.1.3"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#bayesiaanse-regressieanalyse-met-rstanarm",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#bayesiaanse-regressieanalyse-met-rstanarm",
    "title": "Regressie en nog zo iets",
    "section": "Bayesiaanse regressieanalyse met Rstanarm",
    "text": "Bayesiaanse regressieanalyse met Rstanarm\nIn deze post zullen we een eenvoudig voorbeeld van Bayesiaanse regressieanalyse doornemen met het rstanarm pakket in R. Ik heb Gelman, Hill en Vehtari’s recente boek Regression and Other Stories” gelezen, en deze blog post is mijn poging om enkele van de dingen die ik heb geleerd toe te passen. Ik heb de afgelopen jaren stukjes en beetjes van de Bayesiaanse benadering opgevangen, en ik vind het een heel interessante manier om over gegevensanalyse na te denken en ze uit te voeren. Ik heb met veel plezier het nieuwe boek van Gelman en collega’s doorgewerkt en geëxperimenteerd met deze technieken, en ik ben blij dat ik hier iets kan delen van wat ik heb geleerd.\nJe kunt de gegevens en alle code van deze blogpost hier op Github vinden."
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#de-data",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#de-data",
    "title": "Regressie en nog zo iets",
    "section": "De data",
    "text": "De data\nDe gegevens die we in deze blog zullen onderzoeken bestaan uit de dagelijkse totale stappentellingen van verschillende fitnesstrackers die ik de afgelopen 6 jaar heb gehad. De eerste waarneming werd geregistreerd op 2015-03-04 en de laatste op 2021-03-15. Gedurende deze periode bevat de dataset de dagelijkse totale stappentellingen voor 2.181 dagen.\nNaast de dagelijkse totale stappentelling bevat de dataset informatie over de dag van de week (bijv. maandag, dinsdag, etc.), het apparaat dat is gebruikt om de stappentelling vast te leggen (door de jaren heen heb ik er 3 gehad - Accupedo, Fitbit en Mi-Band), en het weer voor elke datum (de gemiddelde dagelijkse temperatuur in graden Celsius en de totale dagelijkse neerslag in millimeters, verkregen via het GSODR pakket in R).\nDe dataset (genaamd steps_weather) ziet er als volgt uit:\n\n# Data inladen\nlibrary(readr)\nsteps_weather <- read_csv(\"C:/FilesHarrie/Stanexample/Rstanarmexample/bayesian_regression_rstanarm/Data/steps_weather.csv\")\n\nRows: 2181 Columns: 7\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr  (3): dow, week_weekend, device\ndbl  (3): daily_total, temp, prcp\ndate (1): date\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nhead(steps_weather)\n\n# A tibble: 6 x 7\n  date       daily_total dow   week_weekend device    temp  prcp\n  <date>           <dbl> <chr> <chr>        <chr>    <dbl> <dbl>\n1 2015-03-04       14136 Wed   Weekday      Accupedo   4.3   1.3\n2 2015-03-05       11248 Thu   Weekday      Accupedo   4.7   0  \n3 2015-03-06       12803 Fri   Weekday      Accupedo   5.4   0  \n4 2015-03-07       15011 Sat   Weekend      Accupedo   7.9   0  \n5 2015-03-08        9222 Sun   Weekend      Accupedo  10.2   0  \n6 2015-03-09       21452 Mon   Weekday      Accupedo   8.8   0  \n\n\nHieronder zie je de eerste en laatste data.\n\nmin(steps_weather$date)\n\n[1] \"2015-03-04\"\n\nmax(steps_weather$date)\n\n[1] \"2021-03-15\"\n\n\nHieronder zie je histogrammen van twee variabelen, namelijk dagelijks totale aantal stappen en de gemiddelde temperatuur over deze periode.\n\nhist(steps_weather$daily_total, breaks = 50)\n\n\n\nhist(steps_weather$temp, breaks = 50)"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#regressie-analyse",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#regressie-analyse",
    "title": "Regressie en nog zo iets",
    "section": "Regressie Analyse",
    "text": "Regressie Analyse\nHet doel van deze blogbijdrage is Bayesiaanse regressiemodellering te verkennen met behulp van het rstanarm pakket. Daarom zullen we de gegevens gebruiken om een zeer eenvoudig model te maken en ons te concentreren op het begrijpen van de modelfit en verschillende regressiediagnoses.\nOns model hier is een lineair regressiemodel dat de gemiddelde temperatuur in graden Celsius gebruikt om het totale dagelijkse aantal stappen te voorspellen. We gebruiken het stan_glm commando om de regressie-analyse uit te voeren. We kunnen het model uitvoeren en een samenvatting van de resultaten zien die de volgende tabel oplevert.\nHet draait 4.000 iteraties en daarna worden de resultaten gepresenteerd.\n\nfit_1 <- stan_glm(daily_total ~ temp, data = steps_weather) \n\n\nSAMPLING FOR MODEL 'continuous' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 0.473 seconds (Warm-up)\nChain 1:                0.184 seconds (Sampling)\nChain 1:                0.657 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'continuous' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 2: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 0.277 seconds (Warm-up)\nChain 2:                0.174 seconds (Sampling)\nChain 2:                0.451 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'continuous' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 3: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 0.584 seconds (Warm-up)\nChain 3:                0.168 seconds (Sampling)\nChain 3:                0.752 seconds (Total)\nChain 3: \n\nSAMPLING FOR MODEL 'continuous' NOW (CHAIN 4).\nChain 4: \nChain 4: Gradient evaluation took 0 seconds\nChain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 4: Adjust your expectations accordingly!\nChain 4: \nChain 4: \nChain 4: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 4: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 4: \nChain 4:  Elapsed Time: 0.884 seconds (Warm-up)\nChain 4:                0.174 seconds (Sampling)\nChain 4:                1.058 seconds (Total)\nChain 4: \n\nsummary(fit_1)\n\n\nModel Info:\n function:     stan_glm\n family:       gaussian [identity]\n formula:      daily_total ~ temp\n algorithm:    sampling\n sample:       4000 (posterior sample size)\n priors:       see help('prior_summary')\n observations: 2181\n predictors:   2\n\nEstimates:\n              mean    sd      10%     50%     90%  \n(Intercept) 16218.9   276.0 15869.3 16215.8 16580.9\ntemp           26.6    21.0    -0.9    26.4    53.5\nsigma        6199.8    96.4  6082.2  6198.2  6322.6\n\nFit Diagnostics:\n           mean    sd      10%     50%     90%  \nmean_PPD 16519.2   190.8 16279.1 16518.9 16767.0\n\nThe mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help('summary.stanreg')).\n\nMCMC diagnostics\n              mcse Rhat n_eff\n(Intercept)   4.3  1.0  4169 \ntemp          0.3  1.0  4436 \nsigma         1.7  1.0  3317 \nmean_PPD      3.1  1.0  3896 \nlog-posterior 0.0  1.0  1716 \n\nFor each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).\n\n\nDeze tabel bevat de volgende variabelen:\n\nIntercept: Dit cijfer geeft het verwachte dagelijkse aantal stappen weer wanneer de gemiddelde dagtemperatuur 0 is. Met andere woorden, het model voorspelt dat, wanneer de gemiddelde dagtemperatuur 0 graden Celsius is, ik op die dag 16211,7 stappen zal lopen.\ntemp: Dit is de geschatte toename van het dagelijkse aantal stappen per 1 eenheid stijging van de gemiddelde dagelijkse temperatuur in graden Celsius. Met andere woorden, het model voorspelt dat voor elke 1 graad stijging van de gemiddelde dagtemperatuur, ik die dag 26,8 extra stappen zal zetten.\nsigma: Dit is de geschatte standaardafwijking van de residuen van het regressiemodel. (Het residu is het verschil tussen de modelvoorspelling en de waargenomen waarde voor het dagelijkse totale aantal stappen). De verdeling van de residuele waarden heeft een standaardafwijking van 6195,1.\ngeman_PPD: De mean_ppd is de gemiddelde posterior predictive distributie van de door het model geïmpliceerde uitkomstvariabele (we zullen dit verder bespreken in het gedeelte over posterior predictive checques hieronder).\n\nDe uitvoer in de samenvattende tabel hierboven lijkt vrij veel op de uitvoer van een standaard gewone kleinste kwadratenregressie. In de Bayesiaanse benadering van regressiemodellering krijgen we echter niet gewoon puntschattingen van coëfficiënten, maar eerder volledige verdelingen van simulaties die mogelijke waarden van de coëfficiënten vertegenwoordigen, gegeven het model. Met andere woorden, de getallen in de bovenstaande tabel zijn gewoon samenvattingen van verdelingen van coëfficiënten die de relatie tussen de voorspellers en de uitkomstvariabele beschrijven.\nStandaard geven de rstanarm regressiemodellen 4.000 simulaties van de posterior verdeling voor elke modelparameter. We kunnen de simulaties uit het modelobject halen en ze als volgt bekijken:\n\n# extraheer de simulaties van het modelobject\nsims <- as.matrix(fit_1)\n\nEn dat geeft 4000 posterior simulaties van de parameters intercept, temp en sd. Deze simulaties drukken de onzekerheid uit van de modeloutput die je hierboven vindt\n\nhead(sims)\n\n          parameters\niterations (Intercept)      temp    sigma\n      [1,]    16172.03 34.679624 6116.416\n      [2,]    16380.96 22.963727 6173.921\n      [3,]    16054.89 29.856779 6223.247\n      [4,]    16107.86 28.293847 6290.878\n      [5,]    16487.89 18.927277 6172.173\n      [6,]    16692.51  6.882619 6199.710\n\n\nDe gemiddelde waarden van deze verdelingen van simulaties worden weergegeven in de hierboven afgebeelde tabel met regressiesamenvattingsuitvoer.\n\n# gemiddelde en intercept - matchen met de tabel \nmean(sims[,1])\n\n[1] 16218.87\n\nsd(sims[,1])\n\n[1] 275.9854\n\n# gemiddelde en sd temp - matchen met de tabel \nmean(sims[,2])\n\n[1] 26.62242\n\nmedian(sims[,2])\n\n[1] 26.44791\n\nsd(sims[,2])\n\n[1] 21.03643\n\n# gemiddelde en sd sigma - matchen met de tabel \nmean(sims[,3])\n\n[1] 6199.79\n\nsd(sims[,3])\n\n[1] 96.39904"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#visualiseren-van-de-posterior-distributies-met-bayesplot",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#visualiseren-van-de-posterior-distributies-met-bayesplot",
    "title": "Regressie en nog zo iets",
    "section": "Visualiseren van de posterior distributies met bayesplot",
    "text": "Visualiseren van de posterior distributies met bayesplot\nHet uitstekende bayesplot-pakket bevat een aantal handige functies om de posterior distributies van onze coëfficiënten te visualiseren. Laten we de mcmc_areas-functie gebruiken om de 90% geloofwaardige intervallen voor de modelcoëfficiënten weer te geven. die de volgende plot oplevert.\n\ncolor_scheme_set(\"red\")\nplot_title <- ggtitle(\"Posterior distributies\",\n                      \"met medianen en 90% intervallen\")\nmcmc_areas(sims, prob = 0.90) + plot_title\n\n\n\n\nDeze grafiek is zeer interessant en toont ons de posterior distributie van de simulaties van het model dat we hierboven hebben getoond. De plot geeft ons een idee van de variatie van alle parameters, maar de coëfficiënten liggen op zulke verschillende schalen dat de details verloren gaan door ze allemaal samen weer te geven.\nLaten we ons concentreren op de temperatuurcoëfficiënt en een gebiedsplot maken met alleen deze parameter:\n\n# area plot van temperatuur parameter\nmcmc_areas(sims,\n          pars = c(\"temp\"),\n          prob = 0.90) + plot_title\n\n\n\n\nDeze grafiek toont de mediaan van de verdeling (26,69, die zeer dicht bij ons gemiddelde van 26,83 ligt). We kunnen de grenzen van het hierboven getoonde gearceerde gebied bepalen met de posterior_interval functie, of rechtstreeks uit de simulaties zelf:\n\nposterior_interval(fit_1, pars = \"temp\", prob=.9)\n\n           5%      95%\ntemp -8.21517 60.75168\n\n# of rechtstreeks van de posterior distribution\nquantile(sims[,2], probs = c(.05,.95))  \n\n      5%      95% \n-8.21517 60.75168 \n\n\nBeide methoden geven hetzelfde resultaat."
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#visualiseren-van-slopes-van-de-posterior-distributie",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#visualiseren-van-slopes-van-de-posterior-distributie",
    "title": "Regressie en nog zo iets",
    "section": "Visualiseren van slopes van de posterior distributie",
    "text": "Visualiseren van slopes van de posterior distributie\nEen andere interessante manier om de verschillende coëfficiënten uit de posterior verdeling te visualiseren is door de regressielijnen van vele simulaties uit de posterior distributie gelijktijdig uit te zetten tegen de ruwe data. Deze visualisatietechniek wordt veel gebruikt in zowel Richard McElreath’s Statistical Rethinking als in Gelmans Regression and Other Stories. Beide boeken maken dit soort tekeningen met behulp van plotfuncties in basis-R. Ik was erg blij deze blog post te vinden met een voorbeeld van hoe je deze plots kan maken met behulp van ggplot2! Ik heb de code lichtjes aangepast om de onderstaande figuur te maken.\nDe eerste stap is het extraheren van de basisinformatie om elke regressielijn te tekenen. We doen dit met de volgende code, waarbij we in essentie ons model-object doorgeven aan een dataframe, en dan enkel het intercept en de temperatuur-hellingen voor elk van onze 4.000 simulaties uit de posterior distributie houden.\nDit geeft het volgende dataframe terug:\n\n# Dit is een data-frame van posterior samples \n# Een rij per sample.\nfits <- fit_1 %>% \n  as_tibble() %>% \n  rename(intercept = `(Intercept)`) %>% \n  select(-sigma)\n# hoe ziet dat dataframe eruit?\nhead(fits)\n\n# A tibble: 6 x 2\n  intercept  temp\n      <dbl> <dbl>\n1    16172. 34.7 \n2    16381. 23.0 \n3    16055. 29.9 \n4    16108. 28.3 \n5    16488. 18.9 \n6    16693.  6.88\n\n\nDit dataframe heeft 4.000 rijen, één voor elke simulatie uit de posterior verdeling in onze originele sims matrix.\nWe stellen dan enkele “esthetische regelaars” in, die specificeren hoeveel lijnen van de posterior verdeling we willen plotten, hun transparantie (de alpha parameter), en de kleuren voor de individuele posterior lijnen en het algemene gemiddelde van de posterior schattingen. De ggplot2 code stelt dan de assen in met het originele data frame (steps_weather), plot een steekproef van regressielijnen uit de posterior verdeling in licht grijs, en plot dan de gemiddelde helling van alle posterior simulaties in blauw.\nDat levert de volgende plot op:\n\n# Eerst de opmaak instellen\nn_draws <- 500\nalpha_level <- .15\ncolor_draw <- \"grey60\"\ncolor_mean <-  \"#3366FF\"\n\n# plot maken\nggplot(steps_weather) + \n  # eerst - eerst de assen van de originele data bepalen\n  aes(x = temp, y = daily_total ) + \n  # restrictie opleggen aan y-as om de focus te leggen op de verschillende slopes in het\n  # centrum van de data\n  coord_cartesian(ylim = c(15000, 18000)) +\n  # Plot een random sample van rijen van  de simulatie\n  # als grijze semi-transparante lijnen\n  geom_abline(\n    aes(intercept = intercept, slope = temp), \n    data = sample_n(fits, n_draws), \n    color = color_draw, \n    alpha = alpha_level\n  ) + \n  # Plot de gemiddelde waarden van onze parameters in blauw\n  # dit correspondeert met de coefficienten die we terugkregen van onze \n  # modelsamenvatting\n  geom_abline(\n    intercept = mean(fits$intercept), \n    slope = mean(fits$temp), \n    size = 1, \n    color = color_mean\n  ) +\n  geom_point() + \n  # definieer de aslabels en de titel van de plot\n  labs(x = 'Gemiddelde dagelijkse temperatuur (Graden Celsius)', \n       y = 'Dagelijkse totale aantal stappen' , \n       title = 'Visualisatie of 500 regressie lijnnen van de posterior eistributie')\n\n\n\n\nDe gemiddelde helling (weergegeven in de grafiek en ook terug te vinden in de modelsamenvatting hierboven) van de temperatuur is 26,8. Maar het plotten van samples uit de posterior verdeling maakt duidelijk dat er nogal wat onzekerheid is over de grootte van deze relatie! Sommige van de hellingen uit de verdeling zijn negatief - zoals we zagen in onze berekening van de onzekerheidsintervallen hierboven. In essentie is er een “gemiddelde” coëfficiëntschatting, maar wat het Bayesiaanse raamwerk heel goed doet (via de posterior verdelingen) is extra informatie verschaffen over de onzekerheid van onze schattingen."
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#posterior-voorspellingscontroles",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#posterior-voorspellingscontroles",
    "title": "Regressie en nog zo iets",
    "section": "Posterior voorspellingscontroles",
    "text": "Posterior voorspellingscontroles\nEen laatste manier om grafieken te gebruiken om ons model te begrijpen is door gebruik te maken van posterior predictive checks. Ik hou van deze intuïtieve manier om de logica achter deze reeks technieken uit te leggen: “Het idee achter posterior predictive checking is simpel: als een model een goede fit is, moeten we het kunnen gebruiken om gegevens te genereren die veel lijken op de gegevens die we hebben waargenomen. De gegenereerde gegevens worden de posterior predictive distributie genoemd, dat is de verdeling van de uitkomstvariabele (dagelijks totaal aantal stappen in ons geval) die wordt geïmpliceerd door een model (het regressiemodel dat hierboven is gedefinieerd). Het gemiddelde van deze verdeling wordt weergegeven in de bovenstaande uitvoer van het regressieoverzicht, met de naam mean_PPD.\nEr zijn vele soorten visualisaties die men kan maken om posterieure voorspellende controles uit te voeren. Wij zullen één zo’n analyse uitvoeren (voor meer informatie over dit onderwerp), die het gemiddelde van onze uitkomstvariabele (dagelijks totaal aantal stappen) in onze oorspronkelijke dataset en de posterior predictive distributie van ons regressie model.\nDe code is rechttoe rechtaan.\n\n# posterior predictive checks\n# https://mc-stan.org/bayesplot/reference/pp_check.html\n# http://mc-stan.org/rstanarm/reference/pp_check.stanreg.html\n\n# Het idee achter posterior predictive checking is eenvoudig: als een model een goede  \n# fit heeft dan moeten we data kunnen genereren die erg lijken op de data die we hebben geobserveerd.\n#  Om die data te genereren voor posterior predictive checks (PPCs), simuleren we die van de posterior predictive distributie. \n\n# posterior predictive check - voor meer informatie zie:\n# https://mc-stan.org/bayesplot/reference/pp_check.html\n# http://mc-stan.org/rstanarm/reference/pp_check.stanreg.html\npp_check(fit_1, \"stat\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nWe kunnen zien dat het gemiddelde van onze dagelijkse stappen variabele in de originele dataset in principe in het midden van de posterior voorspellende distributie valt. Volgens deze analyse “genereert ons regressiemodel gegevens die veel lijken op de gegevens die we hebben geobserveerd!”"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#het-model-gebruiken-om-voorspellingen-te-doen-met-nieuwe-gegevens",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#het-model-gebruiken-om-voorspellingen-te-doen-met-nieuwe-gegevens",
    "title": "Regressie en nog zo iets",
    "section": "Het model gebruiken om voorspellingen te doen met nieuwe gegevens",
    "text": "Het model gebruiken om voorspellingen te doen met nieuwe gegevens\nTenslotte zullen we het model gebruiken om voorspellingen te doen over het aantal stappen per dag, gebaseerd op een specifieke waarde van de gemiddelde dagtemperatuur. In Regression and Other Stories bespreken de auteurs in hoofdstuk 9 hoe een Bayesiaans regressiemodel kan worden gebruikt om voorspellingen te doen op een aantal verschillende manieren, waarbij telkens verschillende niveaus van onzekerheid in de voorspellingen worden opgenomen. Wij zullen elk van deze methoden achtereenvolgens toepassen.\nVoor elk van de onderstaande methoden zullen we het gemiddelde aantal stappen per dag voorspellen wanneer de temperatuur 10 graden Celsius bedraagt. We kunnen een nieuw dataframe opzetten dat we zullen gebruiken om de modelvoorspellingen te verkrijgen:\n\n# Gebruik het model om voorspellingen te doen\n# defineer nieuwe data van waaruit we deze voorspellingen maken \n# we doen voorspellingen voor het geval de gemiddelde dagtemperatuur 10 graden Celsius is for when the average daily temperature \nnew <- data.frame(temp = 10)"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#puntvoorspellingen-met-behulp-van-de-samenvattingen-van-de-afzonderlijke-waardecoëfficiënten-van-de-posterieure-verdelingen",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#puntvoorspellingen-met-behulp-van-de-samenvattingen-van-de-afzonderlijke-waardecoëfficiënten-van-de-posterieure-verdelingen",
    "title": "Regressie en nog zo iets",
    "section": "Puntvoorspellingen met behulp van de samenvattingen van de afzonderlijke waardecoëfficiënten van de posterieure verdelingen",
    "text": "Puntvoorspellingen met behulp van de samenvattingen van de afzonderlijke waardecoëfficiënten van de posterieure verdelingen\nDe eerste benadering komt overeen met die welke we zouden gebruiken bij een klassieke regressieanalyse. We gebruiken gewoon de puntschattingen uit de modelsamenvatting, voegen de nieuwe temperatuur in waarvoor we een voorspelling willen, en produceren onze voorspelling in de vorm van een enkel getal. We kunnen dit doen met de predict functie in R, of door de coëfficiënten uit onze modelsamenvatting te vermenigvuldigen. Beide methoden leveren dezelfde voorspelling op:\n\n# gebruik simpel de puntsamenvatting van de posterio distributie \n# voor de modelcoefficienten (van de modelsamenvatting van hierboven)\ny_point_est <- predict(fit_1, newdata = new)\n# zelfde predictie \"met de hand\"\ny_point_est_2 <- mean(sims[,1]) + mean(sims[,2])*new\n\nBeide leveren een puntvoorspelling van 16483.71.\n\n# ze zijn hetzelfde \npredict(fit_1, newdata = new)\n\n      1 \n16485.1 \n\nmean(sims[,1]) + mean(sims[,2])*new\n\n     temp\n1 16485.1"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#lineaire-voorspellingen-met-onzekerheid-in-de-interceptie-temperatuurcoëfficiënten",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#lineaire-voorspellingen-met-onzekerheid-in-de-interceptie-temperatuurcoëfficiënten",
    "title": "Regressie en nog zo iets",
    "section": "Lineaire voorspellingen met onzekerheid (in de interceptie + temperatuurcoëfficiënten)",
    "text": "Lineaire voorspellingen met onzekerheid (in de interceptie + temperatuurcoëfficiënten)\nWe kunnen echter genuanceerder zijn in onze voorspelling van het dagelijkse totale aantal stappen. Het hierboven berekende regressiemodel geeft 4.000 simulaties voor drie parameters - de intercept, de temperatuurcoëfficiënt, en sigma (de standaardafwijking van de residuen).\nDe volgende methode is geïmplementeerd in rstanarm met de posterior_linpred functie, en we kunnen deze gebruiken om de voorspellingen direct te berekenen. We kunnen hetzelfde resultaat ook “met de hand” berekenen met behulp van de matrix van simulaties uit de posterior verdeling van onze coëfficiëntschattingen. Bij deze aanpak wordt gewoon de temperatuur ingevoerd waarvoor wij voorspellingen willen (10 graden Celsius) en wordt voor elk van de simulaties het intercept opgeteld bij de temperatuurcoëfficiënt maal 10. Beide methoden leveren dezelfde vector van 4.000 voorspellingen op:\n\n# lineaire predictor met onzekerheid met gebruikmaking van posterior_linpred\n\ny_linpred <- posterior_linpred(fit_1, newdata = new)\n# uitrekenen \"met de hand\" \n# we gebruiken de sims matrix die we hierboven definieerden \n# sims <- as.matrix(fit_1)\ny_linpred_2 <- sims[,1] + (sims[,2]*10)  \n\nDat geeft dezelfde resultaten.\n\n# check - ze zijn hetzelfde!\nplot(y_linpred,y_linpred_2)\n\n\n\ncor.test(y_linpred, y_linpred_2)\n\n\n    Pearson's product-moment correlation\n\ndata:  y_linpred and y_linpred_2\nt = Inf, df = 3998, p-value < 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 1 1\nsample estimates:\ncor \n  1"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#posterior-predictive-distributies-met-de-onzekerheid-in-de-coëfficiëntschattingen-en-in-sigma",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#posterior-predictive-distributies-met-de-onzekerheid-in-de-coëfficiëntschattingen-en-in-sigma",
    "title": "Regressie en nog zo iets",
    "section": "Posterior Predictive Distributies met de onzekerheid in de coëfficiëntschattingen en in sigma",
    "text": "Posterior Predictive Distributies met de onzekerheid in de coëfficiëntschattingen en in sigma\nDe laatste voorspellingsmethode voegt nog een extra laag van onzekerheid toe aan onze voorspellingen, door de posterior verdelingen voor sigma mee te nemen in de berekeningen. Deze methode is beschikbaar via de functie posterior_predict, en we gebruiken opnieuw onze matrix van 4.000 simulaties om een vector van 4.000 voorspellingen te berekenen.\nDe posterior predict methode volgt de aanpak van de posterior_linpred functie hierboven, maar voegt een extra foutterm toe gebaseerd op onze schattingen van sigma, de standaardafwijking van de residuen. De berekening zoals getoond in het “met de hand” gedeelte van de code hieronder maakt. Het maakt duidelijk waar de willekeurigheid in het spel komt, en vanwege deze willekeurigheid zullen de resultaten van de posterior_predict functie en de “met de hand” berekening niet overeenkomen tenzij we dezelfde seed instellen voordat we elke berekening uitvoeren. Beide methoden leveren een vector van 4.000 voorspellingen op.\n\n# predictive distributie voor een nieuwe observatie met gebruik van posterior_predict\n\nset.seed(1)\ny_post_pred <- posterior_predict(fit_1, newdata = new)\n\nOf\n\n# uitrekenen \"met de hand\"\nn_sims <- nrow(sims)\nsigma <- sims[,3]\nset.seed(1)\ny_post_pred_2 <- as.numeric(sims[,1] + sims[,2]*10) + rnorm(n_sims, 0, sigma)\n\nDan zien we dezelfde resultaten:\n\n# check - ze zijn hetzelfde!\nplot(y_post_pred, y_post_pred_2)\n\n\n\ncor.test(y_post_pred, y_post_pred_2)\n\n\n    Pearson's product-moment correlation\n\ndata:  y_post_pred and y_post_pred_2\nt = Inf, df = 3998, p-value < 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 1 1\nsample estimates:\ncor \n  1"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#visualisatie-van-de-drie-soorten-voorspellingen",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#visualisatie-van-de-drie-soorten-voorspellingen",
    "title": "Regressie en nog zo iets",
    "section": "Visualisatie van de drie soorten voorspellingen",
    "text": "Visualisatie van de drie soorten voorspellingen\nLaten we een visualisatie maken die de resultaten weergeeft van de voorspellingen die we hierboven deden. We kunnen een enkele cirkel gebruiken om de puntvoorspelling van de regressiecoëfficiënten weer te geven in de modelsamenvatting, en histogrammen om de posterior verdelingen weer te geven die geproduceerd zijn door de lineaire voorspelling met onzekerheid (posterior_linpred) en posterior predictive distribution (posterior_predict) methoden die hierboven beschreven zijn.\nWe zetten eerst de vectoren van posterior verdelingen die we hierboven hebben gemaakt in een dataframe. We maken ook een dataframe met de enkele puntvoorspelling van onze lineaire voorspelling. Vervolgens stellen we ons kleurenpalet in (afkomstig uit het NineteenEightyR pakket) en maken dan de plot:\n\n# creeer een dataframe die de waarden van de posterior distributies omvat \n# van de voorspellingen van de totaal aantal dagelijkse stappen bij 10 grade Celcius\npost_dists <- as.data.frame(rbind(y_linpred, y_post_pred)) %>% \n      setNames(c('prediction'))\npost_dists$pred_type <- c(rep('posterior_linpred', 4000),\n                          rep('posterior_predict', 4000))\ny_point_est_df = as.data.frame(y_point_est)\n\nDat geeft de volgende plot:\n\n# 70 en meer kleuren - via NineteenEightyR pakket\n# https://github.com/m-clark/NineteenEightyR\npal <- c('#FEDF37', '#FCA811', '#D25117', '#8A4C19', '#573420')\n\nggplot(data = post_dists, aes(x = prediction, fill = pred_type)) + \n  geom_histogram(alpha = .75, position=\"identity\") + \n  geom_point(data = y_point_est_df,\n             aes(x = y_point_est,\n                 y = 100,\n                 fill = 'Linear Point Estimate'),\n             color =  pal[2],\n             size = 4,\n             # alpha = .75,\n             show.legend = F) +\n  scale_fill_manual(name = \"Prediction Method\",\n                    values = c(pal[c(2,3,5)]),\n                    labels = c(bquote(paste(\"Lineaire Punt Schatting \", italic(\"(predict)\"))),\n                               bquote(paste(\"Lineaire Voorspelling met Onzekerheid \" , italic(\"(posterior_linpred)\"))),\n                               bquote(paste(\"Posterior Predictive Distributie \",  italic(\"(posterior_predict)\"))))) +\n  # set the plot labels and title\n  labs(x = \"Predicted Daily Total Step Count\", \n       y = \"Aantal\", \n       title = 'Onzekerheid in Posterior Predictie Methode')   +\n  theme_bw()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nDeze grafiek is zeer informatief en maakt duidelijk hoe groot de onzekerheid is die we voor elk van onze voorspellingsmethoden krijgen. Hoewel alle drie voorspellingsmethoden op dezelfde plaats op de x-as gecentreerd zijn, verschillen zij sterk wat betreft de onzekerheid rond de voorspellingsramingen.\nDe puntvoorspelling is een enkele waarde en bevat als zodanig geen onzekerheid. De lineaire voorspelling met onzekerheid, die rekening houdt met de posterior verdeling van onze interceptie- en temperatuurcoëfficiënten, heeft een zeer scherpe piek, waarbij de modelschattingen binnen een relatief klein bereik variëren. De posterior predictive distributie varieert veel meer, met het laagste bereik van de verdeling onder nul, en het hoogste bereik van de verdeling boven 40.000!"
  },
  {
    "objectID": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#samenvatting-en-conclusie",
    "href": "posts/2022-02-11-regressie-en-zo/regressie-en-zo.html#samenvatting-en-conclusie",
    "title": "Regressie en nog zo iets",
    "section": "Samenvatting en conclusie",
    "text": "Samenvatting en conclusie\nIn dit artikel hebben we een eenvoudig model gemaakt met behulp van het rstanarm pakket in R, om te leren over Bayesiaanse regressie analyse. We gebruikten een dataset bestaande uit mijn geschiedenis van dagelijkse totale stappen, en bouwden een regressie model om het dagelijkse aantal stappen te voorspellen uit de dagelijkse gemiddelde temperatuur in graden Celsius. In tegenstelling tot de gewone kleinste kwadraten benadering die puntschattingen van modelcoëfficiënten oplevert, geeft de Bayesiaanse regressie posterior verdelingen van de coëfficiëntschattingen. Wij hebben een aantal verschillende samenvattingen en visualisaties van deze posterior verdelingen gemaakt om de coëfficiënten en de Bayesiaanse benadering in het algemeen te begrijpen - A) het gebruik van het bayesplot pakket om de posterior verdelingen van onze coëfficiënten te visualiseren\nB) het plotten van 500 hellingen van de posterior verdeling, en\nC) het uitvoeren van een controle van de posterior predictive distributie."
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html",
    "title": "Bayes’ principes",
    "section": "",
    "text": "Bayes Rules!"
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#inleiding",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#inleiding",
    "title": "Bayes’ principes",
    "section": "Inleiding",
    "text": "Inleiding\nOnlangs verscheen een prachtig boek van Alicia A. Johnson, Miles Q. Ot en Mine Dogucu onder de titel Bayes Rules! An Introduction to Applied Bayesian Modeling en het verscheen bij CRC Press (2022). Eerdere versies kon je al via bookdown bekijken (https://www.bayesrulesbook.com/) en vanaf de eerste keer dat ik het zag, was ik hier heel enthousiast over. Het boek heb ik direct besteld en vorige week kon ik het ophalen.\nHet boek bestaat uit vier duidelijke delen. Het eerste deel gaat in op de fundamenten van het Bayesiaanse perspectief. Het leert je denken als een Bayesiaan en het gaat in op die belangrijke Bayesiaanse regel \\(posterior=\\frac{prior.likelihood}{normaliserende constante}\\). Aan de hand van enkele voorbeelden gaan Johnson e.a. in op hoe het in de praktijk werkt. Daarna gaat het in op hoe kennis en data op elkaar inwerken en het laat enkele basisanalyses zien en hoe dat in deze vorm van statistiek werkt (normaal, binair en poisson). Het tweede deel is een meer technisch hoofdstuk en laat je ook onder de moterkap van deze techniek kijken. Het gaat ook op de wetenschappelijke principes van de benadering, waar je hier op moet letten, hoe je hiermee hypothesen kunt testen (niet alleen tov van een nulhypothese, maar hoeveel beter de ene hypothese is ten opzichte van de andere hyposthese) en hoe je hiermee ook kunt voorspellen. De twee volgende delen (Deel drie en vier) zijn praktische delen. Deel drie gaat in op regressieanalyses voor continue variabelen en classificatieanalyses voor binaire variabelen. Het vierde deel, ten slotte, gaat in op geclusterde datasets en hoe je hierarchische Bayesiaanse regressie en classificatieanalyses uitvoert.\nNatuurlijk, er zijn onderhand al verschillende interessante boeken te krijgen die je laten zien hoe Bayesiaanse denken in de praktijk kan werken. De boeken van Gelman, McElreath, Spiegelhalter en Kruschke verschenen de afgelopen tien/vijftien jaar en leren je dit. Maar Bayes Rules! vind ik op dit moment als introductieboek mogelijk wel het beste.\nNu het boek bij mij op het bureau ligt, kan ik er binnenkort een keer een korte recensie over schrijven. Voor nu heb ik uit elk deel een hoofdstuk genomen en het vertaald en bewerkt. Hieronder zie je een bewerking van het het vierde hoofdstuk van het eerste deel (Balance and Sequentiallity in Bayesian Analysis).Deze hoofdstukken zo overzetten is voor mij niet alleen een goede manier om het mij eigen te maken, maar ook een manier om het boek anderen aan te raden. Dus lezen en gebruiken deze Bayes Rules! An Introduction to Applied Bayesian Modeling"
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#balans-en-opeenvolging-in-bayesiaanse-analyses",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#balans-en-opeenvolging-in-bayesiaanse-analyses",
    "title": "Bayes’ principes",
    "section": "Balans en opeenvolging in Bayesiaanse Analyses",
    "text": "Balans en opeenvolging in Bayesiaanse Analyses\nIn Alison Bechdels stripverhaal The Rule uit 1985 zegt een personage dat ze alleen naar een film gaan als die aan de volgende drie regels voldoet (Bechdel 1986):\n\ner moeten minstens twee vrouwen in de film voorkomen;\n\ndeze twee vrouwen praten met elkaar; en\n\nze praten over iets anders dan een man.\nDeze criteria vormen de Bechdel-test voor de vertegenwoordiging van vrouwen in films. Als je aan films denkt die je hebt gezien, welk percentage van alle recente films slaagt dan volgens jou voor de Bechdel-test? Ligt dat dichter bij 10%, 50%, 80%, of 100%?\n\nLaat \\(\\pi\\), een willekeurige waarde tussen 0 en 1, het onbekende aandeel van recente films zijn die de Bechdel test doorstaan. Drie vrienden - de feminist, de onwetende, en de optimist - hebben enkele vooroordelen over \\(\\pi\\). Nadenkend over films die zij in het verleden heeft gezien, begrijpt de feminist dat het in de meeste films ontbreekt aan sterke vrouwelijke personages. De onwetende herinnert zich niet echt de films die hij gezien heeft, en weet dus niet zeker of het halen van de Bechdel test gebruikelijk of ongewoon is. De optimist ten slotte denkt dat de Bechdel-test een erg lage lat is voor de vertegenwoordiging van vrouwen in films, en gaat er dus van uit dat bijna alle films de test doorstaan. Dit alles om te zeggen dat drie vrienden drie verschillende voorafgaande modellen hebben van \\(\\pi\\). Geen probleem! Een Beta kan voorafgaand aan het opstellen van een model worden afgestemd op iemands voorkennis (zie de figuur hieronder).\nDoor de grootste aannemelijkheid vooraf te geven aan de waarden van \\(\\pi\\) die lager zijn dan 0,5, weerspiegelt de Beta(5,11) prior het inzicht van de feminist: de meerderheid van de films doorstaat de Bechdel test niet. De Beta(14,1) daarentegen plaatst een grotere aannemelijkheid vooraf op waarden van \\(\\pi\\) in de buurt van 1, en komt dus overeen met de vooronderstelling van de optimist. Dan blijft de Beta(1,1) of Unif(0,1) over die, door een gelijke aannemelijkheid te geven aan alle waarden van \\(\\pi\\) tussen 0 en 1, dat overeenkomt met het figuurlijke schouderophalen van de onwetende - het enige dat zij weet is dat \\(\\pi\\) een proportie is, en dus ergens tussen 0 en 1 ligt.\nDe drie analisten komen overeen een steekproef te nemen van \\(n\\) recente films en noteren \\(Y\\), het aantal dat de Bechdel test doorstaat. Herkenning van \\(Y\\) als het aantal “successen” in een vast aantal onafhankelijke proeven, specificeren zij de afhankelijkheid van \\(Y\\) van \\(\\pi\\) met behulp van een binomiaal model. Elke analist heeft dus een uniek Beta-Binomiaal model van \\(\\pi\\) met verschillende voorafgaande hyperparameters\n\\(\\alpha\\) en \\(\\beta\\):\n\\[Y|\\pi \\sim (Bin(n, \\pi) \\\\\n  \\pi \\sim Beta(\\alpha, \\beta)\\]\nWe weten dat elke analist een uniek posterior model heeft van \\(\\pi\\) dat afhangt van zijn of haar unieke prior (via \\(\\alpha\\) en \\(\\beta\\)) en de gemeenschappelijke waargenomen gegevens (via \\(Y\\) en \\(n\\))\n\\[\\pi|(Y=y) \\sim Beta (\\alpha + y, \\beta +n - Y)\\]\nAls je denkt “Kan iedereen zijn eigen voorkeuren hebben?! Zal dit altijd zo subjectief zijn?!” dan stel je de juiste vragen! En de vragen houden daar niet op. In hoeverre zouden hun verschillende priors van de analisten kunnen leiden tot drie verschillende posterior conclusies over de Bechdel test? Hoe zou dit kunnen afhangen van de steekproefgrootte en de uitkomsten van de filmgegevens die ze verzamelen? In hoeverre zullen de posterior inzichten van de analisten evolueren naarmate ze meer en meer gegevens verzamelen? Zullen ze het ooit eens worden over de vertegenwoordiging van vrouwen in film? We zullen deze fundamentele vragen hier onderzoeken en wij kijken naar ons vermogen om het Bayesiaanse denken verder te ontwikkelen.\nDus:\n- We onderzoek de evenwichtige invloed van de prior en data op de posterior.\n- We voeren verschillende achtereenvolgende Bayesiaanse analyses uit.\n\n# Laten we eerst de pakketten openen die we in dit hoofstuk zullen gebruiken (wel eerst binnenhalen)\nlibrary(bayesrules)\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.1.3\n\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv ggplot2 3.3.6     v purrr   0.3.4\nv tibble  3.1.7     v dplyr   1.0.9\nv tidyr   1.2.0     v stringr 1.4.1\nv readr   2.1.2     v forcats 0.5.1\n\n\nWarning: package 'ggplot2' was built under R version 4.1.3\n\n\nWarning: package 'tibble' was built under R version 4.1.3\n\n\nWarning: package 'tidyr' was built under R version 4.1.3\n\n\nWarning: package 'readr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\nWarning: package 'stringr' was built under R version 4.1.3\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nVerschillende priors, verschillende posteriors\nDe voorafgaande modellen van \\(\\pi\\) (het percentage recente films dat de Bechdel test doorstaat) zijn afgestemd op de onwetende, de feministe, en de optimist. Niet alleen weerspiegelen de verschillende prior gemiddelden onenigheid over de vraag of \\(\\pi\\) dichter bij 0 of 1 ligt, maar ook weerspiegelen hun verschillende niveaus van variabiliteit het feit dat de drie analisten niet allemaal even zeker zijn van hun kennis en informatie. Hoe zekerder ze daarover zijn, hoe kleiner de voorafgaande variabiliteit. Maar ook, hoe vager de prior-informatie, hoe groter de prior-variabiliteit. De priors van de optimist en de onwetende vertegenwoordigen hier twee uitersten. Een Beta(14,1) prior vertoont de kleinste variabiliteit en daarmee is de optimist het meest zeker in zijn prioriteitsbegrip van \\(\\pi\\) (of om duidelijker te zijn, dat bijna alle films de Bechdel test zullen doorstaan). Dergelijke priors noemen we informatief.\n\nEen informatieve prior reflecteert specifieke informatie over de onbekende variabele met grote zekerheid, bv. lage variabiliteit.\n\nMet de grootste prioriteitsvariabiliteit is de onwetende het minst zeker over \\(\\pi\\). In feite kent deze Beta(1,1) prior evenveel prior plausibiliteit toe aan elke waarde van \\(\\pi\\) tussen 0 en 1. Dit type prior model van “schouderophalen” (van “ik weet het echt niet”) heeft een officiële naam: het is een vage prior.\n\nEen vage of diffuse prior reflecteert weinig specifieke informatie over de onbekende variabele. Een vlakke prior die gelijke plausibiliteit toekent aan alle mogelijke waarden van de variabele, is een speciaal geval.\n\nDe volgende voor de hand liggende vraag is dan: hoe zullen hun verschillende priors de posterior conclusies van de feminist, de onwetende en de optimist beïnvloeden? Om deze vraag te beantwoorden, hebben we gegevens nodig. Onze analisten besluiten een willekeurige steekproef te nemen van \\(n=20\\) recente films te bekijken, gebruikmakend van gegevens die verzameld zijn voor het FiveThirtyEight-artikel over de Bechdel-test Het bayesrules-pakket bevat een gedeeltelijke versie van deze dataset, genaamd bechdel. Een volledige versie wordt geleverd door het fivethirtyeight R-pakket (Kim, Ismay, and Chunn 2020). Samen met de titel en het jaar van elke film in deze dataset, geeft de binaire variabele aan of de film slaagde of niet voor de Bechdel test:\n\n# Importeer data\ndata(bechdel, package = \"bayesrules\")\n\n# Neem een sample van 20 films\nset.seed(84735)\nbechdel_20 <- bechdel %>% \n  sample_n(20)\n\nbechdel_20 %>% \n  head(3)\n\n# A tibble: 3 x 3\n   year title      binary\n  <dbl> <chr>      <chr> \n1  2005 King Kong  FAIL  \n2  1983 Flashdance PASS  \n3  2013 The Purge  FAIL  \n\n\nVan de 20 films in deze steekproef slaagden er slechts 9 (45%) voor de test:\n\nbechdel_20 %>% \n  tabyl(binary) %>% \n  adorn_totals(\"row\")\n\n binary  n percent\n   FAIL 11    0.55\n   PASS  9    0.45\n  Total 20    1.00\n\n\nDe posterior modellen van de drie analisten voor\\(\\pi\\) die volgen uit de formule \\(\\pi|(Y=y) \\sim Beta(\\alpha+y, \\beta+n-y)\\) op hun unieke voorgaande modellen en gemeenschappelijke filmgegevens, zijn samengevat in tabel hieronder en de figuur hierboven. Bijvoorbeeld, de posterior parameters van de feminist worden berekend door \\(\\alpha+y=5+9=14\\) en \\(\\beta+n-y=11+20-9=22\\)\n\n\n\nAnalyst\nPrior\nPosterior\n\n\n\n\nfeminist\nBeta(5,11)\nBeta(14,22)\n\n\nonwetende\nBeta(1,1)\nBeta(10,12)\n\n\noptimist\nBeta(14,1)\nBeta(23,12)\n\n\n\nHad je instinct gelijk? Herinner je dat de optimist begon met het vasthoudend optimistisme vooraf over \\(\\pi\\) - zijn prior model had een hoog gemiddelde met lage variabiliteit. Het is dan ook niet verwonderlijk dat zijn posterior model niet zo synchroon loopt met de gegevens als de posteriors van de andere analisten. De trieste gegevens waarbij slechts 45% van de 20 films de test doorstonden was niet genoeg om hem ervan te overtuigen dat er een probleem is in Hollywood - hij denkt nog steeds dat de waarden van \\(\\pi\\) boven 0,5 het meest plausibel is. Aan het andere uiterste staat de onwetende die begon met een vlak, vaag model van \\(\\pi\\). Zonder enige voorinformatie weerspiegelt zijn posterior model direct de inzichten die zijn verkregen uit de waargenomen filmgegevens. In feite is zijn posterior niet te onderscheiden van de geschaalde likelihood functie.\n\n\n\nPosterior models"
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#verschillende-data-verschillende-posteriors",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#verschillende-data-verschillende-posteriors",
    "title": "Bayes’ principes",
    "section": "Verschillende data, verschillende posteriors",
    "text": "Verschillende data, verschillende posteriors\nAls jij je zorgen maakt over het feit dat onze drie analisten achteraf verschillende opvattingen hebben over \\(\\pi\\), de proportie van recente films die de Bechdel halen, wanhoop dan nog niet. Vergeet niet dat data ook een rol spelen in een Bayesiaanse analyse. Om deze dynamiek te onderzoeken, beschouwen we drie nieuwe analisten - Morteza, Nadide, en Ursula - die allen de optimistische Beta(14,1) prior voor \\(\\pi\\) delen maar elk toegang hebben tot andere gegevens. Morteza beoordeelt \\(n=13\\) films uit het jaar 1991, waarvan \\(Y=6\\) (ongeveer 46%) door de Bechdel komen:\n\nbechdel %>% \n  filter(year == 1991) %>% \n  tabyl(binary) %>% \n  adorn_totals(\"row\")\n\n binary  n   percent\n   FAIL  7 0.5384615\n   PASS  6 0.4615385\n  Total 13 1.0000000\n\n\nNadide beoordeelt \\(n=63\\) films uit 2000, waaronder \\(Y=29\\) (ongeveer 46%) door de Bechdel komen:\n\nbechdel %>% \n  filter(year == 2000) %>% \n  tabyl(binary) %>% \n  adorn_totals(\"row\")\n\n binary  n   percent\n   FAIL 34 0.5396825\n   PASS 29 0.4603175\n  Total 63 1.0000000\n\n\nTot slot, beoordeelt Ursula \\(n=99\\) films uit 2013, waarvan er \\(Y=46\\) (ongeveer 46%) door de Bechdel komen:\n\nbechdel %>% \n  filter(year == 2013) %>% \n  tabyl(binary) %>% \n  adorn_totals(\"row\")\n\n binary  n   percent\n   FAIL 53 0.5353535\n   PASS 46 0.4646465\n  Total 99 1.0000000\n\n\nWat een toeval! Hoewel Morteza, Nadide, en Ursula verschillende gegevens hebben verzameld, constateren ze elk een Bechdel slaagpercentage van ongeveer 46%. Toch is hun steekproefomvang \\(n\\) verschillend - Morteza bekeek slechts 13 films terwijl Ursula er 99 bekeek.\nDe posterior modellen van de drie analisten voor \\(\\pi\\) die volgen uit de toepassing van hun gegevens op hun gemeenschappelijke Beta(14,1) voormodel en unieke filmgegevens, zijn samengevat in de figuur en tabel hieronder. Merk op dat hoe groter de steekproefgrootte \\(n\\) hoe “indringender” de likelihoodfunctie. Bijvoorbeeld, de waarschijnlijkheidsfunctie die het slagingspercentage van 46% in Morteza’s kleine steekproef van 13 films weergeeft is vrij breed - deze gegevens zijn relatief plausibel voor elke \\(\\pi\\) tussen 15% en 75%. Ursula’s waarschijnlijkheidsfunctie daarentegen, met het slagingspercentage van 46% in een veel grotere steekproef van 99 films weergeeft, is smal - haar gegevens zijn onwaarschijnlijk voor \\(\\pi\\) waarden buiten het bereik van 35% tot 55%. We zien dat hoe groter de waarschijnlijkheid, hoe meer invloed de gegevens hebben op de posterior. Morteza blijft het minst overtuigd door het lage Bechdel-slaagpercentage dat in zijn kleine steekproef wordt waargenomen, terwijl Ursula het meest overtuigd is. Haar vroege optimisme evolueerde naar een posterior begrip dat \\(\\p\\) waarschijnlijk tussen 40% en 55% ligt.\n\n\n\nPosterior models\n\n\nTabel: De prior en posterior modellen voor \\(\\pi\\) zijn geconstrueerd in het licht van een gemeenschappelijke Beta(14,1)-prior en verschillende gegevens.\n\n\n\nAnalyst\nData\nPosterior\n\n\n\n\nMorteza\n\\(Y=6;n=13\\)\nBeta(20,8)\n\n\nNadide\n\\(Y=26;n=63\\)\nBeta(43,35)\n\n\nUrsula\n\\(Y=46;n=99\\)\nBeta(60,54)"
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#het-vinden-van-de-balans-tussen-de-prior-en-de-data",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#het-vinden-van-de-balans-tussen-de-prior-en-de-data",
    "title": "Bayes’ principes",
    "section": "Het vinden van de balans tussen de prior en de data",
    "text": "Het vinden van de balans tussen de prior en de data\n\nObservaties aan concepten verbinden\nWe hebben gekeken naar de invloed die verschillende priors en verschillende gegevens kunnen hebben op ons posterior begrip van een onbekende variabele. De posterior is echter een meer genuanceerd touwtrekken tussen deze twee kanten. De figuren hieronder illustreren het evenwicht dat het posterior model vindt tussen de prior en de gegevens. Elke rij komt overeen met een uniek prior model en elke kolom met een unieke reeks gegevens.\nVan links naar rechts neemt de steekproefgrootte toe van \\(n=13\\) tot \\(n=99\\) films met behoud van het aandeel films dat de Bechdel-test doorstaat: \\(Y/n\\sim0.46\\) . De waarschijnlijkheid en, dienovereenkomstig, de invloed van de gegevens op de posterior nemen toe met de steekproefgrootte \\(n\\). Dit betekent ook dat de invloed van onze voorkennis afneemt naarmate we nieuwe gegevens vergaren. Verder hangt de snelheid waarmee de posterior balans doorslaat in het voordeel van de gegevens af van de prior. Van boven naar beneden over het rooster gaan de priors van informatief (Beta(14,1)) naar vaag (Beta(1,1)). Het spreekt vanzelf dat hoe informatiever de prior is, hoe groter zijn invloed op de posterior is.\nDoor deze waarnemingen te combineren levert de laatste kolom in het rooster een zeer belangrijke Bayesiaanse clou op: ongeacht de sterkte van en discrepanties tussen hun prioriteitsbegrip van \\(\\pi\\) zullen drie analisten tot een gemeenschappelijke posterior interpretatie komen in het licht van sterke gegevens. Deze vaststelling is een opluchting. Als Bayesiaanse modellen niets zouden betekenen in het licht van steeds meer gegevens, zouden we een probleem hebben.\nMet dit soort gegevens kun je spelen en kijken naar de rol die de prior en de data spelen in een posterior analyse, gebruik je de plot_beta_binomial() en summarize_beta_binomial() functies in het bayesrules pakket om het Beta-Binomial posterior model van \\(\\pi\\) onder verschillende combinaties van voorafgaande Beta(\\(\\alpha, \\beta\\)) modellen en waargenomen gegevens, \\(Y\\) successen in \\(n\\) proeven:\n# Plot the Beta-Binomial model\nplot_beta_binomial(alpha = ___, beta = ___, y = ___, n = ___)\n\n# Obtain numerical summaries of the Beta-Binomial model\nsummarize_beta_binomial(alpha = ___, beta = ___, y = ___, n = ___)\n\n\nConcepten met theorie verbinden\nDe patronen die we hebben waargenomen in het posterior evenwicht tussen de prior en de data zijn intuïtief. Ze worden ook ondersteund door een elegant wiskundig resultaat. Daar moet je het boek maar voor lezen."
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#sequentiële-analyse-evolueren-met-dat",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#sequentiële-analyse-evolueren-met-dat",
    "title": "Bayes’ principes",
    "section": "Sequentiële analyse: Evolueren met dat",
    "text": "Sequentiële analyse: Evolueren met dat\nWe hebben de toenemende invloed van de gegevens en de afnemende invloed van de prior op de posterior onderzocht naarmate er meer en meer gegevens binnenkomen. Overweeg de nuances van dit concept. De uitdrukking “naarmate er meer gegevens binnenkomen” roept het idee op dat het verzamelen van gegevens, en daarmee de evolutie in ons begrip van de posterior, stapsgewijs gebeurt. Zo is het inzicht van wetenschappers in de klimaatverandering in de loop van tientallen jaren geëvolueerd naarmate zij nieuwe informatie kregen. Het inzicht van presidentskandidaten in hun kansen om een verkiezing te winnen evolueert in de loop van maanden naarmate nieuwe opiniepeilingen beschikbaar komen. Het bieden van een formeel kader voor deze evolutie is een van de meest krachtige eigenschappen van Bayesiaanse statistiek!\nIn een eerder hoofdstuk gingen ze in op Milgram’s gedragsstudie over gehoorzaamheid. Daar gaat \\(\\pi\\) om het aandeel van de mensen die het gezag zullen gehoorzamen zelfs als dit betekent dat ze anderen schade toebrengen. In de studie van Milgram betekende gehoorzamen aan het gezag het toedienen van een zware elektrische schok aan een andere deelnemer (wat in feite een list was). Voorafgaand aan de experimenten van Milgram verwachtte een fictieve psycholoog dat weinig mensen gezag zouden gehoorzamen als ze een ander zouden schaden:\n\\(\\pi\\sim Beta(1,10)\\). In het onderzoek stelden we vast dat 26 van de 40 deelnemers aan het onderzoek een schok toebrachten die zij opvatten als een zware schok.\nStel nu dat de psycholoog deze gegevens stapsgewijs, dag na dag, over een periode van drie dagen verzamelde. Elke dag, evalueerde ze \\(n\\) proefpersonen en registreerde ze \\(Y\\), het aantal dat de zwaarste schok kreeg (dus \\(Y|\\pi \\sim Bin(n,\\pi)\\)Y. Van de \\(n=10\\) dag-één deelnemers, alleen \\(Y=1\\) de zwaarste schok. Dus aan het eind van de eerste dag is het begrip van de psycholoog van \\(\\pi\\) al geëvolueerd en blijkt\n\\[\\pi|Y=1) \\sim Beta(2,19)\\]\nDag twee was veel drukker en de resultaten grimmiger: onder \\(n=20\\) deelnemers, gaf \\(Y=17\\) de zwaarste schok. Aan het eind van dag twee was het begrip van de psycholoog van \\(\\pi\\) opnieuw geëvolueerd - \\(\\pi\\) was waarschijnlijk groter dan zij hadden verwacht. Dus, het posterior model van \\(\\pi\\) aan het eind van dag twee is \\(Beta(19,22)\\). Op dag drie heeft \\(Y=8\\) van \\(n=10\\) deelnemers de zwaarste schok toegediend, en dus is het model geëvolueerd van een \\(Beta(19,22)\\) prior naar een \\(Beta(27,24)\\) posterior. De volledige evolutie van de oorspronkelijke \\(Beta(1,10)\\) prior van de psycholoog naar een \\(Beta(27,24)\\) posterior aan het einde van de driedaagse studie is samengevat in de tabel hieronder.\n\n\n\nDag\nData\nModel\n\n\n\n\n0\nNA\nBeta(1,10)\n\n\n1\n\\(Y=1;n=10\\)\nBeta(2,19)\n\n\n2\n\\(Y=17;n=20\\)\nBeta(19,22)\n\n\n3\n\\(Y=8;n=10\\)\nBeta(27,24)\n\n\n\nHet proces dat we zojuist hebben doorlopen, het incrementeel bijwerken van het posterior model van de psycholoog wordt meer algemeen een sequentiële Bayesiaanse analyse of Bayesiaans leren genoemd.\nDe mogelijkheid om te evolueren naarmate nieuwe gegevens binnenkomen, is een van de krachtigste kenmerken van het Bayesiaanse raamwerk. Dit soort sequentiële analyses heeft ook twee fundamentele en gemeenschappelijke sensitieve eigenschappen. Ten eerste is het uiteindelijke posterior model invariant t.a.v. data volgorde: het wordt niet beïnvloed door de volgorde waarin we de data observeren. Bijvoorbeeld, stel dat de psycholoog de studiegegevens van Milgram in omgekeerde volgorde had geobserveerd: \\(Y=8\\) van\n\\(n=10\\) op dag één, \\(Y=17\\) van \\(n=20\\) op dag twee, en \\(Y=1\\) van \\(n=10\\) op dag drie. De resulterende evolutie in hun begrip van \\(\\pi\\) is samengevat in de tabel hieronder. Het evoluerende begrip van de psycholoog van \\(\\pi\\) verloopt een ander pad. Het eindigt echter nog steeds op dezelfde plaats - de Beta(27,24) posterior.\n\n\n\nDag\nData\nModel\n\n\n\n\n0\nNA\nBeta(1,10)\n\n\n1\n\\(Y=8;n=10\\)\nBeta(9,12)\n\n\n2\n\\(Y=17;n=20\\)\nBeta(26,15)\n\n\n3\n\\(Y=1;n=10\\)\nBeta(27,24)\n\n\n\nHet tweede fundamentele kenmerk van een sequentiële analyse is dat de uiteindelijke posterior alleen afhangt van de cumulatieve gegevens. Bijvoorbeeld, in de gecombineerde drie dagen van Milgram’s experiment, waren er \\(n=10+20+20=40\\) deelnemers die \\(Y=1+17+8=26\\) de zwaarste schok opleverde. In paragraaf 3.6 evalueerden wij deze gegevens in één keer, niet stapsgewijs. Daarbij sprongen wij rechtstreeks van het oorspronkelijke Beta(1,10) model van de psycholoog naar het Beta(27,24) posterior model van \\(\\pi\\). Dat wil zeggen, of we de gegevens nu incrementeel of in één keer evalueren, we komen op dezelfde plaats uit."
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#bewijs-van-invariantie-van-gegevensvolgorde",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#bewijs-van-invariantie-van-gegevensvolgorde",
    "title": "Bayes’ principes",
    "section": "Bewijs van invariantie van gegevensvolgorde",
    "text": "Bewijs van invariantie van gegevensvolgorde\nIn de vorige sectie zag je het bewijs van datavolgorde invariantie in actie. Hier zullen we bewijzen dat alle Bayesiaanse modellen van deze eigenschap genieten. Dit deel is leuk, maar hoef je niet echt te weten voor je toekomstige werk.Hier gaan we daar niet verder op in (ook voor dit meer technische deel moet je het boek lezen)."
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#een-opmerking-over-subjectiviteit",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#een-opmerking-over-subjectiviteit",
    "title": "Bayes’ principes",
    "section": "Een opmerking over subjectiviteit",
    "text": "Een opmerking over subjectiviteit\nWe zinspeelden eerder op een veelgehoorde kritiek op Bayesiaanse statistiek - het is te subjectief. In het bijzonder zijn sommigen bezorgd dat het “subjectief” afstemmen van een prior model een Bayesiaanse analist in staat stelt om tot elke conclusie te komen die hij wil. In het licht van wat we hier hebben geleerd, kunnen we deze kritiek meer rigoureus bestrijden. Voordat we dat doen, willen we eerst een aantal concepten nog eens nader bekijken en uitbreiden.\nBevestigd is dat een Bayesiaan inderdaad een prior kan bouwen op basis van “subjectieve” ervaring. Heel zelden is dit een slechte zaak, en heel vaak is het een goede zaak! In het beste geval kan een subjectieve prioriteit een schat aan ervaringen uit het verleden weerspiegelen die in onze analyse moeten worden opgenomen - het zou jammer zijn dat niet te doen. Zelfs als een subjectieve prior ingaat tegen het feitelijk waargenomen bewijs, verdwijnt zijn invloed op de posterior naarmate dit bewijs zich opstapelt. We hebben één uitzondering gezien in het ergste geval. En het was te voorkomen. Als een subjectieve prioriteit koppig genoeg is om de waarschijnlijkheid van 0 toe te kennen aan een mogelijke parameterwaarde, zal geen hoeveelheid tegenbewijs genoeg zijn om het te veranderen.\nTenslotte, hoewel we je aanmoedigen om kritisch te zijn in je toepassing van Bayesiaanse methoden, maak je alsjeblieft geen zorgen dat ze subjectiever zijn dan frequentistische methoden. Geen mens is in staat om alle subjectiviteit uit een analyse te halen. De levenservaringen en kennis die we met ons meedragen bepalen alles, van de onderzoeksvragen die we stellen tot de data die we verzamelen. Het is belangrijk om zowel bij Bayesiaanse als bij frequentistische analyses rekening te houden met de mogelijke implicaties van deze subjectiviteit."
  },
  {
    "objectID": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#samenvatting",
    "href": "posts/2022-03-22-bayesiaanse-principes/bayes-principes.html#samenvatting",
    "title": "Bayes’ principes",
    "section": "Samenvatting",
    "text": "Samenvatting\nWij hebben het evenwicht onderzocht dat een posterior model aanbrengt tussen een prior model en de gegevens. In het algemeen zagen wij de volgende tendensen:\n\nInvloed van de prior\nHoe minder vaag en hoe informatiever de prior, d.w.z. hoe groter onze priorzekerheid, hoe meer invloed de prior op de posterior heeft.\nInvloed van de gegevens\nHoe meer gegevens we hebben, hoe meer invloed de gegevens hebben op de posterior. Dus, als twee onderzoekers voldoende gegevens hebben, zullen ze met verschillende priors vergelijkbare posteriors hebben.\n\nVerder hebben we gezien dat we in een sequentiële Bayesiaanse analyse ons posterior model incrementeel bijwerken naarmate er meer en meer gegevens binnenkomen. De uiteindelijke bestemming van deze posterior wordt niet beïnvloed door de volgorde waarin we deze gegevens observeren (d.w.z. de posterior is datavolgorde invariant) of door de vraag of we de gegevens in één keer of opbouwend observeren."
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html",
    "title": "Machine Learning Workflow",
    "section": "",
    "text": "Tidymodels is the relatively new package for machine learning with R. It is the successor to the caret package which is used during the Introduction to Data Science-course of the Harvard University (Kuhn & Johnson, 2013; Irizarry, 2020). Tidymodels is a collection of modeling packages that, like the tidyverse, has consistent API and are designed to work together specifically to support predictive analytics and machine learning. I followed and looked at different books (Kuhn & Silge, 2021; Kuhn en Johnson, 2019) blogs (Lendway, 2020; Roamiar (2021); Ruiz (2019), Barter (2019; Seyedia (2021) and couses/video’s (Lewis, 2020; Silge, 2021; Silge 2020). I tried to learn this new system and wrote different blogs in Dutch on thishere.\nTidymodels is a grammar for modeling that makes things a lot easier and provides a unified modeling and analysis interface to seamlessly access several model varities in R. tidymodels is a meta-package that installs and load the core packages listed below that you need for modeling and machine learning;\n- recipes is tidy interface for to data pre-processing tools for feature/variables engineering;\n- rsample provides infrastucture for efficient data splitting and resampling;\n- parsnip is a tidy, unified interface to models that can be used to try a range of models without getting bagged down in the syntactical minutae of the underlying packages;\n- tune helps you optimize the hyperparameters of your model and chose pre-processing steps;\n- yardstick measures the effectiveness of models during performance metrics;\n- workflow bundles your pre-processing modeling and post-processing together;\n- dials creates and manages tuning parameters and parameters grids;\n- brooms convert the information in common statistical R objects into user-friendly predictable formats.\nThis year (2021) I learned working with tidymodels. I tried to finish the Capstone course with the use of this metapackage. I will show you the different steps in the working proces.\nLet us first open the packages used in this article (tidymodels, but also tidyverse, finalfit, caret, rpart and randomforest):"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#splitting-the-data",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#splitting-the-data",
    "title": "Machine Learning Workflow",
    "section": "SPLITTING THE DATA",
    "text": "SPLITTING THE DATA\nNow we understand the data we have to split the data into: a) Train set, b) Test set. Here we work on the last pre-model analysis. All functions below come from the rsample package, which is part of tidymodels. First we set the seed to fix the randomization and to make reproducabiltiy possible. We use 80% of the dataset for the trainingset. For a big dataset as this wine-data set with 1591 observations, 80:20-splitting works well. We split it and than make a training- and test-dataset."
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#linear-modelling",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#linear-modelling",
    "title": "Machine Learning Workflow",
    "section": "1. Linear modelling",
    "text": "1. Linear modelling\nFor the outcome or target variable quality, we first research some different linear regression models and choose the best one based on indices. For these tasks, we store each formula in a different R object.\nWe have to define the data: - The target variable. quality is the target variable and it is numeric - The features of the model (predictors) are the other (independent) variables here and they are numeric variables also.\nFuthermore, we design a simple formula to predict the target variable. In this formula (f1) all the available 11 predictors are used.\n\nformula <- formula(quality ~ fixed_acidity + volatile_acidity + citric_acid + \n                   residual_sugar + chlorides + free_sulfur_dioxide + \n                   total_sulfur_dioxide + density + pH + sulphates + alcohol)\n\nLet us fit a linear regression model to the data. What we do: - First, we created an object that will store the model fit.\n- Then, we specify the model.\n- Then, We specify also that we work with regression because of the continue target variable (quality). - Then, we specify also the lm package to train the model. - And we finish in this chunck by adding the formula and the training data to fit the model.\nLet us see how this workflow works.\n\nlm_fit <- \n  linear_reg() %>% \n  set_mode(\"regression\") %>% \n  set_engine(\"lm\") %>% \n  fit(formula, data = train_data) \n\nWe present the results on different ways\nBut this is probably the best and clearest way to show the results.\n\nsummary(lm_fit$fit)\n\n\nCall:\nstats::lm(formula = quality ~ fixed_acidity + volatile_acidity + \n    citric_acid + residual_sugar + chlorides + free_sulfur_dioxide + \n    total_sulfur_dioxide + density + pH + sulphates + alcohol, \n    data = data)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2.68924 -0.37784 -0.04982  0.46247  1.89438 \n\nCoefficients:\n                       Estimate Std. Error t value Pr(>|t|)    \n(Intercept)           2.125e+01  2.458e+01   0.864   0.3877    \nfixed_acidity         1.515e-02  3.015e-02   0.503   0.6154    \nvolatile_acidity     -9.626e-01  1.419e-01  -6.783 1.80e-11 ***\ncitric_acid          -1.749e-02  1.682e-01  -0.104   0.9172    \nresidual_sugar        1.879e-02  1.750e-02   1.074   0.2831    \nchlorides            -2.160e+00  4.601e-01  -4.696 2.95e-06 ***\nfree_sulfur_dioxide   5.057e-03  2.477e-03   2.042   0.0414 *  \ntotal_sulfur_dioxide -4.053e-03  8.358e-04  -4.850 1.39e-06 ***\ndensity              -1.685e+01  2.511e+01  -0.671   0.5022    \npH                   -4.781e-01  2.216e-01  -2.157   0.0312 *  \nsulphates             9.522e-01  1.256e-01   7.581 6.63e-14 ***\nalcohol               2.675e-01  3.070e-02   8.712  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.6545 on 1260 degrees of freedom\nMultiple R-squared:  0.3583,    Adjusted R-squared:  0.3527 \nF-statistic: 63.96 on 11 and 1260 DF,  p-value: < 2.2e-16\n\n\nWe can also visualize the fit summary by using the broom package which is inside tidymodels.\n\ntidy(lm_fit$fit) %>% mutate_if(is.numeric, round, 3)\n\n# A tibble: 12 x 5\n   term                 estimate std.error statistic p.value\n   <chr>                   <dbl>     <dbl>     <dbl>   <dbl>\n 1 (Intercept)            21.2      24.6       0.864   0.388\n 2 fixed_acidity           0.015     0.03      0.503   0.615\n 3 volatile_acidity       -0.963     0.142    -6.78    0    \n 4 citric_acid            -0.017     0.168    -0.104   0.917\n 5 residual_sugar          0.019     0.018     1.07    0.283\n 6 chlorides              -2.16      0.46     -4.70    0    \n 7 free_sulfur_dioxide     0.005     0.002     2.04    0.041\n 8 total_sulfur_dioxide   -0.004     0.001    -4.85    0    \n 9 density               -16.9      25.1      -0.671   0.502\n10 pH                     -0.478     0.222    -2.16    0.031\n11 sulphates               0.952     0.126     7.58    0    \n12 alcohol                 0.267     0.031     8.71    0"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#decision-tree",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#decision-tree",
    "title": "Machine Learning Workflow",
    "section": "2. Decision tree",
    "text": "2. Decision tree\nAfter we worked with linear regression, it is possible to work with other models which maybe give us better results for predicting the outcome. Let us first look at decision tree modeling. A decision tree is tree-like flowchart that assigns labels to individual observations. It splits it into homogeneous subsets, which share the same class labels. For this you need decision tree package and for this you have to install and open the library of rpart. We see similar steps here in the machine learning workflow. Once again, the workflow: - define an object dt_fit;\n- tell that we work with decision tree;\n- set the mode on regression;\n- set the engine on rpart;\n- fit the formula on the training data-set.\nPrint the results\n\nprint(dt_fit$fit)\n\nn= 1272 \n\nnode), split, n, deviance, yval\n      * denotes terminal node\n\n 1) root 1272 841.093600 5.645440  \n   2) alcohol< 10.45 735 314.223100 5.345578  \n     4) sulphates< 0.585 323  99.275540 5.133127 *\n     5) sulphates>=0.585 412 188.939300 5.512136  \n      10) total_sulfur_dioxide>=59.5 121  33.239670 5.198347 *\n      11) total_sulfur_dioxide< 59.5 291 138.831600 5.642612  \n        22) volatile_acidity>=0.405 220  94.836360 5.527273 *\n        23) volatile_acidity< 0.405 71  32.000000 6.000000 *\n   3) alcohol>=10.45 537 370.324000 6.055866  \n     6) sulphates< 0.645 240 156.733300 5.716667  \n      12) volatile_acidity>=0.995 7   6.857143 4.142857 *\n      13) volatile_acidity< 0.995 233 132.017200 5.763948  \n        26) pH>=3.365 114  62.280700 5.543860  \n          52) free_sulfur_dioxide< 8.5 34  19.529410 5.117647 *\n          53) free_sulfur_dioxide>=8.5 80  33.950000 5.725000 *\n        27) pH< 3.365 119  58.924370 5.974790 *\n     7) sulphates>=0.645 297 163.663300 6.329966  \n      14) alcohol< 11.45 180  95.777780 6.111111  \n        28) volatile_acidity>=0.405 94  35.276600 5.829787 *\n        29) volatile_acidity< 0.405 86  44.930230 6.418605  \n          58) total_sulfur_dioxide>=49.5 20   8.550000 5.850000 *\n          59) total_sulfur_dioxide< 49.5 66  27.954550 6.590909 *\n      15) alcohol>=11.45 117  46.000000 6.666667 *\n\n\nAs a sidestep, we can visualize this, but than we have to install and open the visNetwork and sparkline packages. Then we see this.\n\nlibrary(visNetwork)\nlibrary(sparkline)\n\nWarning: package 'sparkline' was built under R version 4.1.3\n\nvisTree(dt_fit$fit)"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#random-forest",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#random-forest",
    "title": "Machine Learning Workflow",
    "section": "3. Random forest",
    "text": "3. Random forest\nA third model we use here is RandomForest. RandomForest is a natural extension of DecisionTree. A RandomForest is a collection of Deciontrees that are aggregated by majority rule, and is in essence a collection ‘bootstrapped’ decision trees. You need to install randomForest package and open the library randomForest. And also here, once again the same steps: - define object rf_fit;\n- tell we want to use randomforest;\n- set the mode again on regression;\n- set the engine here on randomForest;\n- fit the model on the training_set.\nPrint these results (not shown here).\n\nprint(rf_fit$fit)\n\n\nCall:\n randomForest(x = maybe_data_frame(x), y = y) \n               Type of random forest: regression\n                     Number of trees: 500\nNo. of variables tried at each split: 3\n\n          Mean of squared residuals: 0.3259127\n                    % Var explained: 50.71"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#accuracy-of-the-lm-model",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#accuracy-of-the-lm-model",
    "title": "Machine Learning Workflow",
    "section": "1. Accuracy of the lm-model",
    "text": "1. Accuracy of the lm-model\nLet us first look at the accuracy of the linear-model.\nNow we see a new column, .pred, with a predicted scores for each row.\nIt gives here the following mse-score for linear modeling, which we show here.\n\nhead(lm_mse)\n\n# A tibble: 1 x 2\n  type    MSE\n  <chr> <dbl>\n1 lm    0.467"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#accuracy-of-the-decision-tree-model",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#accuracy-of-the-decision-tree-model",
    "title": "Machine Learning Workflow",
    "section": "2. Accuracy of the Decision Tree Model",
    "text": "2. Accuracy of the Decision Tree Model\nThen we look at the accuracy of the DecisionTree Model.\nThe decision model gives the following mse-score.\n\nhead(dt_mse)\n\n# A tibble: 1 x 2\n  type    MSE\n  <chr> <dbl>\n1 dt    0.596"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#accuracy-of-the-random-forest-model",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#accuracy-of-the-random-forest-model",
    "title": "Machine Learning Workflow",
    "section": "3. Accuracy of the Random Forest Model",
    "text": "3. Accuracy of the Random Forest Model\nAnd then ofcourse we also have to look at the accuracy of the RandomForest-model.\nThe Random Forest Model gives us the following mse-score:\n\nhead(rf_mse)\n\n# A tibble: 1 x 2\n  type    MSE\n  <chr> <dbl>\n1 rf    0.408"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#all-results-together",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow.html#all-results-together",
    "title": "Machine Learning Workflow",
    "section": "All results together",
    "text": "All results together\nLet us put all the results together and compare them with each other.\nLet us show these results together.\n\nhead(res)\n\n# A tibble: 3 x 2\n  type    MSE\n  <chr> <dbl>\n1 lm    0.467\n2 dt    0.596\n3 rf    0.408\n\n\nAltogether the prediction scores don’t look very well, but we know that RandomForest is the best model for prediction.\n\nmetrics(rf_pred, quality, pred)\n\n# A tibble: 3 x 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard       0.638\n2 rsq     standard       0.378\n3 mae     standard       0.351\n\n\nNow we choosed the random forest model, we can look at the importance of the ten independent variables and compare them with each other. We see that alcohol is the most import predictor for quality followed by sulphates ad volatile_acidity. Residul-sugar, pH and fixed_acidity are the lowest important predictors for quality of wine.\n\nlibrary(vip)\nvip(rf_fit)\n\n\n\n\nLet us look at which percentage of the test sample are wrongly predicted.\n\\(105/307*100= 34,2%\\) is not correctly predicted. So \\(65,8%\\) is predicted correctly with this model. We choose the random_forest model as the best opportunity here. Let us look at it once again.\n\nhead(rf_pred)\n\n# A tibble: 6 x 13\n  fixed_~1 volat~2 citri~3 resid~4 chlor~5 free_~6 total~7 density    pH sulph~8\n     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl>   <dbl>\n1     11.2    0.28    0.56     1.9   0.075      17      60   0.998  3.16    0.58\n2      7.5    0.5     0.36     6.1   0.071      17     102   0.998  3.35    0.8 \n3      8.9    0.62    0.18     3.8   0.176      52     145   0.999  3.16    0.88\n4      8.9    0.22    0.48     1.8   0.077      29      60   0.997  3.39    0.53\n5      7.9    0.43    0.21     1.6   0.106      10      37   0.997  3.17    0.91\n6      7.1    0.71    0        1.9   0.08       14      35   0.997  3.47    0.55\n# ... with 3 more variables: alcohol <dbl>, quality <dbl>, pred <dbl>, and\n#   abbreviated variable names 1: fixed_acidity, 2: volatile_acidity,\n#   3: citric_acid, 4: residual_sugar, 5: chlorides, 6: free_sulfur_dioxide,\n#   7: total_sulfur_dioxide, 8: sulphates"
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/Blob-1.0/LICENSE.html",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/Blob-1.0/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/canvas-toBlob-1.0/LICENSE.html",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/canvas-toBlob-1.0/LICENSE.html",
    "title": "",
    "section": "",
    "text": "This software is licensed under the MIT license."
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/canvas-toBlob-1.0/LICENSE.html#mit-license",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/canvas-toBlob-1.0/LICENSE.html#mit-license",
    "title": "",
    "section": "MIT license",
    "text": "MIT license\nCopyright © 2016 Eli Grey and Devin Samarin.\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/FileSaver-1.1.20151003/LICENSE.html",
    "href": "posts/2022-03-25-machine-learning-workflow/machine-learning-workflow_files/FileSaver-1.1.20151003/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "",
    "text": "Bayes Rules!"
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#inleiding",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#inleiding",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "Inleiding",
    "text": "Inleiding\nOnlangs verscheen een prachtig boek van Alicia A. Johnson, Miles Q. Ot en Mine Dogucu onder de titel Bayes Rules! An Introduction to Applied Bayesian Modeling en het verscheen bij CRC Press (2022). Eerdere versies stonden kon je al via bookdown bekijken (https://www.bayesrulesbook.com/) en vanaf de eerste keer dat ik het zag, was ik hier heel enthousiast over. Het boek heb ik direct besteld en vorige week kon ik het ophalen.\nHet boek bestaat uit vier duidelijke delen. Het eerste deel gaat in op de fundamenten van het Bayesiaanse perspectief. Het leert je denken als een Bayesiaan en het gaat in op die belangrijke Bayesiaanse regel \\(posterior=\\frac{prior.likelihood}{normaliserende constante}\\). Aan de hand van enkele voorbeelden gaan Johnson e.a. in op hoe het in de praktijk werkt. Daarna gaat het in op hoe kennis en data op elkaar inwerken en laat het enkele basisanalyses zien en hoe dat in deze vorm van statistiek werkt (normaal, binair en poisson). Het tweede deel is een meer technisch hoofdstuk en laat je ook onder de moterkap van deze techniek kijken. Het gaat ook in op de wetenschappelijke principes van de benadering, waar je hier op moet letten, hoe je hiermee hypothesen kunt testen (niet alleen tov van een nulhypothese, maar hoeveel beter de ene hypothese is ten opzichte van de andere hyposthese) en hoe je hiermee ook kunt voorspellen. De twee volgende delen (Deel drie en vier) zijn praktische delen. Deel drie gaat in op regressieanalyses voor continue variabelen en classificatieanalyses voor binaire variabelen. Het vierde deel ten slotte gaat in op geclusterde datasets en hoe je hierarchische Bayesiaanse regressie en classificatieanalyses uitvoert.\nNatuurlijk, er zijn onderhand al verschillende interessante boeken te krijgen die je laten zien hoe Bayesiaanse denken in de praktijk kan werken. De boeken van Gelman, McElreath, Spiegelhalter en Kruschke verschenen de afgelopen tien/vijftien jaar en leren je dit. Maar Bayes Rules! vind ik op dit moment als introductieboek mogelijk wel het beste.\nNu het boek bij mij op het bureau ligt, kan ik er binnenkort een keer een korte recensie over schrijven. Voor nu heb ik uit elk deel een hoofdstuk genomen en het vertaald en bewerkt. Hieronder zie je een bewerking van het veertiende hoofdstuk van het derde deel (Naïve Bayes Classification).Hoofdstukken zo overzetten is voor mij niet alleen een goede manier om het mij eigen te maken, maar ook een manier om het boek anderen aan te raden. Dus lezen en gebruiken deze Bayes Rules! An Introduction to Applied Bayesian Modeling"
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#naïeve-bayesiaanse-classificatie",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#naïeve-bayesiaanse-classificatie",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "Naïeve Bayesiaanse classificatie",
    "text": "Naïeve Bayesiaanse classificatie\nOp Antartica zijn er verschillende penguinsoorten te vinden waaronder de *Adelie**, Chinstrap en Gentoo-soorten.\n\\[\\\nY = \\begin{cases}\nA=Adelie \\\\\nC=Chinstrap \\\\\nG=Gentoo\\\\\n\\end{cases}\n\\]\\]\nWe zullen deze drie soorten classificeren op basis van het gewicht\n$$\n\nX_1 =\n\\[\\begin{cases}\n1=bovenhetgemiddeldegewicht \\\\\n0=onderhetgemiddeldegewicht\\\\\n\\end{cases}\\]\n]$$\n(\\(x_1=1\\) als het boven het gemiddelde gewicht van 4200 g ligt en een \\(X_1=0\\) als dat gemiddelde lager is dan 4300 gram).\nVerder is er \\[x_2=snavellengte (in mm)\\]\n\\[x_3=flipperlengte\\]\nDe penguins_bayes data, oorspronkelijk ter beschikking gesteld door Gorman, Williams, en Fraser (2014) en vervolgens verspreid door Horst, Hill, en Gorman (2020), bevat de bovenstaande soort- en kenmerkinformatie voor een steekproef van 344 Antarctische pinguïns:\n\n# Laden van pakketten \nlibrary(bayesrules)\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.1.3\n\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv ggplot2 3.3.6     v purrr   0.3.4\nv tibble  3.1.7     v dplyr   1.0.9\nv tidyr   1.2.0     v stringr 1.4.1\nv readr   2.1.2     v forcats 0.5.1\n\n\nWarning: package 'ggplot2' was built under R version 4.1.3\n\n\nWarning: package 'tibble' was built under R version 4.1.3\n\n\nWarning: package 'tidyr' was built under R version 4.1.3\n\n\nWarning: package 'readr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\nWarning: package 'stringr' was built under R version 4.1.3\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\nlibrary(e1071)\n\nWarning: package 'e1071' was built under R version 4.1.3\n\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n# Laden van data\ndata(penguins_bayes)\npenguins <- penguins_bayes\n\nOnder deze 344 pinguïns zijn er 152 Adelies, 68 Chinstrap/Kinband pinguïns, en 124 Gentoos. We gaan er steeds van uit dat de proportionele verdeling van deze soorten in onze dataset de verdeling van de soorten in het wild weerspiegelt. Dat wil zeggen dat we bij elke nieuwe pinguïn aannemen dat het hoogst waarschijnlijk een Adélie is (44,2%) en het minst waarschijnlijk een Chinstrap(19,8%). Zo ziet de geschatte verdeling er dan uit:\n\npenguins %>% \n  tabyl(species)\n\n   species   n   percent\n    Adelie 152 0.4418605\n Chinstrap  68 0.1976744\n    Gentoo 124 0.3604651\n\n\nEr zijn drie mogelijkheden of categorieën voor de \\(Y\\). Gelukkig zijn er allerlei hulpmiddel om te schatten over welke soort we het hebben. Logistische regressie werkt hier niet zo goed voor, naïeve Bayes classificatie wel. Ten opzichte van Bayesiaanse logistische regressie heeft naïeve Bayes classificatie een paar voordelen:\n\nhet kan categorische respons variabelen classificeren, dus Y met twee of meer categorieën;\n\ner is niet veel theorie nodig buiten de regel van Bayes;\n\nen zij is rekenkundig efficiënt, d.w.z. dat er geen MCMC-simulatie voor nodig is."
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#classificeren-van-één-pinquin",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#classificeren-van-één-pinquin",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "Classificeren van één pinquin",
    "text": "Classificeren van één pinquin\nLaten we met het Bayesiaans classificeren van één penguin beginnen. Stel dat we een penguin vinden die minder dan 4200 gram weegt, die een snavel heeft van 50 mm en een flipper van 195mm. We willen iets ontwikkelen dat ons helpt om vast te stellen met welk soort we hier te maken hebben.Laten we de drie soorten en hun gewicht eens afbeelden.\n\nggplot(penguins %>% drop_na(above_average_weight), \n       aes(fill = above_average_weight, x = species)) + \n  geom_bar(position = \"fill\")\n\n\n\n\nFig 1. Proporties van elk soort met bovengemiddeld gewicht\n\n\n\n\nChinstraps is relatief het lichtste soort. Maar we moeten tegelijkertijd in ons achterhoofd houden dat dit de minst voorkomende soort is. Dat wil zeggen dat we moeten denken als Bayesianen door de informatie uit onze gegevens over het te combineren met onze informatie vooraf (prior) over de proportionele verdeling van het soort om een posterior model te construeren voor de soort van onze pinguïn. De naïeve Bayes classificatie benadering van deze taak is niets meer dan een direct beroep op de beproefde Bayes’ Regel. In het algemeen, om de posterior waarschijnlijkheid te berekenen dat onze pinguïn van de soort\n\\[f(y|x_1) = \\frac{\\text{prior}\\cdot\\text{likelihood}}{\\text{normaliserende constante}}=\\frac{f(y)L(y|X_1)}{f(x_1)}\\] waarvoor geldt de wet van de totale waarschijnlijkheid\n\\[f(x_1)=\\sum_{ally^'}\\]\nEen tabel waarin de bovengemiddelde gewichtsstatus per soort (above_average_weight) wordt uitgesplitst, verschaft de nodige informatie om deze Bayesiaanse berekening te voltooien:\n\npenguins %>% \n  select(species, above_average_weight) %>% \n  na.omit() %>% \n  tabyl(species, above_average_weight) %>% \n  adorn_totals(c(\"row\", \"col\"))\n\n   species   0   1 Total\n    Adelie 126  25   151\n Chinstrap  61   7    68\n    Gentoo   6 117   123\n     Total 193 149   342\n\n\nIn feite kunnen we het posterior model van de soort van onze pinguïn rechtstreeks uit deze tabel berekenen. Bijvoorbeeld, merk op dat van de 193 pinguïns die onder het gemiddelde gewicht zitten, 126 Adelies zijn. Er is dus ongeveer 65% posterior kans dat deze pinguïn een Adelie is:\n\\[f(y=A|x_1=0)=\\frac{126}{93}\\approx{0.6528}\\] Laten we dit resultaat bevestigen door de informatie uit onze tabel hierboven in de regel van Bayes in te voeren. Deze vervelende stap is niet om te ergeren, maar om te oefenen voor generalisaties die we zullen moeten maken in meer ingewikkelde omgevingen. Ten eerste, onze informatie over het soort geeft aan dat Adelies het meest voorkomen en Chinstraps het minst:\n\\[f(y=A)=\\frac{151}{342}, f(y=C)=\\frac{68}{342}, f(y=G)=\\frac{123}{342}\\]\nVerder tonen de waarschijnlijkheden aan dat een lager dan gemiddeld gewicht het meest voorkomt bij Chinstrapspinguïns. Bijvoorbeeld, 89.71% van de Chinstrapspinguïns maar slechts 4.88% van de Gentoos hebben een lager dan gemiddeld gewicht:\n\\[L=(y=A|x_1=0)=\\frac{126}{151}\\approx{0.8344} \\\\\n  L=(y=A|x_1=0)=\\frac{61}{68}\\approx{0.8971} \\\\\n  L=(y=A|x_1=0)=\\frac{6}{123}\\approx{0.0488}\\]\nDoor deze priors en waarschijnlijkheden te gebruiken, wordt de totale waarschijnlijkheid van een pinguïn met een lager dan gemiddeld gewicht voor alle soorten\n\\[f(x_1=0)=\\frac{151}{342}\\times\\frac{126}{151}+\\frac{68}{342}\\times\\frac{61}{68}+\\frac{123}{342}\\times\\frac{6}{123}=\\frac{193}{342}\\]\nTenslotte, door de regel van Bayes kunnen we bevestigen dat er een 65% posterior kans is dat deze pinguïn een Adelie is:\n\\[f(y=A|x_1=0)=\\frac{f(y=A)L(y=A|x_1=0)}{f(x_1=0)} \\\\\n              =\\frac{151/342.(126/151)}{193/342}\\approx{0.6528}\\]\nTegelijk zien we dat\n\\[f(y=C|x_1=0)\\approx{0.3161}\\] en \\[f(y=G|x_1=0)\\approx{0.0311}\\]\nAlles bij elkaar is de posterior waarschijnlijkheid dat deze pinguïn een Adelie is meer dan dubbel zo groot als die van de andere twee soorten. Dus, onze naïeve Bayes classificatie, gebaseerd op onze voorinformatie en het onder-gemiddelde gewicht van de pinguïn alleen, is dat deze pinguïn een Adelie is. Hoewel een lager dan gemiddeld gewicht relatief minder voorkomt bij Adélie’s dan bij Kinbandpinguïns, werd de uiteindelijke classificatie over de rand geduwd door het feit dat Adélie’s veel algemener zijn.\n\nÉén kwantitatieve voorspeller\nLaten we het gewicht van de pinguïn even buiten beschouwing en het soort indelen aan de hand van het feit dat hij een snavel van 50 mm heeft.\n\nggplot(penguins, aes(x = bill_length_mm, fill = species)) + \n  geom_density(alpha = 0.7) + \n  geom_vline(xintercept = 50, linetype = \"dashed\")\n\nWarning: Removed 2 rows containing non-finite values (stat_density).\n\n\n\n\n\n\n# Bereken het gemiddelde en de sd van het sample voor elke Y-groep \npenguins %>% \n  group_by(species) %>% \n  summarize(mean = mean(bill_length_mm, na.rm = TRUE), \n            sd = sd(bill_length_mm, na.rm = TRUE))\n\n# A tibble: 3 x 3\n  species    mean    sd\n  <fct>     <dbl> <dbl>\n1 Adelie     38.8  2.66\n2 Chinstrap  48.8  3.34\n3 Gentoo     47.5  3.08\n\n\nHet uitzetten van de afgestemde normale modellen voor elke soort bevestigt dat deze naïeve Bayes-aanname niet perfect is - het is iets idealistischer dan de dichtheidsplots van de ruwe gegevens van het figuur hierboven. Maar het is goed genoeg om verder te gaan.\n\nggplot(penguins, aes(x = bill_length_mm, color = species)) + \n  stat_function(fun = dnorm, args = list(mean = 38.8, sd = 2.66), \n                aes(color = \"Adelie\")) +\n  stat_function(fun = dnorm, args = list(mean = 48.8, sd = 3.34),\n                aes(color = \"Chinstrap\")) +\n  stat_function(fun = dnorm, args = list(mean = 47.5, sd = 3.08),\n                aes(color = \"Gentoo\")) + \n  geom_vline(xintercept = 50, linetype = \"dashed\")\n\n\n\n\nHerinner u dat deze Normaliteitsveronderstelling het mechanisme verschaft dat we nodig hebben om de waarschijnlijkheid van het waarnemen van een 50 mm lange snavel bij elk van de drie soorten te evalueren, \\(L(y|x_2=50)\\) Terugkomend op figuur 14.3, komen deze waarschijnlijkheden overeen met de hoogte van de normale densiteitskromme bij een snavellengte van 50 mm. Dus, een 50 mm lange bek is iets waarschijnlijker bij Kinband- dan bij Gentoo pinguïns, en hoogst onwaarschijnlijk bij Adelie pinguïns. Meer specifiek kunnen we de waarschijnlijkheden berekenen met dnorm()\n\n# L(y = A | x_2 = 50)\ndnorm(50, mean = 38.8, sd = 2.66)\n\n[1] 2.119955e-05\n\n# L(y = C | x_2 = 50)\ndnorm(50, mean = 48.8, sd = 3.34)\n\n[1] 0.1119782\n\n# L(y = G | x_2 = 50)\ndnorm(50, mean = 47.5, sd = 3.08)\n\n[1] 0.09317395\n\n\n\n\nTwee voorspellers\nWe hebben nu twee naïeve Bayes classificaties gemaakt van de soort van onze pinguïn: de ene enkel gebaseerd op het feit dat onze pinguïn onder het gemiddelde gewicht zit en de andere enkel gebaseerd op zijn 50mm lange snavel (naast onze eerdere informatie). En deze classificaties zijn niet identiek: wij classificeerden de pinguïn als Adelie in de eerste analyse en Gentoo in de tweede. Deze discrepantie toont aan dat er ruimte is voor verbetering in onze naïeve Bayes classificatie methode. In het bijzonder, in plaats van enkel te vertrouwen op één enkele voorspeller, kunnen we meerdere voorspellers in ons classificatieproces opnemen.\nBeschouw de informatie dat onze pinguïn een snavellengte heeft van\n\\(X_2=50mm\\) en een flipperlengte van \\(X_3=195mm\\). Elk van deze metingen alleen kan leiden tot een verkeerde classificatie. Net zoals het moeilijk is om een onderscheid te maken tussen de Chinstrap- en de Gentoopinguïn op basis van hun snavellengte, is het moeilijk om een onderscheid te maken tussen de Chinstrap en de Adéliepinguïn op basis van hun flipperlengte alleen (zie hieronder).\n\nggplot(penguins, aes(x = bill_length_mm, fill = species)) + \n  geom_density(alpha = 0.6)\n\nWarning: Removed 2 rows containing non-finite values (stat_density).\n\n\n\n\nggplot(penguins, aes(x = flipper_length_mm, fill = species)) + \n  geom_density(alpha = 0.6)\n\nWarning: Removed 2 rows containing non-finite values (stat_density).\n\n\n\n\n\nMAAR de soorten zijn redelijk te onderscheiden wanneer we de informatie over snavel- en vleugellengte combineren. Onze pinguïn met een 50 mm lange bek en 195 mm lange vleugels, voorgesteld op het snijpunt van de stippellijnen in de figuur hieronder, ligt nu precies tussen de Chinstrap waarnemingen:\n\nggplot(penguins, aes(x = flipper_length_mm, y = bill_length_mm, \n                     color = species)) + \n  geom_point() \n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\nLaten we naïeve Bayes classificatie gebruiken om deze gegevens in evenwicht te brengen met onze voorafgaande informatie over het soort lidmaatschap. Om de posterior waarschijnlijkheid te berekenen dat de pinguïn van de soort \\(Y=y\\) kunnen we de Bayes aanpassen aan onze twee voorspellers, \\(X_2=x_2\\) en \\(X_3=x_3\\).\nDit geeft weer een nieuwe wending: Hoe kunnen we de likelihood functie berekenen die twee variabelen omvat,\\(L(y|x_2, x_3)\\)? Dit is waar weer een andere “naïeve” veronderstelling binnensluipt. Naïeve Bayes classificatie gaat ervan uit dat voorspellers voorwaardelijk onafhankelijk zijn, dus\n\\[L(y|x_2, x_3)=f(x_2, x_3|y)=f(x_2|y)f(x_3|y)\\] Met andere woorden, binnen elke soort nemen we aan dat de lengte van de snavel van een pinguïn geen verband houdt met de lengte van zijn flipper. Wiskundig en computationeel gezien, maakt deze veronderstelling het naïeve Bayes algoritme efficiënt en beheersbaar. Maar het kan het ook verkeerd maken. Kijk nog eens naar de figuur hiervoven. Binnen elke soort lijken de vleugellengte en de snavellengte positief gecorreleerd te zijn, niet onafhankelijk. Toch gaan we naïef om met de veronderstelling van onvolmaakte onafhankelijkheid, en dus met de mogelijkheid dat onze classificatienauwkeurigheid zou kunnen worden afgezwakt.\nGecombineerd gaat het multivariabele naïeve Bayes-model ervan uit dat onze twee voorspellers Normaal en voorwaardelijk onafhankelijk zijn. We hebben dit normale model al afgestemd op de snalvellengte \\(x_2\\). Op dezelfde manier kunnen we de soortspecifieke normale modellen voor de lengte van de vleugels afstemmen op de overeenkomstige steekproefgemiddelden en standaardafwijkingen:\n\n# Bereken eerst het samplegemiddelde en sd voor elke Y groep\npenguins %>% \n  group_by(species) %>% \n  summarize(mean = mean(flipper_length_mm, na.rm = TRUE), \n            sd = sd(flipper_length_mm, na.rm = TRUE))\n\n# A tibble: 3 x 3\n  species    mean    sd\n  <fct>     <dbl> <dbl>\n1 Adelie     190.  6.54\n2 Chinstrap  196.  7.13\n3 Gentoo     217.  6.48\n\n\nZo kunnen wij voor elk van de drie soorten nagaan hoe groot de kans is dat een vleugelengte van 195 mm wordt waargenomen, \\(L(y|x_3=195)=f(x_3=195|y)\\)\n\n# L(y = A | x_3 = 195)\ndnorm(195, mean = 190, sd = 6.54)\n\n[1] 0.04554175\n\n# L(y = C | x_3 = 195)\ndnorm(195, mean = 196, sd = 7.13)\n\n[1] 0.05540502\n\n# L(y = G | x_3 = 195)\ndnorm(195, mean = 217, sd = 6.48)\n\n[1] 0.0001933746\n\n\nVoor elke soort hebben we nu de waarschijnlijkheid dat we een snavellengte waarnemen van \\(x_2=50mm\\), de waarschijnlijkheid van het waarnemen van een vleugellengte van \\(x_3=195\\) en de voorafgaande waarschijnlijkheid (prior). Gecombineerd is de kans op het waarnemen van een 50 mm lange snavel en een 195 mm lange vleugel voor elk soort \\(Y=y\\), gewogen met de prior van elk van de soorten als volgt:\n$$f(y^{‘}=A)L(y^{’}=A|x_2=50, x3=195)= \\\nf(y^{‘}=C)L(y^{’}=C|x_2=50, x3=195)= \\ f(y^{‘}=G)L(y^{’}=G|x_2=50, x3=195)= $$ met een som van\n\\[\\sum_{all y^{'}}f(y^{'})L(y^{'}|x_2=50, x_3=195)\\approx0.001241\\]\nAls we dat in de Bayes’regel stoppen dan wordt de waarschijnlijkheid dat de penguin een Adeliesoort is:\n\\[f(y=A|x_2=50,x_3=195)=\\frac{\\frac{151}{342}\\times0.0000212\\times0.04555}{0.001241}\\approx0.0003\\]\nZo kunnen we de kans op de andere twee soorten ook berekeken:\n\\[f(y=C|x_2=50,x_3=195)\\approx0.9944 \\\\\n  f(y=G|x_2=50,x_3=195)\\approx0.0052\\] Conclusie, onze penguin is vrijwel zeker een Chinstrap. Hoewel we niet tot deze conclusie zijn gekomen op basis van een fysiek kenmerk alleen, schetsen deze twee samen een vrij duidelijk beeld."
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#implementeren-en-evalueren-van-naive-bayesisaanse-classificatie",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#implementeren-en-evalueren-van-naive-bayesisaanse-classificatie",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "Implementeren en evalueren van naive Bayesisaanse classificatie",
    "text": "Implementeren en evalueren van naive Bayesisaanse classificatie\nDat was aardig, maar we hoeven niet al dit werk met de hand te doen. Om naïeve Bayes classificatie in R te implementeren, gebruiken we de naïeveBayes() functie in het e1071 pakket (Meyer et al. 2021). Net zoals bij stan_glm(), voeden we naiveBayes() met de data en een formule die aangeeft welke variabelen in de analyse moeten worden gebruikt. Maar aangezien naive Bayes de prioriteitswaarschijnlijkheden rechtstreeks uit de gegevens berekent en de implementatie geen MCMC-simulatie vereist, hoeven we ons geen zorgen te maken over het verstrekken van informatie m.b.t. de priormodellen of Markovketens. Hieronder bouwen we twee naïeve Bayes classificatie-algoritmen, een die alleen bill_length_mm gebruikt en een die ook flipper_length_mm bevat:\n\nnaive_model_1 <- naiveBayes(species ~ bill_length_mm, data = penguins)\nnaive_model_2 <- naiveBayes(species ~ bill_length_mm + flipper_length_mm, \n                            data = penguins)\n\nLaten we deze beide toepassen om onze_penguin te classificeren die we de hele tijd hebben bestudeerd:\n\nour_penguin <- data.frame(bill_length_mm = 50, flipper_length_mm = 195)\n\nWe beginnen met naive_model_1. De predict() functie geeft de posterior waarschijnlijkheden van elke soort terug, samen met een uiteindelijke classificatie. Deze classificatie volgt een eenvoudige regel: classificeer de pinguïn als de soort met de hoogste posterior waarschijnlijkheid. De resultaten van dit proces zijn gelijkaardig aan deze die we hierboven “met de hand” verkregen met een kleine afwijking door een afrondingsfout. In feite, gebaseerd op de snavellengte alleen, is onze beste gok dat deze pinguïn een Gentoo is:\n\npredict(naive_model_1, newdata = our_penguin, type = \"raw\")\n\n           Adelie Chinstrap    Gentoo\n[1,] 0.0001690279 0.3978306 0.6020004\n\npredict(naive_model_1, newdata = our_penguin)\n\n[1] Gentoo\nLevels: Adelie Chinstrap Gentoo\n\n\n\npredict(naive_model_2, newdata = our_penguin, type = \"raw\")\n\n           Adelie Chinstrap      Gentoo\n[1,] 0.0003445688 0.9948681 0.004787365\n\n\nEn net zoals we hierboven concludeerden, als we rekening houden met zowel de snavellengte als de lengte van de vleugels, is onze beste gok dat deze pinguïn een Chinstrap is.\nWe kunnen op dezelfde manier onze naïeve Bayes modellen toepassen om een willekeurig aantal pinguïns te classificeren. Zoals met logistische regressie, zullen we twee gebruikelijke benaderingen volgen om de nauwkeurigheid van deze classificaties te evalueren:\n\nconfusion matrixen construeren die de waargenomen soorten van onze steekproef pinguïns vergelijken met hun naïeve Bayes soortclassificaties;\n\nom een beter idee te krijgen van hoe goed onze naïeve Bayes modellen nieuwe pinguïns classificeren, berekenen we kruisgevalideerde schattingen van de nauwkeurigheid van de classificatie.\n\nOm met de eerste benadering te beginnen, classificeren we elk van de pinguïns met zowel naive_model_1 als naive_model_2 en slaan deze op in penguins als class_1 en class_2:\n\npenguins <- penguins %>% \n  mutate(class_1 = predict(naive_model_1, newdata = .),\n         class_2 = predict(naive_model_2, newdata = .))\n\nDe classificatieresultaten worden hieronder getoond voor vier willekeurig gekozen pinguïns, afgezet tegen de werkelijke species van deze pinguïns. Voor de laatste twee pinguïns, geven de twee modellen dezelfde classificaties (Adelie) en deze classificaties zijn correct. Voor de eerste twee pinguïns, leiden de twee modellen tot verschillende classificaties. In beide gevallen is naive_model_2 correct.\n\nset.seed(84735)\npenguins %>% \n  sample_n(4) %>% \n  select(bill_length_mm, flipper_length_mm, species, class_1, class_2) %>% \n  rename(bill = bill_length_mm, flipper = flipper_length_mm)\n\n# A tibble: 4 x 5\n   bill flipper species   class_1 class_2  \n  <dbl>   <int> <fct>     <fct>   <fct>    \n1  47.5     199 Chinstrap Gentoo  Chinstrap\n2  40.9     214 Gentoo    Adelie  Gentoo   \n3  41.3     194 Adelie    Adelie  Adelie   \n4  38.5     190 Adelie    Adelie  Adelie   \n\n\nHet valt natuurlijk nog te bezien of naive_model_2 beter presteert dan naive_model_1 in het algemeen. Daartoe geven de onderstaande confusion matrixen een overzicht van de classificatienauwkeurigheid van de modellen over alle pinguïns in onze steekproef\n\n# Confusion matrix voor naive_model_1\npenguins %>% \n  tabyl(species, class_1) %>% \n  adorn_percentages(\"row\") %>% \n  adorn_pct_formatting(digits = 2) %>%\n  adorn_ns()\n\n   species       Adelie Chinstrap       Gentoo\n    Adelie 95.39% (145) 0.00% (0)  4.61%   (7)\n Chinstrap  5.88%   (4) 8.82% (6) 85.29%  (58)\n    Gentoo  6.45%   (8) 4.84% (6) 88.71% (110)\n\n# Confusion matrix voor naive_model_2\npenguins %>% \n  tabyl(species, class_2) %>% \n  adorn_percentages(\"row\") %>% \n  adorn_pct_formatting(digits = 2) %>%\n  adorn_ns()\n\n   species       Adelie   Chinstrap       Gentoo\n    Adelie 96.05% (146)  2.63%  (4)  1.32%   (2)\n Chinstrap  7.35%   (5) 86.76% (59)  5.88%   (4)\n    Gentoo  0.81%   (1)  0.81%  (1) 98.39% (122)\n\n\nLaten we, met deze aanwijzingen in gedachten, de twee confusion matrixen onderzoeken. Een snelle blik leert dat naive_model_2 het over de hele linie beter doet. Niet alleen zijn de classificatiepercentages voor elk van de Adelie, Chinstrap en Gentoo soorten hoger dan in naive_model_1, maar ook de totale nauwkeurigheid is hoger.\nHet naive_model_2 classificeert 327 (146+59+122) van de 344 pinguïns correct (95%). Terwijl het naive_model_1 slechts 261 pinguïns correct classificeert (76%). Waar naive_model_2 de grootste verbetering vertoont t.o.v. naive_model_1 is in de classificatie van de Chinstrappinguïns. In naive_model_1 wordt slechts 9% van de Chinstrapspinguïns juist geklasseerd, met maar liefst 85% die verkeerd geklasseerd wordt als Gentoo. Met 87% is de classificatienauwkeurigheid voor Chinstraps veel hoger in naive_model_2.\nTenslotte kunnen we, voor de nodige zorgvuldigheid, 10-voudige kruisvalidatie gebruiken om te evalueren en te vergelijken hoe goed onze naïeve Bayes classificatiemodellen nieuwe pinguïns classificeren, niet enkel deze uit onze steekproef. We doen dit met behulp van de naive_classification_summary_cv() functie in het bayesrules pakket:\n\nset.seed(84735)\ncv_model_2 <- naive_classification_summary_cv(\n  model = naive_model_2, data = penguins, y = \"species\", k = 10)\n\nHet cv_model_2$folds object bevat de classificatienauwkeurigheid voor elk van de 10 vouwen (k=10) terwijl cv_model_2$cv het gemiddelde neemt van de resultaten over alle 10 vouwen:\n\ncv_model_2$cv\n\n   species       Adelie   Chinstrap       Gentoo\n    Adelie 96.05% (146)  2.63%  (4)  1.32%   (2)\n Chinstrap  7.35%   (5) 86.76% (59)  5.88%   (4)\n    Gentoo  0.81%   (1)  0.81%  (1) 98.39% (122)\n\n\nDe nauwkeurigheidspercentages in deze kruisgevalideerde confusion matrixen zijn vergelijkbaar met die in de niet-kruisgevalideerde verwarringsmatrix hierboven. Dit impliceert dat ons naïef Bayes model bijna even goed lijkt te presteren op nieuwe pinguïns als op het originele pinguïn monster dat we gebruikten om dit model te bouwen."
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#naëve-bayes-vs-logistische-regressie",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#naëve-bayes-vs-logistische-regressie",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "Naëve Bayes vs logistische regressie",
    "text": "Naëve Bayes vs logistische regressie\nGezien de drie pinguïnsoorten, vereiste onze classificatie-analyse hierboven een naïeve Bayes classificatie - logistische regressie toepassen was zelfs geen optie. Echter, in scenario’s met een binaire categorische respons variabele \\(Y\\) zijn zowel logistische regressie als naïeve Bayes haalbare classificatiebenaderingen. Zowel naïeve Bayes als logistische regressie hebben hun voor- en nadelen. Hoewel naïeve Bayes zeker rekenkundig efficiënt is, maakt het ook een aantal zeer starre en vaak ongeschikte veronderstellingen over datastructuren. Je hebt misschien ook opgemerkt dat we wat nuance verliezen met naïeve Bayes. In tegenstelling tot het logistische regressiemodel met\n\\[log(\\frac{\\pi}{1-\\pi})=\\beta_0+\\beta_1X_1+...\\beta_kX_p,\\]\nnaïeve Bayes mist regressiecoëfficiënten \\(\\beta_1\\). Dus, hoewel naïeve Bayes informatie over voorspellers \\(X\\) kan omzetten in classificaties van \\(Y\\) maar doet dit zonder veel opheldering over de relaties tussen deze variabelen.\nOf naïeve Bayes of logistische regressie het juiste instrument is voor een binaire classificatie hangt af van de situatie. In het algemeen, als de starre naïeve Bayes-aannamen ongepast zijn of als u belang hecht aan de specifieke verbanden tussen \\(Y\\) en \\(X\\) (d.w.z. je wilt niet gewoon een reeks classificaties), dan moet je logistische regressie gebruiken. Anders is naïeve Bayes misschien precies wat je nodig hebt. Beter nog, kies niet! Probeer beide tools uit en leer ervan."
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#samengevat",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#samengevat",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "Samengevat",
    "text": "Samengevat\nNaive Bayes classificatie is een handig hulpmiddel voor het classificeren van categorische responsvariabelen\n\\(Y\\) met twee of meer categorieën. Stel (\\(X_1, X_2, ...,X_p)\\) zijn een set van \\(p\\) mogelijke voorspellers van \\(Y\\), naïef Bayes berekent de posterior waarschijnlijkheid van elke categorie via de Bayes regel:\n\\[f(y|x_1, x_2,...,x_p)=\\frac{f(y)L(y|x_1, x_2, ...,x_p)}{\\sum_{ally^{'}f(y^{'}L(y^{'}|x_1, x_2, ...,x_p)}}\\]\nDaarbij worden enkele zeer naïeve veronderstellingen gemaakt over het gegevensmodel op basis waarvan wij de waarschijnlijkheid \\(L(y|x_1,x_2, ...,x_p\\) bepalen. De voorspellers \\(X_1\\) zijn voorwaardelijk onafhankelijk en de waarden van de kwantitatieve voorspellers \\(X_i\\)X variëren normaal binnen elke categorie \\(Y=y\\). Deze vereenvoudigende veronderstellingen maken het naïeve Bayes-model rekenkundig efficiënt en eenvoudig toe te passen. Maar als deze vereenvoudigende veronderstellingen niet worden nageleefd (wat vaak voorkomt), kan het naïeve Bayes-model misleidende classificaties opleveren."
  },
  {
    "objectID": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#literatuur",
    "href": "posts/2022-03-26-naieve-bayesiaanse-classificatie/naeve-bayesiaanse-classificatie.html#literatuur",
    "title": "Naïeve Bayesiaanse classificatie",
    "section": "Literatuur",
    "text": "Literatuur\nGorman, Kristen B., Tony D. Williams, and William R. Fraser. 2014. “Ecological Sexual Dimorphism and Environmental Variability Within a Community of Antarctic Penguins (Genus Pygoscelis).” PLoS ONE 9(3) (e90081). hier.\nJohnson, A.A., Ott, M.Q. & Dogucu, M. (2022). *Bayes Rules! An introduction to applied Bayesian Modeling. CRC Press. hier\nHorst, Allison, Alison Hill, and Kristen Gorman. 2020. Palmerpenguins: Palmer Archipelago (Antarctica) Penguin Data. hier."
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html",
    "title": "Wat kun je met Bayes?",
    "section": "",
    "text": "Bayes Rules"
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#inleiding",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#inleiding",
    "title": "Wat kun je met Bayes?",
    "section": "Inleiding",
    "text": "Inleiding\nOnlangs verscheen een prachtig boek van Alicia A. Johnson, Miles Q. Ot en Mine Dogucu onder de titel Bayes Rules! An Introduction to Applied Bayesian Modeling en het verscheen bij CRC Press (2022). Eerdere versies kon je al via bookdown bekijken (https://www.bayesrulesbook.com/) en vanaf de eerste keer dat ik het zag, was ik hier heel enthousiast over. Het boek heb ik direct besteld en vorige week kon ik het ophalen.\nHet boek bestaat uit vier duidelijke delen. Het eerste deel gaat in op de fundamenten van het Bayesiaanse perspectief. Het leert je denken als een Bayesiaan en het gaat in op die belangrijke Bayesiaanse regel \\(posterior=\\frac{prior.likelihood}{normaliserende constante}\\). Aan de hand van enkele voorbeelden gaan Johnson e.a. in op hoe het in de praktijk werkt. Daarna gaat het in op hoe kennis en data op elkaar inwerken en laat het enkele basisanalyses zien en hoe dat in deze vorm van statistiek werkt (normaal, binair en poisson). Het tweede deel is een meer technisch hoofdstuk en laat je ook onder de moterkap van deze techniek kijken. Het gaat ook in op de wetenschappelijke principes van de benadering, waar je hier op moet letten, hoe je hiermee hypothesen kunt testen (niet alleen tov van een nulhypothese, maar hoeveel beter de ene hypothese is ten opzichte van de andere hyposthese) en hoe je hiermee ook kunt voorspellen. De twee volgende delen (Deel drie en vier) zijn praktische delen. Deel drie gaat in op regressieanalyses voor continue variabelen en classificatieanalyses voor binaire variabelen. Het vierde deel ten slotte gaat in op geclusterde datasets en hoe je hierarchische Bayesiaanse regressie en classificatieanalyses uitvoert.\nNatuurlijk, er zijn onderhand al verschillende interessante boeken te krijgen die je laten zien hoe Bayesiaanse denken in de praktijk kan werken. De boeken van Gelman, McElreath, Spiegelhalter en Kruschke verschenen de afgelopen tien/vijftien jaar en leren je dit. Maar Bayes Rules! vind ik op dit moment als introductieboek mogelijk wel het beste.\nNu het boek bij mij op het bureau ligt, kan ik er binnenkort een keer een korte recensie over schrijven. Voor nu heb ik uit elk deel een hoofdstuk genomen en het vertaald en bewerkt. Hieronder zie je een bewerking van het achtste hoofdstuk van het tweede deel (Posterior Inference & Prediction).Hoofdstukken zo overzetten is voor mij niet alleen een goede manier om het mij eigen te maken, maar ook een manier om het boek anderen aan te raden. Dus lezen en gebruiken deze Bayes Rules! An Introduction to Applied Bayesian Modeling"
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-inferentie-en-voorspelling",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-inferentie-en-voorspelling",
    "title": "Wat kun je met Bayes?",
    "section": "Posterior inferentie en voorspelling",
    "text": "Posterior inferentie en voorspelling\nStel je voor dat je in het Museum of Modern Art (MoMA) in New York City staat, gefascineerd door het kunstwerk voor je. Hoewel je begrijpt dat “moderne” kunst niet noodzakelijk “nieuwe” kunst betekent, komt er toch een vraag bij je op: wat is de kans dat deze moderne kunstenaar Gen X is of zelfs jonger, d.w.z. geboren in 1965 of later? Hier voeren we een Bayesiaanse analyse uit met als doel deze vraag te beantwoorden. Laat daartoe\n\\(\\pi\\) het aandeel zijn van de kunstenaars vertegenwoordigd in de grote Amerikaanse musea voor moderne kunst die Gen X of jonger zijn. Het Beta(4,6) prior model voor \\(\\pi\\) dat onze eigen zeer vage aanname weerspiegelt dat grote moderne kunstmusea onevenredig veel kunstenaars tonen die geboren zijn voor 1965, d.w.z, \\(\\pi\\) valt hoogstwaarschijnlijk onder 0,5. Moderne kunst” dateert immers van de jaren 1880 en het kan een tijdje duren voor men zo’n hoge erkenning in de kunstwereld bereikt.\nOm meer te weten te komen over \\(\\pi\\), zullen we \\(n\\)=100 kunstenaars uit de collectie van het MoMA nemen. Deze moma_sample dataset in het bayesrules pakket is een subset van gegevens die door het MoMA zelf beschikbaar zijn gesteld (zie MuseumofModernArt 2020-“MoMA – Collection.” GitHub Repository).\n\n# Op de pakketten (wel eerst installeren uiteraard) \nlibrary(bayesrules)\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.1.3\n\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv ggplot2 3.3.6     v purrr   0.3.4\nv tibble  3.1.7     v dplyr   1.0.9\nv tidyr   1.2.0     v stringr 1.4.1\nv readr   2.1.2     v forcats 0.5.1\n\n\nWarning: package 'ggplot2' was built under R version 4.1.3\n\n\nWarning: package 'tibble' was built under R version 4.1.3\n\n\nWarning: package 'tidyr' was built under R version 4.1.3\n\n\nWarning: package 'readr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\nWarning: package 'stringr' was built under R version 4.1.3\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\nlibrary(rstan)\n\nWarning: package 'rstan' was built under R version 4.1.3\n\n\nLoading required package: StanHeaders\n\n\nrstan (Version 2.21.5, GitRev: 2e1f913d3ca3)\n\n\nFor execution on a local, multicore CPU with excess RAM we recommend calling\noptions(mc.cores = parallel::detectCores()).\nTo avoid recompilation of unchanged Stan programs, we recommend calling\nrstan_options(auto_write = TRUE)\n\n\nDo not specify '-march=native' in 'LOCAL_CPPFLAGS' or a Makevars file\n\n\n\nAttaching package: 'rstan'\n\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n\nlibrary(bayesplot)\n\nWarning: package 'bayesplot' was built under R version 4.1.3\n\n\nThis is bayesplot version 1.9.0\n\n\n- Online documentation and vignettes at mc-stan.org/bayesplot\n\n\n- bayesplot theme set to bayesplot::theme_default()\n\n\n   * Does _not_ affect other ggplot2 plots\n\n\n   * See ?bayesplot_theme_set for details on theme setting\n\nlibrary(broom.mixed)\n\nWarning: package 'broom.mixed' was built under R version 4.1.3\n\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n#  data openen\ndata(\"moma_sample\")\n\nOnder deze groep artiesten zitten 14 Gen X of jongere artiesten (\\(Y=14\\)).\n\nmoma_sample %>% \n  group_by(genx) %>% \n  tally()\n\n# A tibble: 2 x 2\n  genx      n\n  <lgl> <int>\n1 FALSE    86\n2 TRUE     14\n\n\n\\(Y|\\pi\\) kun je het beste opvatten en dat betekent dat onze analyse het bèta-binomiale kader volgt. On aangepast posterior model van \\(\\p\\) in het licht van de waargenomen kunstgegevens ziet er als volgt uit:\n\\[Y|\\pi \\sim Bin(100,\\pi) \\\\\n  \\pi\\sim Beta(4,6)\\] wordt \\[\\pi|Y=14) \\sim Beta(18,92)\\]\nmet de corresponderende posterior pdf \\[f(\\pi|y=14)=\\frac{\\Gamma(18+92)}{\\Gamma(18)\\Gamma(92)}\\pi^{18-1}(1-\\pi)^{92-1} for \\pi \\epsilon[0,1].\\]\nDe evolutie in ons begrip van \\(\\pi\\) is hieronder te zien. Terwijl we begonnen met een vaag begrip dat minder dan de helft van de tentoongestelde kunstenaars Gen X zijn, hebben de gegevens ons met enige zekerheid doen stellen dat dit cijfer waarschijnlijk onder 25% ligt.\n\nplot_beta_binomial(alpha = 4, beta = 6, y = 14, n = 100)\n\n\n\n\nNadat we succesvol de posterior hebben geconstrueerd, besefen we ons dat er nog veel werk voor ons ligt. We moeten deze posterior kunnen gebruiken om een rigoureuze posterior analyse uit te voeren. Er zijn drie algemene taken in posterior analyse: schatting, hypothesetest, en voorspelling. Bijvoorbeeld, wat is onze preciese schatting van \\(\\pi\\)? Ondersteunt ons model de bewering dat minder dan 20% van de museumkunstenaars Gen X of jonger zijn? Als we 20 extra museumkunstenaars zouden nemen, hoeveel voorspellen we dan dat Gen X of jonger zullen zijn? Laat je gevoel eens spreken, wat denk je:\na. Ongeveer 16% van de museum kunstenaars zijn Gen X of jonger.\nb. Het is zeer waarschijnlijk dat ongeveer 16% van de museumkunstenaars Gen X of jonger is, maar dat cijfer zou ook tussen 9% en 26% kunnen liggen.\nAls je antwoordde met antwoord b, is je denkwijze Bayesiaans van geest.\n[Figuur: Ons Beta(18, 92) posterior model voor \\(π\\) (links) naast een alternatief Beta(4, 16) posterior model (rechts). De gekleurde gebieden geven de overeenkomstige 95% posterior geloofwaardigheids intervallen weer voor ]\nDe clou hier is dat posterieure schattingen zowel de centrale tendens als de variabiliteit in \\(\\pi\\). Het posterior gemiddelde en de modus van \\(\\pi\\) geven een snel overzicht van enkel de centrale tendens. Deze kenmerken voor onze Beta(18, 92) posterior volgen uit de algemene Beta-eigenschappen komen overeen met onze bovenstaande observatie dat de Gen X vertegenwoordiging hoogstwaarschijnlijk rond 16% ligt:\n\\[E(\\pi|Y=14)=\\frac{18}{18+92} \\approx 0.164 \\\\\nMode(\\pi|Y=14)=\\frac{18-1}{18+92-2} \\approx 0.157\\]"
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-schatting",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-schatting",
    "title": "Wat kun je met Bayes?",
    "section": "Posterior schatting",
    "text": "Posterior schatting\nLaten we eens opnieuw kijken naar het Beta(18, 92) posterior model voor \\(\\pi\\), het percentage moderne kunst museumkunstenaars dat Gen X of jonger is (zie figuur hierboven). In een Bayesiaanse analyse kunnen we dit hele posterior model zien als een schatting van \\(\\pi\\). Immers, dit model van posterior plausibele waarden geeft een compleet beeld van de centrale tendens en onzekerheid in \\(\\pi\\). Maar bij het specificeren en communiceren van ons posterior begrip is het ook nuttig om eenvoudige posterior samenvattingen te berekenen van \\(\\pi\\).\nBeter is het nog, om zowel de centrale tendens als de variabiliteit in \\(\\pi\\) te kunnen rapporteren als een reeks van aannemelijke posterior aannemelijke \\(\\pi\\) waarden. Dit bereik wordt een posterior geloofwaardigheids interval (CI, Credible Interval) genoemd voor \\(\\pi\\). We hebben bijvoorbeeld eerder opgemerkt dat het aandeel museumkunstenaars dat Gen X of jonger is, hoogstwaarschijnlijk tussen 10% en 24% ligt. Dit bereik vangt de meer plausibele waarden van \\(\\pi\\) terwijl de meer extreme en onwaarschijnlijke scenario’s worden geëlimineerd. In feite zijn 0,1 en 0,24 de 2,5e en 97,5e posterior percentielen (d.w.z. 0,025ste en 0,975ste posterior kwantielen). Dit zijn is het middelste deel, 95% CI van de posterior geloofwaardige \\(\\pi\\)waarden. We kunnen deze Beta(18,92) posterior quantiel berekeningen bevestigen met qbeta():\n\n# 0.025-0.975 interval van de Beta(18,92) posterior\nqbeta(c(0.025, 0.975), 18, 92)\n\n[1] 0.1009084 0.2379286\n\n\nHet resulterende 95% geloofwaardigheidsinterval voor \\(\\pi\\), (0,1, 0,24), wordt weergegeven door het gekleurde gebied in de figuur hierboven (links). Terwijl het gebied onder de gehele posterior pdf 1 is, is het gebied van dit gekleurde gebied 0,95, dus de fractie van \\(\\pi\\)waarden die in dit gebied vallen. Dit onthult een intuïtieve interpretatie van de CI. Er is een 95% posterior waarschijnlijkheid dat ergens tussen 10% en 24% van de museumkunstenaars Gen X of jonger zijn:\n\\[P(\\pi\\epsilon(0.1,0.24)|Y=14)=\\int_{0.1}^{0.24}f(\\pi|y=14)d\\pi=0.95\\]\nSta hier alstublieft even stil. Voelt deze interpretatie natuurlijk en intuïtief aan? Dus, een beetje anticlimactisch? Als dat zo is, zijn we blij dat je er zo over denkt - het betekent dat je denkt als een Bayesiaan.\nBij de constructie van de CI hierboven hebben we een “middelste 95%” benadering gebruikt. Dit is niet onze enige optie. De eerste aanpassing die we kunnen doen is het geloofwaardige niveau van 95% (zie figuur hieronder). Bijvoorbeeld, een middelste 50% CI, van het 25ste tot het 75ste percentiel, zou onze aandacht vestigen op een kleiner bereik van enkele van de meer plausibele \\(\\pi\\) waarden. Er is een 50% posterior waarschijnlijkheid dat ergens ligt tussen 14% en 19% van de museumkunstenaars Gen X of jonger zijn:\n\n# 0.25-0.75 interval van de Beta(18,92) posterior\nqbeta(c(0.25, 0.75), 18, 92)\n\n[1] 0.1388414 0.1862197\n\n\nIn de andere richting zou een bredere 99%-controlegrens van 0,5 tot 99,5 percentiel lopen. In dat geval wordt alleen de extreme 1% uitgeslopten. Als zodanig zou een 99% CI ons een vollediger beeld geven van plausibele en in sommige gevallen zeer onwaarschijnlijke \\(\\pi\\)waarden:\n\n# 0.005-0.995 interval van de Beta(18,92) posterior\nqbeta(c(0.005, 0.995), 18, 92)\n\n[1] 0.08530422 0.26468037\n\n\nHoewel een 95%-niveau een gebruikelijke keuze is, is het enigszins arbitrair en gewoon ingebakken door decennia van traditie. Er is niet één “juist” geloofwaardigheidsniveau. Je kunt net zo makkelijk 50%, 80% of 95% niveaus gebruiken, afhankelijk van de context van de analyse. Elk geeft een ander posterior begrip."
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-hypothese-testing",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-hypothese-testing",
    "title": "Wat kun je met Bayes?",
    "section": "Posterior hypothese testing",
    "text": "Posterior hypothese testing\n\nEenzijdige tests\nHet testen van hypothesen is een andere veel voorkomende taak bij posterior analyse. Bijvoorbeeld, stel dat we een artikel lezen waarin wordt beweerd dat minder dan 20% van de museumkunstenaars Gen X of jonger zijn. Twee aanwijzingen die we hebben waargenomen uit ons posterior model van \\(\\pi\\) wijzen erop dat deze bewering op zijn minst voor een deel plausibel is:\n\nHet grootste deel van de posterior pdf in figuur hieronder valt onder 0.2.\n\nHet 95% CI voor \\(\\pi\\) (0.1, 0.24) zit vooral onder 0.2.\n\nDeze waarnemingen zijn een goed begin. Maar we kunnen nog preciezer zijn. Om precies te evalueren hoe aannemelijk het is dat \\(\\pi<0.2\\), kunnen we de posterior waarschijnlijkheid van dit scenario berekenen, $P(<0.2|Y=14). Deze posterior waarschijnlijkheid wordt weergegeven door het gearceerde gebied onder de posterior pdf in xxxxx. Het wordt wiskundig berekend door de posterior pdf te integreren in het gebied van 0 tot 0,2:\n\\[P(\\pi<0.2|Y=14)=\\int_{0}^{0.2}f(\\pi|y=14)d\\pi\\] We zullen de integratie omzeilen en deze Beta(18,92) posterior waarschijnlijkheid verkrijgen met pbeta() hieronder. Het resultaat toont een sterk bewijs ten gunste van onze bewering: er is ongeveer 84,9% posterior kans dat Gen X-ers minder dan 20% van de moderne kunst museumkunstenaars uitmaken.\n\n# Posterior waarschijnlijkheid dat pi < 0.20\npost_prob <- pbeta(0.20, 18, 92)\npost_prob\n\n[1] 0.8489856\n\n\nDe analyse van onze bewering is verfrissend eenvoudig. Wij hebben eenvoudigweg de posterior waarschijnlijkheid van het scenario van belang berekend. Hoewel dit niet altijd nodig is, formaliseren mensen uit de praktijk deze procedure vaak in een raamwerk voor het testen van hypothesen. Wij kunnen onze analyse bijvoorbeeld omkaderen met twee concurrerende hypothesen: de nulhypothese \\(H_0\\) stelt dat minstens 20% van de museumkunstenaars Gen X of jonger zijn (de status quo hier), terwijl de alternatieve hypothese \\(H_{\\alpha}\\) (onze bewering) stelt dat dit cijfer lager is dan 20%. In wiskundige notatie:\n$$H_0: \\\nH_{}:< 0.2$$ Merk op dat \\(H_{\\alpha}\\) beweert dat \\(\\pi\\) aan één kant van 0,2 ligt (\\(\\pi<0.2\\)) in tegenstelling tot gewoon verschillend zijn dan 0.2 (\\(\\pi\\ne0.2\\)). We noemen dit dus een eenzijdige hypothesetoets. We hebben de posterior waarschijnlijkheid van de alternatieve hypothese al berekend als \\(P(H_{\\alpha}|Y=14=0.849\\). De posterieure waarschijnlijkheid van de nulhypothese is dus \\(P(H_0|Y=14)=0.151\\). Samengenomen is de posterior odds dat \\(\\pi<0.2\\) ruwweg 5,62 zijn. Dat wil zeggen, onze posterieure beoordeling is dat \\(\\pi\\) bijna 6 keer meer kans heeft om onder 0,2 te liggen dan om boven 0,2 te liggen:\n\\[posterior odds=\\frac{P(H_{alpha}|Y=14)}{P(H_0|Y=14)}\\approx5.62\\]\n\n# Posterior odds\npost_odds <- post_prob / (1 - post_prob)\npost_odds\n\n[1] 5.621883\n\n\n\n# Prior probability that pi < 0.2\nprior_prob <- pbeta(0.20, 4, 6)\nprior_prob\n\n[1] 0.08564173\n\n\n\n# Prior odds\nprior_odds <- prior_prob / (1 - prior_prob)\nprior_odds\n\n[1] 0.09366321\n\n\n\n# Bayes factor\nBF <- post_odds / prior_odds\nBF\n\n[1] 60.02232\n\n\n\n\nTweezijdige tests"
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-voorspelling",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-voorspelling",
    "title": "Wat kun je met Bayes?",
    "section": "Posterior voorspelling",
    "text": "Posterior voorspelling"
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-analyse-met-mcmc",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#posterior-analyse-met-mcmc",
    "title": "Wat kun je met Bayes?",
    "section": "Posterior analyse met MCMC",
    "text": "Posterior analyse met MCMC\nHet is goed te weten dat er enige theorie achter Bayesiaanse posterior analyse zit. En wanneer we werken met modellen die zo eenvoudig zijn als de Beta-Binomiaal, kunnen we deze theorie direct implementeren - dat wil zeggen, we kunnen exacte posterior geloofwaardige intervallen, waarschijnlijkheden, en voorspellende modellen berekenen. Maar het is duidelijk dat dit mooie terrein ook betreden kan worden bij scenario’s waarin we geen posterior modellen kunnen specificeren, laat staan exacte samenvattingen van hun eigenschappen kunnen berekenen. In deze scenario’s kunnen we posteriores benaderen met behulp van MCMC methoden. Laten we nu eens onderzoeken hoe we dit soort Markov chain steekproefwaarden ook kunnen worden gebruikt om specifieke posterior kenmerken te benaderen. Laten we eens zien hoe we dit soort methodes kunnen gebruiken om posterior analyses uit te voeren.\nHieronder worden vier parallelle Markovketens uitgevoerd van \\(\\pi\\) voor 10.000 iteraties elk. Na het weggooien van de eerste 5.000 iteraties van elke keten, houden we nog vier afzonderlijke Markovketens van 5.000 over, {\\({\\pi^{1}, \\pi^{(2)}, ..., \\pi^{(5000)}}\\)}, of een gecombineerde Markov-keten steekproefgrootte van 20.000.\n\nPosterior simulatie\n\n# STAP 1: DEFINEER HET model\nart_model <- \"\n  data {\n    int<lower = 0, upper = 100> Y;\n  }\n  parameters {\n    real<lower = 0, upper = 1> pi;\n  }\n  model {\n    Y ~ binomial(100, pi);\n    pi ~ beta(4, 6);\n  }\n\"\n\n# STAP 2: SIMULEER DE POSTERIOR\nart_sim <- stan(model_code = art_model, data = list(Y = 14), \n                chains = 4, iter = 5000*2, seed = 84735)\n\n\nSAMPLING FOR MODEL '55ec3099e16ca06fa44f4c9f6d6ebcf4' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 10000 [  0%]  (Warmup)\nChain 1: Iteration: 1000 / 10000 [ 10%]  (Warmup)\nChain 1: Iteration: 2000 / 10000 [ 20%]  (Warmup)\nChain 1: Iteration: 3000 / 10000 [ 30%]  (Warmup)\nChain 1: Iteration: 4000 / 10000 [ 40%]  (Warmup)\nChain 1: Iteration: 5000 / 10000 [ 50%]  (Warmup)\nChain 1: Iteration: 5001 / 10000 [ 50%]  (Sampling)\nChain 1: Iteration: 6000 / 10000 [ 60%]  (Sampling)\nChain 1: Iteration: 7000 / 10000 [ 70%]  (Sampling)\nChain 1: Iteration: 8000 / 10000 [ 80%]  (Sampling)\nChain 1: Iteration: 9000 / 10000 [ 90%]  (Sampling)\nChain 1: Iteration: 10000 / 10000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 0.035 seconds (Warm-up)\nChain 1:                0.043 seconds (Sampling)\nChain 1:                0.078 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL '55ec3099e16ca06fa44f4c9f6d6ebcf4' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 10000 [  0%]  (Warmup)\nChain 2: Iteration: 1000 / 10000 [ 10%]  (Warmup)\nChain 2: Iteration: 2000 / 10000 [ 20%]  (Warmup)\nChain 2: Iteration: 3000 / 10000 [ 30%]  (Warmup)\nChain 2: Iteration: 4000 / 10000 [ 40%]  (Warmup)\nChain 2: Iteration: 5000 / 10000 [ 50%]  (Warmup)\nChain 2: Iteration: 5001 / 10000 [ 50%]  (Sampling)\nChain 2: Iteration: 6000 / 10000 [ 60%]  (Sampling)\nChain 2: Iteration: 7000 / 10000 [ 70%]  (Sampling)\nChain 2: Iteration: 8000 / 10000 [ 80%]  (Sampling)\nChain 2: Iteration: 9000 / 10000 [ 90%]  (Sampling)\nChain 2: Iteration: 10000 / 10000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 0.035 seconds (Warm-up)\nChain 2:                0.045 seconds (Sampling)\nChain 2:                0.08 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL '55ec3099e16ca06fa44f4c9f6d6ebcf4' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 10000 [  0%]  (Warmup)\nChain 3: Iteration: 1000 / 10000 [ 10%]  (Warmup)\nChain 3: Iteration: 2000 / 10000 [ 20%]  (Warmup)\nChain 3: Iteration: 3000 / 10000 [ 30%]  (Warmup)\nChain 3: Iteration: 4000 / 10000 [ 40%]  (Warmup)\nChain 3: Iteration: 5000 / 10000 [ 50%]  (Warmup)\nChain 3: Iteration: 5001 / 10000 [ 50%]  (Sampling)\nChain 3: Iteration: 6000 / 10000 [ 60%]  (Sampling)\nChain 3: Iteration: 7000 / 10000 [ 70%]  (Sampling)\nChain 3: Iteration: 8000 / 10000 [ 80%]  (Sampling)\nChain 3: Iteration: 9000 / 10000 [ 90%]  (Sampling)\nChain 3: Iteration: 10000 / 10000 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 0.035 seconds (Warm-up)\nChain 3:                0.041 seconds (Sampling)\nChain 3:                0.076 seconds (Total)\nChain 3: \n\nSAMPLING FOR MODEL '55ec3099e16ca06fa44f4c9f6d6ebcf4' NOW (CHAIN 4).\nChain 4: \nChain 4: Gradient evaluation took 0 seconds\nChain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 4: Adjust your expectations accordingly!\nChain 4: \nChain 4: \nChain 4: Iteration:    1 / 10000 [  0%]  (Warmup)\nChain 4: Iteration: 1000 / 10000 [ 10%]  (Warmup)\nChain 4: Iteration: 2000 / 10000 [ 20%]  (Warmup)\nChain 4: Iteration: 3000 / 10000 [ 30%]  (Warmup)\nChain 4: Iteration: 4000 / 10000 [ 40%]  (Warmup)\nChain 4: Iteration: 5000 / 10000 [ 50%]  (Warmup)\nChain 4: Iteration: 5001 / 10000 [ 50%]  (Sampling)\nChain 4: Iteration: 6000 / 10000 [ 60%]  (Sampling)\nChain 4: Iteration: 7000 / 10000 [ 70%]  (Sampling)\nChain 4: Iteration: 8000 / 10000 [ 80%]  (Sampling)\nChain 4: Iteration: 9000 / 10000 [ 90%]  (Sampling)\nChain 4: Iteration: 10000 / 10000 [100%]  (Sampling)\nChain 4: \nChain 4:  Elapsed Time: 0.042 seconds (Warm-up)\nChain 4:                0.028 seconds (Sampling)\nChain 4:                0.07 seconds (Total)\nChain 4: \n\n\nBekijk de numerieke en visuele diagnostiek in de figuur hieronder eens. Ten eerste duiden de willekeurigheid in de sporenplots (links), de overeenstemming in de dichtheidplots van de vier parallelle ketens (midden) en een Rhat-waarde van effectief 1 erop dat onze simulatie uiterst stabiel is. Verder gedragen onze afhankelijke ketens zich elk “genoeg” als een onafhankelijk sample. De autocorrelatie, rechts weergegeven voor slechts één keten, neemt snel af en de verhouding van de effectieve steekproefgrootte is bevredigend hoog - onze 20.000 Markov-ketenwaarden zijn even effectief als 7600 onafhankelijke steekproeven (0,38 ⋅ 20000).\n\n# Parallelle spoor(trace) plotten & density plotten\nmcmc_trace(art_sim, pars = \"pi\", size = 0.5) + \n  xlab(\"iteration\")\n\n\n\nmcmc_dens_overlay(art_sim, pars = \"pi\")\n\n\n\n# Autocorrelatie plot\nmcmc_acf(art_sim, pars = \"pi\")\n\n\n\n\n\n# MC diagnostiek\nrhat(art_sim, pars = \"pi\")\n\n[1] 1.000508\n\nneff_ratio(art_sim, pars = \"pi\")\n\n[1] 0.4032414\n\n\n\n\nPosterior schatting en hypothese testen\nWe kunnen nu de gecombineerde 20.000 Markovketenwaarden gebruiken, met vertrouwen, om het Beta(18, 92) posterior model te benaderen van \\(\\pi\\). Het figuur hieronder bevestigt inderdaad dat de volledige MCMC-benadering (rechts) de werkelijke posterior (links) dicht benadert.\n\n# De actuele Beta(18, 92) posterior\nplot_beta(alpha = 18, beta = 92) + \n  lims(x = c(0, 0.35))\n\n\n\n# MCMC posterior benadering\nmcmc_dens(art_sim, pars = \"pi\") + \n  lims(x = c(0,0.35))\n\nScale for 'x' is already present. Adding another scale for 'x', which will\nreplace the existing scale.\n\n\n\n\n\nAls zodanig kunnen wij elk kenmerk van het Beta(18, 92) posterior model benaderen door het overeenkomstige kenmerk van de Markov-keten. Wij kunnen bijvoorbeeld het posterieure gemiddelde benaderen door het gemiddelde van de MCMC-steekproefwaarden, of het 2,5-percentiel posterior benaderen door het 2,5-percentiel van de MCMC-steekproefwaarden. Hiertoe levert de tidy() functie in het broom.mixed pakket (Bolker en Robinson 2021. Broom.mixed: Tidying Methods for Mixed Models)[https://github.com/bbolker/broom.mixed] een aantal handige statistieken voor de gecombineerde 20.000 Markov chain waarden die zijn opgeslagen in art_sim:\n\ntidy(art_sim, conf.int = TRUE, conf.level = 0.95)\n\n# A tibble: 1 x 5\n  term  estimate std.error conf.low conf.high\n  <chr>    <dbl>     <dbl>    <dbl>     <dbl>\n1 pi       0.161    0.0352    0.100     0.239\n\n\nEn de mcmc_areas()-functie in het bayesplot-pakket biedt een visuele aanvulling (zie de figuur hieronder)\n\n# Kleur in het midden het 95% interval\nmcmc_areas(art_sim, pars = \"pi\", prob = 0.95)\n\n\n\n\nIn de tidy() samenvatting geven conf.low en conf.high de 2,5e en 97,5e percentielen van de Markov-ketenwaarden aan, respectievelijk 0,101 en 0,239. Deze vormen bij benadering het midden 95%- geloofwaardigheidsinterval voor \\(\\pi\\) dat wordt weergegeven door het gearceerde gebied in de mcmc_areas()-plot. Verder meldt de schatting dat de mediaan van onze 20.000 Markov chain-waarden, en dus onze benadering van de werkelijke posterieure mediaan, 0,162 is. Deze mediaan wordt weergegeven door de verticale lijn in de mcmc_areas()-plot. Net als het gemiddelde en de modus geeft de mediaan een andere maat voor een “typische” posterior \\(\\pi\\) waarde. Hij komt overeen met het 50ste posterior percentiel - 50% van posterior \\(\\pi\\) waarden liggen boven de mediaan en 50% liggen eronder. Maar in tegenstelling tot het gemiddelde en de modus, bestaat er geen eenduidige formule voor een Beta(\\(\\alpha, \\beta\\))-mediaan. Dit legt nog meer moois bloot van MCMC simulatie: zelfs als een formule ongrijpbaar is, kunnen we een posterior eenheid schatten door de overeenkomstige eigenschap van onze waargenomen Markov chain steekproefwaarden.\nHoewel het een mooie eerste stop is, geeft de tidy() functie niet altijd elke samenvattende statistiek die van belang is. Hij rapporteert bijvoorbeeld niet het gemiddelde of de modus van onze Markov chain steekproefwaarden. Geen probleem. We kunnen samenvattende statistieken rechtstreeks uit de Markov chain waarden berekenen. De eerste stap is het omzetten van een matrix van de vier parallelle ketens in een enkel dataframe van de gecombineerde ketens:\n\n# Sla de 4 kettingen op in 1 data frame\nart_chains_df <- as.data.frame(art_sim, pars = \"lp__\", include = FALSE)\ndim(art_chains_df)\n\n[1] 20000     1\n\n\nMet de ketens in dataframe-vorm kunnen wij op de gebruikelijke manier te werk gaan en onze dplyr gereedschappen gebruiken om een en ander te transformeren en samen te vatten. Wij kunnen bijvoorbeeld direct het steekproefgemiddelde, de mediaan, de modus en de kwantielen van de gecombineerde Markov-ketenwaarden berekenen. De mediaan- en kwantielwaarden zijn precies die welke door tidy() hierboven worden gerapporteerd, en elimineren dus elk mysterie over die functie!\n\n# Bereken de posterior samenvattingen van pi\nart_chains_df %>% \n  summarize(post_mean = mean(pi), \n            post_median = median(pi),\n            post_mode = sample_mode(pi),\n            lower_95 = quantile(pi, 0.025),\n            upper_95 = quantile(pi, 0.975))\n\n  post_mean post_median post_mode  lower_95  upper_95\n1 0.1635785   0.1614223 0.1549176 0.1004316 0.2389237\n\n\nWij kunnen de ruwe kettingwaarden ook gebruiken om de volgende taak in onze posterior analyse aan te pakken - het testen van de bewering dat minder dan 20% van de grote museumkunstenaars Gen X zijn. Daartoe kunnen wij de posterior waarschijnlijkheid van dit scenario benaderen, \\(P(\\pi<0.20|Y=14)\\), door het aandeel Markovketen \\(\\pi\\)πwaarden die onder 0,20 vallen. Volgens deze benadering is er een kans van 84,6% dat de vertegenwoordiging van Gen X-artiesten onder 0,20 ligt:\n\n# Zet de pi waarden in een tabel die onder de 0.20 zitten\nart_chains_df %>% \n  mutate(exceeds = pi < 0.20) %>% \n  tabyl(exceeds)\n\n exceeds     n percent\n   FALSE  3043 0.15215\n    TRUE 16957 0.84785\n\n\nLaat het op je inwerken en onthoud het punt. We hebben onze MCMC simulatie gebruikt om het posterior model van \\(\\pi\\) te benaderen samen met de eigenschappen van belang. Ter vergelijking, de tabel hieronder toont de Beta(18,92) posterior kenmerken die we eerder hebben berekend naast hun overeenkomstige MCMC-benaderingen. De clou is dit: MCMC werkte. De benaderingen zijn vrij nauwkeurig. Laat dit u geruststellen - ook als modellen te ingewikkeld zijn om te specificeren, kunnen we vertrouwen hebben in onze MCMC-benaderingen van deze modellen (zolang de diagnostiek maar klopt!).\n\n\n\n\ngemiddelde\nmodus\n2.5\n97.5\n\n\n\n\nposterior\n0.16\n0.16\n0.1\n0.24\n\n\nMCMC\n0.1642\n0.1598\n0.1011\n0.2388\n\n\n\n\n\nPosterior voorspelling\nTenslotte kunnen wij onze Markov-ketenwaarden gebruiken om het posterior voorspellingsmodel van \\(Y^{'}\\) het aantal van de volgende 20 artiesten uit de steekproef dat Gen X of jonger zal zijn. Bonus: het simuleren van dit model helpt ons ook intuïtie op te bouwen voor de theorie die ten grondslag ligt aan de posterior voorspelling. Herinner je dat het posterior voorspellingsmodel twee bronnen van variabiliteit weerspiegelt:\n\nSteekproefvariabiliteit in de gegevens\n\\(Y^{'}\\) kan een willekeurig aantal kunstenaars in {0,1,…,20} en hangt af van het onderliggende aandeel van kunstenaars die Gen X zijn, \\(\\pi:Y^{'}|\\pi\\sim Bin(20,\\pi)\\).\n\nPosterieure variabiliteit in \\(\\pi\\)π De verzameling van 20.000 Markovketens \\(\\pi\\) waarden geeft bij benadering een idee van de variabiliteit en het bereik in plausibele \\(\\pi\\)waarden.\n\nOm beide bronnen van variabiliteit in posterieure voorspellingen te vatten \\(Y^{'}\\) kunnen we rbinom() gebruiken om één \\(Bin(20,\\pi\\) uitkomst \\(Y^{'}\\) van elk van de 20.000\\(\\pi\\) ketenwaarden. De eerste drie resultaten weerspiegelen een algemene trend: kleinere waarden van \\(\\pi\\) zullen meestal kleinere waarden van \\(Y^{'}\\) geven. Dit is logisch. Hoe lager de onderliggende vertegenwoordiging van Gen X-kunstenaars in het museum, hoe minder Gen X-kunstenaars we mogen verwachten in onze volgende steekproef van 20 kunstwerken.\n\n# Vastzetten zodat het dezelfde waarden blijft geven \nset.seed(1)\n\n# Voorspel een waarde van Y' voor elke pi waarde in de ketting\nart_chains_df <- art_chains_df %>% \n  mutate(y_predict = rbinom(length(pi), size = 20, prob = pi))\n\n# Check het vervolgens\nart_chains_df %>% \n  head(3)\n\n         pi y_predict\n1 0.1300704         2\n2 0.1755149         3\n3 0.2214144         5\n\n\n\n# Plot de 20,000 voorspellingen\nggplot(art_chains_df, aes(x = y_predict)) + \n  stat_count()\n\n\n\n\n\nart_chains_df %>% \n  summarize(mean = mean(y_predict),\n            lower_80 = quantile(y_predict, 0.1),\n            upper_80 = quantile(y_predict, 0.9))\n\n   mean lower_80 upper_80\n1 3.274        1        6"
  },
  {
    "objectID": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#bayesiaanse-voordelen",
    "href": "posts/2022-03-29-wat-kun-je-met-bayes/wat-kun-je-met-bayes.html#bayesiaanse-voordelen",
    "title": "Wat kun je met Bayes?",
    "section": "Bayesiaanse voordelen",
    "text": "Bayesiaanse voordelen\nZoals je waarschijnlijk merkte, is het moeilijkste deel van een Bayesiaanse analyse vaak het bouwen of simuleren van het posterior model. Zodra je dat stuk op zijn plaats hebt, is het vrij eenvoudig om deze posterior te gebruiken voor schatting, hypothese toetsing en voorspelling. Daarentegen is het opbouwen van de formules om de analoge frequentistische berekeningen uit te voeren vaak minder intuïtief.\nWe kunnen ons ook koesteren in het gemak waarmee Bayesiaanse resultaten kunnen worden geïnterpreteerd. In het algemeen beoordeelt een Bayesiaanse analyse de onzekerheid over een onbekende parameter \\(\\pi\\) in het licht van de waargenomen gegevens \\(Y\\). Neem bijvoorbeeld de studie van de kunstenaars zoals hierboven gepresenteerd. In het licht van de waarneming dat \\(Y=14\\) van de 100 kunstenaars in de steekproef Gen X of jonger waren, stelden we vast dat er een 84,9% posterior kans was dat Gen X vertegenwoordigd was in het hele museum,\n\\(π\\) lager is dan 0,20:\n\\[P(\\pi<0.20|Y=14)=0.849\\]\nDeze berekening heeft geen zin in een frequentistische analyse. Omgekeerd beoordeelt een frequentistische analyse de onzekerheid van de waargenomen gegevens \\(Y\\) in het licht van veronderstelde waarden van \\(π\\). De frequentistische tegenhanger van de Bayesiaanse posterior waarschijnlijkheid hierboven is bijvoorbeeld de p-waarde, waarvan we de formule hier niet zullen behandelen:\n\\[PY(\\leq14|\\pi=0.20)=0.08\\] De omgekeerde volgorde van de conditionering in deze waarschijnlijkheid, \\(Y\\) gegeven \\(π\\) (\\(Y|\\pi\\)) in plaats van \\(π\\) gegeven \\(Y\\) (\\(\\pi|Y)\\)) leidt tot een andere berekening en interpretatie dan de Bayesiaanse waarschijnlijkheid: als \\(π\\) slechts 0,20 zou zijn, dan is er slechts een kans van 8% dat we een steekproef zouden hebben waargenomen waarin ten hoogste \\(Y=14\\) van de 100 kunstenaars Gen X waren. Het is niet onze manier van schrijven die onhandig is, het is de p-waarde. Hoewel het ons interessante informatie verschaft, is de vraag die het beantwoordt een beetje minder natuurlijk voor het menselijk brein: aangezien we de gegevens eigenlijk hebben geobserveerd, maar \\(\\pi\\) niet weten, kan het een breinbreker zijn om een berekening te interpreteren die het tegendeel veronderstelt. Voornamelijk bij het testen van hypothesen is het natuurlijker om te vragen “hoe waarschijnlijk is mijn hypothese?” (wat de Bayesiaanse waarschijnlijkheid antwoordt) dan “hoe waarschijnlijk zijn mijn data als mijn hypothese niet waar zou zijn?” (wat de frequentistische waarschijnlijkheid antwoordt). Aangezien p-waarden zo vaak verkeerd worden geïnterpreteerd, en dus verkeerd worden gebruikt, worden zij in het hele frequentistische en Bayesiaanse spectrum steeds minder benadrukt.\nDeze blog leert je hoe je een posterior model in antwoorden kunt omzetten. Dat wil zeggen dat je gebruik maakte van posterior modellen, exact of bij benadering, om drie posterior analyse taken uit te voeren voor een onbekende parameter \\(\\pi\\):\n\nPosterior schatting\nEen posterior geloofwaardigheidsinterval (CI) geeft een reeks van posterior aannemelijke waarden van \\(\\pi\\) en dus een idee van zowel de posterior typische waarden als de onzekerheid in \\(\\pi\\).\n\nPosterior toetsing van hypothesen Posterior waarschijnlijkheden geven inzicht in overeenkomstige hypothesen betreffende \\(\\pi\\).\n\nPosterior voorspelling\nHet posterior voorspellingsmodel voor een nieuw gegevenspunt \\(Y\\) houdt rekening met zowel de steekproefvariabiliteit in \\(Y\\) en de posterior variabiliteit in \\(\\pi\\)."
  },
  {
    "objectID": "posts/2022-05-05-kaarten-maken-met-r/kaarten-maken-met-r.html#inleiding",
    "href": "posts/2022-05-05-kaarten-maken-met-r/kaarten-maken-met-r.html#inleiding",
    "title": "Kaarten maken met R",
    "section": "Inleiding",
    "text": "Inleiding\nHieronder een korte handleidingen die je leert om met R kaarten te maken. Euginio Petrovich schreef: Drawing maps with R. A basic tutorial in 2020. Hij laat je zien hoe je een kaart van Europa maakt met vooral de pakketten sfen `ggplot, hoe je geografische data combineert met een eenvoudige dataset en hoe je vervolgens deze kaart met deze gegevens verfijnt.Inderdaad een basishandleiding. Dank je Euginio."
  },
  {
    "objectID": "posts/2022-05-05-kaarten-maken-met-r/kaarten-maken-met-r.html#met-r-kaarten-tekenen.-een-basishandleiding",
    "href": "posts/2022-05-05-kaarten-maken-met-r/kaarten-maken-met-r.html#met-r-kaarten-tekenen.-een-basishandleiding",
    "title": "Kaarten maken met R",
    "section": "Met R kaarten tekenen. Een basishandleiding",
    "text": "Met R kaarten tekenen. Een basishandleiding\nMet kaarten kun je op een krachtige wijze informatie visualiseren. Het plotten van gegevens op een kaart kan trends en patronen aan het licht brengen die moeilijk te zien zijn door alleen een spreadsheet te onderzoeken. Kaarten zijn ook zeer nuttig om informatie op een aantrekkelijke en makkelijkere manier over te brengen aan het publiek.\nIn deze korte handleiding leren we hoe we eenvoudige geografische kaarten kunnen genereren met R. In het bijzonder zullen we leren hoe we de volgende kaart van de DR2 leden in Europa kunnen maken:\n\nAan de slag\nR is een gratis en open-source software die vele oplossingen biedt voor het berekenen van gegevens en het produceren van visualisaties. Een groot voordeel van R is dat de basisfunctionaliteiten kunnen worden uitgebreid met andere pakketten die vrij beschikbaar zijn op CRAN, het Comprehensive R Archive Network. Bovendien is er een actieve R-gemeenschap over de hele wereld die de meeste codeervragen beantwoordt die je kunt hebben.\nDe pakketten die nodig zijn voor deze handleiding kunnen worden geïnstalleerd met:\n\n# install.packages(c(\"sf\", \"rnaturalearth\" , \"rnaturalearthdata\", \"rgeos\", \"ggspatial\", \"ggrepel\", \"tidyverse\"))\n\n# Ik heb een hekje geplaatst omdat ik deze pakketten al had binnengehaald. Heb je dat nog niet gedaan, dan moet je het hekje weghalen.\n\nDe eerste vijf pakketten zijn specifiek ontwikkeld voor kaarten: sf wordt gebruikt om ruimtelijke gegevens te beheren, rnaturalearth en rnaturalearthdata bevatten informatie over alle landen van de wereld, alsook informatie die nodig is om die landen op een kaart uit te zetten, en ggspatial verbetert de visualisatie van ruimtelijke gegevens. ggrepel helpt ons bij het beheer van de labels op de kaart, terwijl tidyverse een set R-bibliotheken omvat die de standaard zijn geworden voor gegevensmanipulatie en -visualisatie.\nNa de installatie van de pakketten, moeten we ze laden:\n\nlibrary(\"sf\")\n\nWarning: package 'sf' was built under R version 4.1.3\n\n\nLinking to GEOS 3.9.1, GDAL 3.2.1, PROJ 7.2.1; sf_use_s2() is TRUE\n\nlibrary(\"rnaturalearth\")\n\nWarning: package 'rnaturalearth' was built under R version 4.1.3\n\nlibrary(\"rnaturalearthdata\")\n\nWarning: package 'rnaturalearthdata' was built under R version 4.1.3\n\nlibrary(\"rgeos\")\n\nWarning: package 'rgeos' was built under R version 4.1.3\n\n\nLoading required package: sp\n\n\nWarning: package 'sp' was built under R version 4.1.3\n\n\nrgeos version: 0.5-9, (SVN revision 684)\n GEOS runtime version: 3.9.1-CAPI-1.14.2 \n Please note that rgeos will be retired by the end of 2023,\nplan transition to sf functions using GEOS at your earliest convenience.\n GEOS using OverlayNG\n Linking to sp version: 1.4-6 \n Polygon checking: TRUE \n\nlibrary(\"ggspatial\")\n\nWarning: package 'ggspatial' was built under R version 4.1.3\n\nlibrary(\"ggrepel\")\n\nLoading required package: ggplot2\n\n\nWarning: package 'ggplot2' was built under R version 4.1.3\n\nlibrary(\"tidyverse\")\n\nWarning: package 'tidyverse' was built under R version 4.1.3\n\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv tibble  3.1.7     v dplyr   1.0.9\nv tidyr   1.2.0     v stringr 1.4.1\nv readr   2.1.2     v forcats 0.5.1\nv purrr   0.3.4     \n\n\nWarning: package 'tibble' was built under R version 4.1.3\n\n\nWarning: package 'tidyr' was built under R version 4.1.3\n\n\nWarning: package 'readr' was built under R version 4.1.3\n\n\nWarning: package 'dplyr' was built under R version 4.1.3\n\n\nWarning: package 'stringr' was built under R version 4.1.3\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\n\nAlvorens de kaarten te maken, moeten we de geografische gegevens in R importeren. Wij hebben ze opgeslagen in DR2_data, het volgende dataframe.\nZoals je kunt zien, zijn steden de basiseenheid van dit dataframe. Voor elk van hen hebben we het land opgegeven, het aantal leden (Members), het label dat we op de kaart zullen weergeven (het bestaat uit de naam van de stad plus het aantal leden tussen haakjes), en de breedtegraad en lengtegraad.\nWe importeren het dataframe, dat is opgeslagen in een CSV bestand, in R met de functie read.csv. Aangezien we een header met de namen van de kolommen hebben gebruikt, zetten we het argument header op TRUE. We moeten ook specificeren dat het scheidingsteken tussen de kolommen de puntkomma is en dat het decimaal scheidingsteken de komma is (en niet de punt, omdat er een Italiaanse versie van Excel is gebruikt om het bestand te produceren).\n\nDR2_data <- read.csv(file=\"Dr2.CSV\",\n    header=TRUE, \n    sep=\";\", \n    dec = \",\")\n\nJe kunt de eerste records van het dataframe controleren met het commando head(DR2_data).\n\nhead(DR2_data)\n\n  ï..ID      City     Country Members         Label      Lat      Lng\n1     1     Turin       Italy      14    Turin (14) 45.07049  7.68682\n2     2     Siena       Italy       2     Siena (2) 43.31822 11.33064\n3     3      Pisa       Italy       1      Pisa (1) 43.70853 10.40360\n4     4  Florence       Italy       1  Florence (1) 43.77925 11.24626\n5     5 Barcelona       Spain       1 Barcelona (1) 41.38879  2.15899\n6     6 Amsterdam Netherlands       1 Amsterdam (1) 52.37403  4.88969\n\n\nWe zijn nu klaar om onze kaart te maken.\n\n\nDe wereldkaart maken\nDe eerste stap van onze kaartoefening is het creëren van een wereldkaart. Om dit te doen, gebruiken we de functie ne_countries om landengegevens op te halen uit rnaturalearth. We specificeren medium als scale en sf als returnclass van het dataframe, zodat de gegevens al in het juiste formaat zijn voor geografische kaarten maken.\n\nworld <- ne_countries(scale = \"medium\", returnclass = \"sf\")\n\nWij plotten deze gegevens met ggplot2, het tidyversepakket voor visualisatie, en sf:\n\nggplot(data = world) +\n       geom_sf()\n\n\n\n\nWij zullen de wereldkaart gebruiken als basiskaart waarop wij de landen waar DR2-leden gevestigd zijn, zullen markeren.\nOm de DR2-landen op de kaart te markeren, moeten wij nu onze DR2-gegevens “toevoegen” aan het dataframe van de wereld. Wij doen dit met de functie left.join.\n\nworld_joined <- left_join(world, DR2_data, by = c(\"name\" = \"Country\"))\n\nDeze functie vertelt R dat het de DR2-data moet verbinden met de worlddata door te zoeken naar een overeenkomst op de naam van het land (we specificeren de overeenkomstige sleutel tussen de twee gegevenssets in het by argument). Wanneer een overeenkomst wordt gevonden, worden de records uit de twee tabellen gecombineerd. Wanneer geen overeenkomst wordt gevonden, zoals in het geval van Brazilië, wordt de waarde van de DR2-kolommen (bv. “Leden”) van de niet-overeenkomende records op NA gezet, de standaardcode die door R wordt gebruikt voor ontbrekende waarden. Zo zal de record Brazilië NA krijgen als waarde van de kolom “Members”. Het is belangrijk om alle landen in de wereld te behouden en niet alleen die met DR2-leden. Anders zullen wij, wanneer wij onze gegevens op de kaart uitzetten, alle landen zonder DR2 verliezen! Daarom hebben we de left.join gebruikt in plaats van de simple join: we willen dat R alle records in de “linker” dataset behoudt (d.w.z. degene die het eerste argument in de functie bevat).\nWij willen nu de landen met DR2 leden op de wereldkaart markeren. Om dit te doen gebruiken we een if...else in het fill argument. Indien de waarde van de kolom “Members” null is (d.w.z. gelijk aan NA), stellen wij de kleur van het land in op grijs. Indien de waarde niet nul is, d.w.z. indien er DR2 leden zijn in dat land, stellen we de kleur in op rood. Merk op dat we in het eerste geval de kleurnaam hebben gebruikt, terwijl we in het tweede geval de hexadecimale kleurcode hebben gebruikt die overeenkomt met de kleur van het DR2-logo. Het argument kleur specificeert de kleur van de grenzen van de landen.\n\n DR2_countries_map <- ggplot(data =  world_joined)+\n    geom_sf(fill = ifelse(is.na(world_joined$Members), \"lightgrey\", \"#c8242b\"), \n    color = \"black\")\n\nDe Europese landen waar DR2-leden gevestigd zijn, zijn te klein om op een wereldkaart op te vallen. De wereldschaal is dus niet erg effectief om de geografische spreiding van DR2 weer te geven. We moeten inzoomen op het niveau van Europa. Een zeer nuttig kenmerk van het sf-pakket is dat dit zeer gemakkelijk kan worden gedaan door een reeks coördinaten op te geven van het gebied waarin wij geïnteresseerd zijn:\n\nDR2_countries_map +\n    coord_sf(xlim = c(-16.1, 32.88), \n        ylim = c(35, 60), \n        expand = TRUE)\n\n\n\n\n\n\nSteden markeren (puntdata)\nWij weten dat DR2-leden niet alleen in bepaalde landen gevestigd zijn, maar ook in specifieke steden binnen die landen. In ons DR2-dataset hadden we de DR2-steden samen met hun geografische coördinaten. We willen deze steden nu als punten op onze kaart plaatsen.\nWe moeten eerst ons dataframe converteren naar een sf object:\n\nsf_DR2_cities <- st_as_sf(DR2_data, \n    coords = c(\"Lng\", \"Lat\"), \n    remove = FALSE, \n    crs = 4326, \n    agr = \"constant\")\n\nMerk op dat we de kolommen moesten aanduiden waarin de geografische coördinaten van onze steden zijn opgeslagen, evenals andere parameters zoals de gebruikte geografische projectie (hier WGS84, wat de CRS-code #4326 is).\nWe kunnen nu de punten van de steden op de kaart plotten:\n\nDR2_countries_map +\n    geom_sf(data = sf_DR2_cities)\n\n\n\n\nOm ze duidelijk te zien, laten we inzoomen op Europa, zoals we eerder hebben geleerd:\n\nDR2_countries_map +\n    geom_sf(data = sf_DR2_cities) +\n    coord_sf(xlim = c(-16.1, 32.88), \n        ylim = c(35, 60), \n        expand = TRUE)\n\n\n\n\n\n\nLabels toevoegen\nOm de interpretatie van onze kaart te vergemakkelijken, is het zeer nuttig om enkele labels toe te voegen. Wij willen bijvoorbeeld weten hoeveel DR2-leden gevestigd zijn in de steden die wij eerder hebben aangegeven. We hebben de tekst van de labels al in de kolom “Label” van het DR2-datasetje. Nu moeten we deze tekst op de kaart visualiseren. We doen dit door gebruik te maken van de functie geom_label_repel. Deze functie, die is opgenomen in het pakket ggrepel, verbetert de positionering van labels op een plot: ze stoot labels van elkaar af, weg van datapunten, en weg van de randen van het plotgebied.\nIn de parameter esthetica van de functie specificeren we dat we de etiketten op de kaart willen plaatsen op basis van de breedte- en lengtegraad van de steden, en dat hun tekst wordt aangegeven in de kolom “Label”. De andere parameters specificeren de kleur van de labels, de grootte van de tekst, en de hoeveelheid “afstotingskracht” van het positioneringsalgoritme.\n\nDR2_countries_map +\n    geom_sf(data = sf_DR2_cities) +\n    geom_label_repel(data = sf_DR2_cities, \n        aes(x = Lng, y = Lat, label = Label), \n        color = \"black\", \n        fontface = \"bold\", \n        size = 3, \n        force = 5)\n\nWarning: ggrepel: 9 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\nEr is echter een probleem. Als we inzoomen op Europa, vinden we een “indringer”: het label “Montreal (1)” zou niet mogen verschijnen op de Europese kaart!\nOm dit probleempje op te lossen, moeten we de steden in landen buiten Europa uitfilteren. We maken dus een deelverzameling van het DR2-datasetje en specificeren dat we alle records willen behouden waarvan het land niet ( != ) Canada is:\n\nDR2_european_cities <- subset(DR2_data, \n            Country != \"Canada\", \n            select = City:Lng)\n## Convert to the sf format\nsf_DR2_european_cities <- st_as_sf(DR2_european_cities, \n    coords = c(\"Lng\", \"Lat\"), \n    remove = FALSE, \n    crs = 4326, \n    agr = \"constant\")\n\nAls we de nieuwe dataset op de Europese kaart uitzetten, ontdekken we dat de indringer is verwijderd:\n\nDR2_countries_map +\n    geom_sf(data = sf_DR2_european_cities) +\n    geom_label_repel(data = sf_DR2_european_cities, \n        aes(x = Lng, y = Lat, label = Label), \n        color = \"black\", \n        fontface = \"bold\",  \n        size = 3, \n        force = 5)+\n    coord_sf(xlim = c(-16.1, 32.88), \n        ylim = c(35, 60), \n        expand = TRUE)\n\n\n\n\nHet is duidelijk dat er redenen kunnen zijn om het label Montreal te behouden: bijvoorbeeld om aan te tonen dat DR2 ook overzeese leden heeft.\n\n\nVerbetering van de kaart\nIn de tot nu toe gegenereerde versies van de kaart wordt de informatie over het aantal leden van DR2 in de labels weergegeven, als een getal tussen haakjes. Is het mogelijk om dit als een visueel kenmerk weer te geven, zodat het meteen in het oog springt? Een eerste idee zou kunnen zijn om de grootte van de labels evenredig met het aantal leden te veranderen:\n\nDR2_countries_map +\n    geom_sf(data = sf_DR2_european_cities) +\n    geom_label_repel(data = sf_DR2_european_cities, \n        aes(x = Lng, y = Lat, label = Label, size = Members), \n        color = \"black\", \n        fontface = \"bold\",  \n        force = 5)+\n    coord_sf(xlim = c(-16.1, 32.88), \n        ylim = c(35, 60), \n        expand = TRUE)\n\n\n\n\nHet resultaat is echter vrij slecht, vanwege het grote verschil in grootte tussen Turijn en de andere steden. Aangezien de meeste steden slechts één lid hebben, zijn hun labels te klein om leesbaar te zijn. Merk op dat R automatisch een legende toevoegt om de grootte van de labels te interpreteren.\nEen betere oplossing is om de grootte van de stadspunten evenredig te laten zijn met het aantal leden:\n\nDR2_countries_map +\n    geom_sf(data = sf_DR2_european_cities, \n        aes(size = Members))+\n    geom_label_repel(data = sf_DR2_european_cities, \n        aes(x = Lng, y = Lat, label = Label), \n        color = \"black\", \n        fontface = \"bold\",\n        size = 3,   \n        force = 9)+\n    coord_sf(xlim = c(-16.1, 32.88), \n        ylim = c(35, 60), \n        expand = TRUE)\n\n\n\n\nMerk op dat R automatisch een legende creëert op basis van de grootte van de punten:\nOp dezelfde manier kunnen we ook de kleur van de punten gebruiken om het aantal leden weer te geven. We passen de kleurenschaal aan door het uiterste in te stellen op blauw en groen, zodat de grote steden in blauw en de kleine steden in groen worden gekleurd:\n\nDR2_countries_map +\n    geom_sf(data = sf_DR2_european_cities, \n        aes(color = Members, size = Members))+\n    scale_color_gradient(low = \"blue\", high = \"green\")+\n    geom_label_repel(data = sf_DR2_european_cities, \n        aes(x = Lng, y = Lat, label = Label), \n        color = \"black\", \n        fontface = \"bold\",\n        size = 3,   \n        force = 9)+\n    coord_sf(xlim = c(-16.1, 32.88), \n        ylim = c(35, 60), \n        expand = TRUE)\n\n\n\n\nMerk op dat R een tweede legende toevoegt om de kleur van de punten te interpreteren:\nDe laatste kaart lijkt me echter “overbelast”. Dezelfde informatie (de DR2 leden) wordt op drie verschillende manieren gevisualiseerd: met een getal in het label, met de grootte van de punten, en met de kleur van de punten. Persoonlijk vind ik deze oplossing overbodig. Ik denk dat de tweede kaart het meest evenwichtig (en esthetisch het meest aangenaam) is.\n\n\nLaatste accenten\nEen groot voordeel van ggplot2 is dat het toelaat om bijna alle grafische aspecten van de visualisaties te controleren. Door de parameters in de thema-functie te wijzigen, kunnen we onze kaart verfijnen tot ze aan onze smaak beantwoordt. Om de uiteindelijke versie van de kaart te realiseren, veranderen we de kleur van de achtergrond van de kaart (dat is de oceaan) in lichtblauw, we verwijderen de titels van de assen, de teksten en de vinkjes en de legenda. Tenslotte voegen we een titel toe aan onze kaart.\n\nEuropean_DR2_map2 <- DR2_countries_map +\n    geom_sf(data = sf_DR2_european_cities, \n        aes(size = Members))+\n    geom_label_repel(data = sf_DR2_european_cities, \n        aes(x = Lng, y = Lat, label = Label), \n        color = \"black\", \n        fontface = \"bold\",\n        size = 3,   \n        force = 12)+\n    coord_sf(xlim = c(-16.1, 32.88), \n        ylim = c(35, 60), \n        expand = TRUE)+\n    theme_minimal() +\n    theme(panel.background = element_rect(fill = \"aliceblue\"), \n        axis.title.x = element_blank(), \n        axis.title.y = element_blank(), \n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"none\") +\n    ggtitle(\"Map of DR2 Members in Europe\")\n\nDe laatste stap is het opslaan van de kaart in een geschikt formaat. We slaan zowel een PDF-versie van de kaart op, die de hoogste kwaliteit behoudt, als een lichtere PNG-versie:\n\nggsave(\"DR2_map_Europe.pdf\")\n\nSaving 7 x 5 in image\n\nggsave(\"DR2_map_Europe.png\", dpi = \"screen\")\n\nSaving 7 x 5 in image\n\n\n\n\n\n\nZo ziet het eruit\n\n\n\n\n\nVerder lezen\nDeze korte handleiding is grotendeels geïnspireerd door de tutorial die Euginio gebruikte om de basis van mapping met R te leren. Hij legt heel duidelijk verschillende andere onderwerpen uit die met maps te maken hebben en hij raadt deze zeker aan. Een andere nuttige tutorial is voor hem deze, die uitlegt hoe je een ander R-pakket voor kaarten, ggmap, gebruikt en een aantal veelvoorkomende data wrangling operaties."
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#data-imputeren-met-r-het-mice-pakket",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#data-imputeren-met-r-het-mice-pakket",
    "title": "Missende waarden",
    "section": "Data imputeren met R; het MICE pakket",
    "text": "Data imputeren met R; het MICE pakket"
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#inleiding",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#inleiding",
    "title": "Missende waarden",
    "section": "Inleiding",
    "text": "Inleiding\nOnlangs gaf Stef van Buuren een verhelderende introductie op het pakket mice dat hij de laatste jaren ontwikkeld heeft en dat een standaardpakket geworden is om missende data om te gaan. Zijn presentatie is hier te vinden slides. Hij verwees tijdens de presentatie naar het artikel dat hij hierover eerder schreef (Van Buuren, and Groothuis-Oudshoorn, 2011)[hier](mice: Multivariate Imputation by Chained Equations in R by Stef van Buuren, het boek dat hij hierover maakte hier en ook verwees hij naar een korte Nederlandse talige introductie hier. Na zijn presentatie las ik via Rbloggers de korte post van Michy Allice hier.Voor deze blog heb ik dat artile van Allice bewerkt. Tot slot las ik ook nog het boek van Heymans en Eekhout over dit onderwerp hier dat ook goed is."
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#het-mice-pakket",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#het-mice-pakket",
    "title": "Missende waarden",
    "section": "Het mice-pakket",
    "text": "Het mice-pakket\nOntbrekende gegevens zijn niet zo’n triviaal probleem bij de analyse van een dataset. Het is meestal ook niet zo eenvoudig om er rekening mee te houden.\nAls de hoeveelheid ontbrekende gegevens zeer klein is in verhouding tot de grootte van de dataset, dan kan het weglaten van de weinige data met ontbrekende kenmerken de beste strategie zijn om de analyse niet te vertekenen,. Met hety weglaten van beschikbare datapunten verdwijnt een bepaalde hoeveelheid informatie. Afhankelijk van de situatie waarmee u te maken hebt, kunt u op zoek gaan naar andere oplossingen voordat u potentieel nuttige datapunten uit uw dataset verwijdert.\nHoewel sommige snelle oplossingen zoals het vervangen door het gemiddelde in sommige gevallen goed kunnen zijn, heb je met zulke eenvoudige benaderingen gewoonlijk bias in de data. Het toepassen van gemiddelde-substitutie laat het gemiddelde onveranderd (wat wenselijk is), maar vermindert de variantie, wat onwenselijk kan zijn.\n\nHet micepakket in R helpt bij het imputeren van ontbrekende waarden met plausibele gegevenswaarden. Deze plausibele waarden worden getrokken uit een distributie die speciaal ontworpen is voor elk ontbrekend datapunt.\n\nHieronder gaan we ontbrekende waarden imputeren met behulp van de dataset airquality (standaard beschikbaar in R). Voor dit blog verwijder ik een aantal datapunten uit de dataset.\n\nlibrary(mice)\n\nWarning: package 'mice' was built under R version 4.1.3\n\n\n\nAttaching package: 'mice'\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following objects are masked from 'package:base':\n\n    cbind, rbind\n\ndata <- airquality\ndata[4:10,3] <- rep(NA,7)\ndata[1:5,4] <- NA\nsummary(data)\n\n     Ozone           Solar.R           Wind             Temp      \n Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :57.00  \n 1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:73.00  \n Median : 31.50   Median :205.0   Median : 9.700   Median :79.00  \n Mean   : 42.13   Mean   :185.9   Mean   : 9.806   Mean   :78.28  \n 3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00  \n Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00  \n NA's   :37       NA's   :7       NA's   :7        NA's   :5      \n     Month            Day      \n Min.   :5.000   Min.   : 1.0  \n 1st Qu.:6.000   1st Qu.: 8.0  \n Median :7.000   Median :16.0  \n Mean   :6.993   Mean   :15.8  \n 3rd Qu.:8.000   3rd Qu.:23.0  \n Max.   :9.000   Max.   :31.0  \n                               \n\n\nWat categorische variabelen betreft, is het vervangen van categorische variabelen gewoonlijk niet aan te bevelen. Het is wel gebruikelijk om ontbrekende categorische variabelen te vervangen door de modus van de waargenomen variabelen, maar het is de vraag of dat een goede keuze is. Ook al ontbreken er in dit geval geen datapunten van de categorische variabelen (Month, Day), we verwijderen ze uit onze dataset (we kunnen ze later weer toevoegen als dat nodig is) en bekijken de gegevens met summary().\n\ndata <- data[-c(5,6)]\nsummary(data)\n\n     Ozone           Solar.R           Wind             Temp      \n Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :57.00  \n 1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:73.00  \n Median : 31.50   Median :205.0   Median : 9.700   Median :79.00  \n Mean   : 42.13   Mean   :185.9   Mean   : 9.806   Mean   :78.28  \n 3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00  \n Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00  \n NA's   :37       NA's   :7       NA's   :7        NA's   :5      \n\n\nOzon is blijkbaar de variabele met de meeste ontbrekende datapunten. Hieronder gaan we dieper in op de ontbrekende datapatronen."
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#snelle-classificatie-van-ontbrekende-gegevens",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#snelle-classificatie-van-ontbrekende-gegevens",
    "title": "Missende waarden",
    "section": "Snelle classificatie van ontbrekende gegevens",
    "text": "Snelle classificatie van ontbrekende gegevens\nEr zijn twee soorten ontbrekende gegevens:\n\nMCAR: volledig willekeurig ontbrekend. Dit is het wenselijke scenario in geval van ontbrekende data.\n\nMNAR: missing not at random. Niet-willekeurig ontbrekende gegevens zijn een ernstiger probleem en in dit geval kan het verstandig zijn het proces van gegevensverzameling verder te controleren en te proberen te begrijpen waarom de informatie ontbreekt. Als bijvoorbeeld de meeste mensen in een enquête een bepaalde vraag niet hebben beantwoord, waarom hebben zij dat dan gedaan? Was de vraag onduidelijk?\n\nErvan uitgaande dat de gegevens MCAR zijn, kan een teveel aan ontbrekende gegevens ook een probleem zijn. Gewoonlijk is een veilige maximumdrempel 5% van het totaal voor grote datasets. Als de ontbrekende gegevens voor een bepaald kenmerk of een bepaalde steekproef meer dan 5% bedragen, moet u dat kenmerk of die steekproef waarschijnlijk weglaten. Daarom controleren we op kenmerken (kolommen) en steekproeven (rijen) waar meer dan 5% van de data ontbreekt met een eenvoudige functie\n\npMiss <- function(x){sum(is.na(x))/length(x)*100}\napply(data,2,pMiss)\n\n    Ozone   Solar.R      Wind      Temp \n24.183007  4.575163  4.575163  3.267974 \n\napply(data,1,pMiss)\n\n  [1]  25  25  25  50 100  50  25  25  25  50  25   0   0   0   0   0   0   0\n [19]   0   0   0   0   0   0  25  25  50   0   0   0   0  25  25  25  25  25\n [37]  25   0  25   0   0  25  25   0  25  25   0   0   0   0   0  25  25  25\n [55]  25  25  25  25  25  25  25   0   0   0  25   0   0   0   0   0   0  25\n [73]   0   0  25   0   0   0   0   0   0   0  25  25   0   0   0   0   0   0\n [91]   0   0   0   0   0  25  25  25   0   0   0  25  25   0   0   0  25   0\n[109]   0   0   0   0   0   0  25   0   0   0  25   0   0   0   0   0   0   0\n[127]   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0\n[145]   0   0   0   0   0  25   0   0   0\n\n\nWe zien dat Ozon bijna 25% van de datapunten mist, dus we kunnen overwegen om het uit de analyse te laten of meer metingen te verzamelen. De andere variabelen blijven onder de drempel van 5%, zodat we ze kunnen behouden. Wat de data betreft, leidt het ontbreken van slechts één kenmerk tot 25% ontbrekende gegevens per dataset."
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#gebruik-mice-voor-het-bekijken-van-ontbrekende-data-patronen",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#gebruik-mice-voor-het-bekijken-van-ontbrekende-data-patronen",
    "title": "Missende waarden",
    "section": "Gebruik `mice voor het bekijken van ontbrekende data patronen",
    "text": "Gebruik `mice voor het bekijken van ontbrekende data patronen\nHet mice pakket biedt een mooie functie md.pattern() om een beter inzicht te krijgen in het patroon van ontbrekende gegevens.\n\nmd.pattern(data)\n\n\n\n\n    Temp Solar.R Wind Ozone   \n104    1       1    1     1  0\n34     1       1    1     0  1\n3      1       1    0     1  1\n1      1       1    0     0  2\n4      1       0    1     1  1\n1      1       0    1     0  2\n1      1       0    0     1  2\n3      0       1    1     1  1\n1      0       1    0     1  2\n1      0       0    0     0  4\n       5       7    7    37 56\n\n\nDe output vertelt ons dat 104 gegevens compleet zijn, 34 data missen alleen de Ozonmeting, 3 data missen alleen de Solar.R waarde enzovoort.\nEen wellicht meer behulpzame visuele weergave kan worden verkregen met behulp van het VIM pakket als volgt\n\nlibrary(VIM)\n\nWarning: package 'VIM' was built under R version 4.1.3\n\n\nLoading required package: colorspace\n\n\nLoading required package: grid\n\n\nVIM is ready to use.\n\n\nSuggestions and bug-reports can be submitted at: https://github.com/statistikat/VIM/issues\n\n\n\nAttaching package: 'VIM'\n\n\nThe following object is masked from 'package:datasets':\n\n    sleep\n\naggr_plot <- aggr(data, col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, labels=names(data), cex.axis=.7, gap=3, ylab=c(\"Histogram van missende data\",\"Patroon\"))\n\n\n\n\n\n Variables sorted by number of missings: \n Variable      Count\n    Ozone 0.24183007\n  Solar.R 0.04575163\n     Wind 0.04575163\n     Temp 0.03267974\n\n\nUit de grafiek kunnen we opmaken dat bij bijna 70% van de data geen informatie ontbreekt, bij 22% ontbreekt de ozonwaarde en bij de overige variabelen ontbreekt zo’n 5%. Door deze aanpak ziet de situatie er naar mijn mening een stuk duidelijker uit.\nEen andere (hopelijk) behulpzame visuele benadering is een speciale boxplot\n\nmarginplot(data[c(1,2)])\n\n\n\n\nUiteraard zijn we hier beperkt tot het plotten van slechts 2 variabelen tegelijk, maar desalniettemin kunnen we hier een aantal interessante inzichten uit verkrijgen. De rode boxplot links toont de verdeling van Solar.R waarbij Ozone ontbreekt, terwijl de blauwe boxplot de verdeling van de resterende datapunten toont. Hetzelfde geldt voor de boxplots van Ozone onderaan de grafiek. Als onze aanname van MCAR-gegevens juist is, dan verwachten we dat de rode en blauwe boxplots sterk op elkaar lijken."
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#imputeren-van-missende-data",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#imputeren-van-missende-data",
    "title": "Missende waarden",
    "section": "Imputeren van missende data",
    "text": "Imputeren van missende data\nDe mice() functie zorgt voor het imputatieprocess\n\ntempData <- mice(data,m=5,maxit=50,meth='pmm',seed=500)\n\n\n iter imp variable\n  1   1  Ozone  Solar.R  Wind  Temp\n  1   2  Ozone  Solar.R  Wind  Temp\n  1   3  Ozone  Solar.R  Wind  Temp\n  1   4  Ozone  Solar.R  Wind  Temp\n  1   5  Ozone  Solar.R  Wind  Temp\n  2   1  Ozone  Solar.R  Wind  Temp\n  2   2  Ozone  Solar.R  Wind  Temp\n  2   3  Ozone  Solar.R  Wind  Temp\n  2   4  Ozone  Solar.R  Wind  Temp\n  2   5  Ozone  Solar.R  Wind  Temp\n  3   1  Ozone  Solar.R  Wind  Temp\n  3   2  Ozone  Solar.R  Wind  Temp\n  3   3  Ozone  Solar.R  Wind  Temp\n  3   4  Ozone  Solar.R  Wind  Temp\n  3   5  Ozone  Solar.R  Wind  Temp\n  4   1  Ozone  Solar.R  Wind  Temp\n  4   2  Ozone  Solar.R  Wind  Temp\n  4   3  Ozone  Solar.R  Wind  Temp\n  4   4  Ozone  Solar.R  Wind  Temp\n  4   5  Ozone  Solar.R  Wind  Temp\n  5   1  Ozone  Solar.R  Wind  Temp\n  5   2  Ozone  Solar.R  Wind  Temp\n  5   3  Ozone  Solar.R  Wind  Temp\n  5   4  Ozone  Solar.R  Wind  Temp\n  5   5  Ozone  Solar.R  Wind  Temp\n  6   1  Ozone  Solar.R  Wind  Temp\n  6   2  Ozone  Solar.R  Wind  Temp\n  6   3  Ozone  Solar.R  Wind  Temp\n  6   4  Ozone  Solar.R  Wind  Temp\n  6   5  Ozone  Solar.R  Wind  Temp\n  7   1  Ozone  Solar.R  Wind  Temp\n  7   2  Ozone  Solar.R  Wind  Temp\n  7   3  Ozone  Solar.R  Wind  Temp\n  7   4  Ozone  Solar.R  Wind  Temp\n  7   5  Ozone  Solar.R  Wind  Temp\n  8   1  Ozone  Solar.R  Wind  Temp\n  8   2  Ozone  Solar.R  Wind  Temp\n  8   3  Ozone  Solar.R  Wind  Temp\n  8   4  Ozone  Solar.R  Wind  Temp\n  8   5  Ozone  Solar.R  Wind  Temp\n  9   1  Ozone  Solar.R  Wind  Temp\n  9   2  Ozone  Solar.R  Wind  Temp\n  9   3  Ozone  Solar.R  Wind  Temp\n  9   4  Ozone  Solar.R  Wind  Temp\n  9   5  Ozone  Solar.R  Wind  Temp\n  10   1  Ozone  Solar.R  Wind  Temp\n  10   2  Ozone  Solar.R  Wind  Temp\n  10   3  Ozone  Solar.R  Wind  Temp\n  10   4  Ozone  Solar.R  Wind  Temp\n  10   5  Ozone  Solar.R  Wind  Temp\n  11   1  Ozone  Solar.R  Wind  Temp\n  11   2  Ozone  Solar.R  Wind  Temp\n  11   3  Ozone  Solar.R  Wind  Temp\n  11   4  Ozone  Solar.R  Wind  Temp\n  11   5  Ozone  Solar.R  Wind  Temp\n  12   1  Ozone  Solar.R  Wind  Temp\n  12   2  Ozone  Solar.R  Wind  Temp\n  12   3  Ozone  Solar.R  Wind  Temp\n  12   4  Ozone  Solar.R  Wind  Temp\n  12   5  Ozone  Solar.R  Wind  Temp\n  13   1  Ozone  Solar.R  Wind  Temp\n  13   2  Ozone  Solar.R  Wind  Temp\n  13   3  Ozone  Solar.R  Wind  Temp\n  13   4  Ozone  Solar.R  Wind  Temp\n  13   5  Ozone  Solar.R  Wind  Temp\n  14   1  Ozone  Solar.R  Wind  Temp\n  14   2  Ozone  Solar.R  Wind  Temp\n  14   3  Ozone  Solar.R  Wind  Temp\n  14   4  Ozone  Solar.R  Wind  Temp\n  14   5  Ozone  Solar.R  Wind  Temp\n  15   1  Ozone  Solar.R  Wind  Temp\n  15   2  Ozone  Solar.R  Wind  Temp\n  15   3  Ozone  Solar.R  Wind  Temp\n  15   4  Ozone  Solar.R  Wind  Temp\n  15   5  Ozone  Solar.R  Wind  Temp\n  16   1  Ozone  Solar.R  Wind  Temp\n  16   2  Ozone  Solar.R  Wind  Temp\n  16   3  Ozone  Solar.R  Wind  Temp\n  16   4  Ozone  Solar.R  Wind  Temp\n  16   5  Ozone  Solar.R  Wind  Temp\n  17   1  Ozone  Solar.R  Wind  Temp\n  17   2  Ozone  Solar.R  Wind  Temp\n  17   3  Ozone  Solar.R  Wind  Temp\n  17   4  Ozone  Solar.R  Wind  Temp\n  17   5  Ozone  Solar.R  Wind  Temp\n  18   1  Ozone  Solar.R  Wind  Temp\n  18   2  Ozone  Solar.R  Wind  Temp\n  18   3  Ozone  Solar.R  Wind  Temp\n  18   4  Ozone  Solar.R  Wind  Temp\n  18   5  Ozone  Solar.R  Wind  Temp\n  19   1  Ozone  Solar.R  Wind  Temp\n  19   2  Ozone  Solar.R  Wind  Temp\n  19   3  Ozone  Solar.R  Wind  Temp\n  19   4  Ozone  Solar.R  Wind  Temp\n  19   5  Ozone  Solar.R  Wind  Temp\n  20   1  Ozone  Solar.R  Wind  Temp\n  20   2  Ozone  Solar.R  Wind  Temp\n  20   3  Ozone  Solar.R  Wind  Temp\n  20   4  Ozone  Solar.R  Wind  Temp\n  20   5  Ozone  Solar.R  Wind  Temp\n  21   1  Ozone  Solar.R  Wind  Temp\n  21   2  Ozone  Solar.R  Wind  Temp\n  21   3  Ozone  Solar.R  Wind  Temp\n  21   4  Ozone  Solar.R  Wind  Temp\n  21   5  Ozone  Solar.R  Wind  Temp\n  22   1  Ozone  Solar.R  Wind  Temp\n  22   2  Ozone  Solar.R  Wind  Temp\n  22   3  Ozone  Solar.R  Wind  Temp\n  22   4  Ozone  Solar.R  Wind  Temp\n  22   5  Ozone  Solar.R  Wind  Temp\n  23   1  Ozone  Solar.R  Wind  Temp\n  23   2  Ozone  Solar.R  Wind  Temp\n  23   3  Ozone  Solar.R  Wind  Temp\n  23   4  Ozone  Solar.R  Wind  Temp\n  23   5  Ozone  Solar.R  Wind  Temp\n  24   1  Ozone  Solar.R  Wind  Temp\n  24   2  Ozone  Solar.R  Wind  Temp\n  24   3  Ozone  Solar.R  Wind  Temp\n  24   4  Ozone  Solar.R  Wind  Temp\n  24   5  Ozone  Solar.R  Wind  Temp\n  25   1  Ozone  Solar.R  Wind  Temp\n  25   2  Ozone  Solar.R  Wind  Temp\n  25   3  Ozone  Solar.R  Wind  Temp\n  25   4  Ozone  Solar.R  Wind  Temp\n  25   5  Ozone  Solar.R  Wind  Temp\n  26   1  Ozone  Solar.R  Wind  Temp\n  26   2  Ozone  Solar.R  Wind  Temp\n  26   3  Ozone  Solar.R  Wind  Temp\n  26   4  Ozone  Solar.R  Wind  Temp\n  26   5  Ozone  Solar.R  Wind  Temp\n  27   1  Ozone  Solar.R  Wind  Temp\n  27   2  Ozone  Solar.R  Wind  Temp\n  27   3  Ozone  Solar.R  Wind  Temp\n  27   4  Ozone  Solar.R  Wind  Temp\n  27   5  Ozone  Solar.R  Wind  Temp\n  28   1  Ozone  Solar.R  Wind  Temp\n  28   2  Ozone  Solar.R  Wind  Temp\n  28   3  Ozone  Solar.R  Wind  Temp\n  28   4  Ozone  Solar.R  Wind  Temp\n  28   5  Ozone  Solar.R  Wind  Temp\n  29   1  Ozone  Solar.R  Wind  Temp\n  29   2  Ozone  Solar.R  Wind  Temp\n  29   3  Ozone  Solar.R  Wind  Temp\n  29   4  Ozone  Solar.R  Wind  Temp\n  29   5  Ozone  Solar.R  Wind  Temp\n  30   1  Ozone  Solar.R  Wind  Temp\n  30   2  Ozone  Solar.R  Wind  Temp\n  30   3  Ozone  Solar.R  Wind  Temp\n  30   4  Ozone  Solar.R  Wind  Temp\n  30   5  Ozone  Solar.R  Wind  Temp\n  31   1  Ozone  Solar.R  Wind  Temp\n  31   2  Ozone  Solar.R  Wind  Temp\n  31   3  Ozone  Solar.R  Wind  Temp\n  31   4  Ozone  Solar.R  Wind  Temp\n  31   5  Ozone  Solar.R  Wind  Temp\n  32   1  Ozone  Solar.R  Wind  Temp\n  32   2  Ozone  Solar.R  Wind  Temp\n  32   3  Ozone  Solar.R  Wind  Temp\n  32   4  Ozone  Solar.R  Wind  Temp\n  32   5  Ozone  Solar.R  Wind  Temp\n  33   1  Ozone  Solar.R  Wind  Temp\n  33   2  Ozone  Solar.R  Wind  Temp\n  33   3  Ozone  Solar.R  Wind  Temp\n  33   4  Ozone  Solar.R  Wind  Temp\n  33   5  Ozone  Solar.R  Wind  Temp\n  34   1  Ozone  Solar.R  Wind  Temp\n  34   2  Ozone  Solar.R  Wind  Temp\n  34   3  Ozone  Solar.R  Wind  Temp\n  34   4  Ozone  Solar.R  Wind  Temp\n  34   5  Ozone  Solar.R  Wind  Temp\n  35   1  Ozone  Solar.R  Wind  Temp\n  35   2  Ozone  Solar.R  Wind  Temp\n  35   3  Ozone  Solar.R  Wind  Temp\n  35   4  Ozone  Solar.R  Wind  Temp\n  35   5  Ozone  Solar.R  Wind  Temp\n  36   1  Ozone  Solar.R  Wind  Temp\n  36   2  Ozone  Solar.R  Wind  Temp\n  36   3  Ozone  Solar.R  Wind  Temp\n  36   4  Ozone  Solar.R  Wind  Temp\n  36   5  Ozone  Solar.R  Wind  Temp\n  37   1  Ozone  Solar.R  Wind  Temp\n  37   2  Ozone  Solar.R  Wind  Temp\n  37   3  Ozone  Solar.R  Wind  Temp\n  37   4  Ozone  Solar.R  Wind  Temp\n  37   5  Ozone  Solar.R  Wind  Temp\n  38   1  Ozone  Solar.R  Wind  Temp\n  38   2  Ozone  Solar.R  Wind  Temp\n  38   3  Ozone  Solar.R  Wind  Temp\n  38   4  Ozone  Solar.R  Wind  Temp\n  38   5  Ozone  Solar.R  Wind  Temp\n  39   1  Ozone  Solar.R  Wind  Temp\n  39   2  Ozone  Solar.R  Wind  Temp\n  39   3  Ozone  Solar.R  Wind  Temp\n  39   4  Ozone  Solar.R  Wind  Temp\n  39   5  Ozone  Solar.R  Wind  Temp\n  40   1  Ozone  Solar.R  Wind  Temp\n  40   2  Ozone  Solar.R  Wind  Temp\n  40   3  Ozone  Solar.R  Wind  Temp\n  40   4  Ozone  Solar.R  Wind  Temp\n  40   5  Ozone  Solar.R  Wind  Temp\n  41   1  Ozone  Solar.R  Wind  Temp\n  41   2  Ozone  Solar.R  Wind  Temp\n  41   3  Ozone  Solar.R  Wind  Temp\n  41   4  Ozone  Solar.R  Wind  Temp\n  41   5  Ozone  Solar.R  Wind  Temp\n  42   1  Ozone  Solar.R  Wind  Temp\n  42   2  Ozone  Solar.R  Wind  Temp\n  42   3  Ozone  Solar.R  Wind  Temp\n  42   4  Ozone  Solar.R  Wind  Temp\n  42   5  Ozone  Solar.R  Wind  Temp\n  43   1  Ozone  Solar.R  Wind  Temp\n  43   2  Ozone  Solar.R  Wind  Temp\n  43   3  Ozone  Solar.R  Wind  Temp\n  43   4  Ozone  Solar.R  Wind  Temp\n  43   5  Ozone  Solar.R  Wind  Temp\n  44   1  Ozone  Solar.R  Wind  Temp\n  44   2  Ozone  Solar.R  Wind  Temp\n  44   3  Ozone  Solar.R  Wind  Temp\n  44   4  Ozone  Solar.R  Wind  Temp\n  44   5  Ozone  Solar.R  Wind  Temp\n  45   1  Ozone  Solar.R  Wind  Temp\n  45   2  Ozone  Solar.R  Wind  Temp\n  45   3  Ozone  Solar.R  Wind  Temp\n  45   4  Ozone  Solar.R  Wind  Temp\n  45   5  Ozone  Solar.R  Wind  Temp\n  46   1  Ozone  Solar.R  Wind  Temp\n  46   2  Ozone  Solar.R  Wind  Temp\n  46   3  Ozone  Solar.R  Wind  Temp\n  46   4  Ozone  Solar.R  Wind  Temp\n  46   5  Ozone  Solar.R  Wind  Temp\n  47   1  Ozone  Solar.R  Wind  Temp\n  47   2  Ozone  Solar.R  Wind  Temp\n  47   3  Ozone  Solar.R  Wind  Temp\n  47   4  Ozone  Solar.R  Wind  Temp\n  47   5  Ozone  Solar.R  Wind  Temp\n  48   1  Ozone  Solar.R  Wind  Temp\n  48   2  Ozone  Solar.R  Wind  Temp\n  48   3  Ozone  Solar.R  Wind  Temp\n  48   4  Ozone  Solar.R  Wind  Temp\n  48   5  Ozone  Solar.R  Wind  Temp\n  49   1  Ozone  Solar.R  Wind  Temp\n  49   2  Ozone  Solar.R  Wind  Temp\n  49   3  Ozone  Solar.R  Wind  Temp\n  49   4  Ozone  Solar.R  Wind  Temp\n  49   5  Ozone  Solar.R  Wind  Temp\n  50   1  Ozone  Solar.R  Wind  Temp\n  50   2  Ozone  Solar.R  Wind  Temp\n  50   3  Ozone  Solar.R  Wind  Temp\n  50   4  Ozone  Solar.R  Wind  Temp\n  50   5  Ozone  Solar.R  Wind  Temp\n\nsummary(tempData)\n\nClass: mids\nNumber of multiple imputations:  5 \nImputation methods:\n  Ozone Solar.R    Wind    Temp \n  \"pmm\"   \"pmm\"   \"pmm\"   \"pmm\" \nPredictorMatrix:\n        Ozone Solar.R Wind Temp\nOzone       0       1    1    1\nSolar.R     1       0    1    1\nWind        1       1    0    1\nTemp        1       1    1    0\n\n\nEen paar opmerkingen over de parameters:\n\nm=5 verwijst naar het aantal geïmputeerde datasets. Vijf is de standaard waarde.\n\nmeth='pmm' verwijst naar de imputatie methode. In dit geval gebruiken we pmm (predictive mean matching) als imputatiemethode. Er kunnen ook andere imputatiemethoden worden gebruikt, type methods(mice) voor een lijst van de beschikbare imputatiemethoden.\n\nAls u de geïmputeerde gegevens wilt controleren, bijvoorbeeld voor de variabele Ozon, moet u de volgende regel code invoeren\n\ntempData$imp$Ozone\n\n     1   2   3   4   5\n5   13  19  12 115  63\n10  30  12  13  21   7\n25   8  28   6  18  28\n26   9  32   4  18  37\n27  37  21   4  32  32\n32  40  39  35  32  47\n33  44  28  36  52  20\n34  20  23  37  37  19\n35  32  28  16  32  35\n36  89  80  48  49 115\n37  18   7  16  30  22\n39  96  77 135  76  85\n42  50 168  64  50  41\n43  96  78  96  96  78\n45  63  20  18  24  31\n46  71  37  20  20  28\n52  20  35  37  63  63\n53  16  78  73  48 115\n54  59  35  46  44  23\n55  16  39  28  40  49\n56  24  36  52  21  44\n57  36  20  20  18  23\n58  11  11  24   7  23\n59  44  13  23  23  27\n60  23   4  19   4  32\n61  44  16  46  37  35\n65  30  23  65  30  30\n72  45  37  63  63  44\n75  39  46  32  39  28\n83  37  40  59  32  35\n84  40  59  28  28  35\n102 61  85  96  79  78\n103 31  59  20  31  36\n107 32  24  11  21  21\n115 52  16  11  14  13\n119 78  96 168  76  50\n150 14  12  13  23  11\n\n\nDe uitvoer toont de geïmputeerde data voor elke observatie (eerste kolom links) binnen elke geïmputeerde dataset (eerste rij bovenaan). Als u de gebruikte imputatiemethode voor elke variabele wilt controleren, kunt u dat met mice heel eenvoudig doen\n\ntempData$meth\n\n  Ozone Solar.R    Wind    Temp \n  \"pmm\"   \"pmm\"   \"pmm\"   \"pmm\" \n\n\nNu kunnen we de voltooide dataset terugkrijgen met de complete()functie. Het is bijna gewoon Engels:\n\ncompletedData <- complete(tempData,1)\n\nDe ontbrekende waarden zijn vervangen door de geïmputeerde waarden in de eerste van de vijf datasets. Als je een andere wilt gebruiken, verander dan de tweede parameter in de complete() functie."
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#de-verdeling-van-de-originele-en-geïmputeerde-data-bekijken",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#de-verdeling-van-de-originele-en-geïmputeerde-data-bekijken",
    "title": "Missende waarden",
    "section": "De verdeling van de originele en geïmputeerde data bekijken",
    "text": "De verdeling van de originele en geïmputeerde data bekijken\nLaten we de verdelingen van de originele en geïmputeerde data vergelijken met behulp van een aantal handige plots. Allereerst kunnen we een scatterplot gebruiken en Ozon uitzetten tegen alle andere variabelen.\nHier is dat het geval:\n\nxyplot(tempData,Ozone ~ Wind+Temp+Solar.R,pch=18,cex=1)\n\n\n\n\nWat wij willen zien is dat de vorm van de magenta punten (geïmputeerd) overeenkomt met de vorm van de blauwe punten (waargenomen). De overeenkomstige vorm zegt ons dat de geïmputeerde waarden inderdaad “plausibele waarden” zijn. Een andere nuttige grafiek is de densitygrafiek:\n\ndensityplot(tempData)\n\n\n\n\nDe dichtheid van de geïmputeerde gegevens voor elke geïmputeerde dataset wordt getoond in magenta, terwijl de dichtheid van de waargenomen gegevens in blauw wordt getoond. Nogmaals, onder onze eerdere aannames verwachten we dat de verdelingen vergelijkbaar zijn.\nEen andere nuttige visuele kijk op de verdelingen kan worden verkregen met de stripplot() functie die de verdelingen van de variabelen als afzonderlijke punten toont\n\nstripplot(tempData, pch = 20, cex = 1.2)"
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#pooling",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#pooling",
    "title": "Missende waarden",
    "section": "Pooling",
    "text": "Pooling\nVeronderstel dat de volgende stap in onze analyse erin bestaat een lineair model op de gegevens toe te passen. Dan kun je je afvragen welke geïmputeerde dataset je moet kiezen. Het mice pakket maakt het weer heel gemakkelijk om een model te passen op elk van de geïmputeerde datasets en dan deze resultaten samen te voegen\n\nmodelFit1 <- with(tempData,lm(Temp~ Ozone+Solar.R+Wind))\nsummary(pool(modelFit1))\n\n         term    estimate   std.error statistic        df      p.value\n1 (Intercept) 72.70719792 2.761360433 26.330209 117.27936 0.000000e+00\n2       Ozone  0.15924872 0.025914423  6.145177  49.30693 1.367056e-07\n3     Solar.R  0.01252384 0.008678358  1.443112  18.19046 1.659893e-01\n4        Wind -0.34547006 0.207866970 -1.661977 123.65905 9.905045e-02\n\n\nDe variabele modelFit1 bevat de resultaten van de aanpassing die is uitgevoerd over de geïmputeerde datasets, terwijl de pool() functie ze allemaal samenvoegt. Blijkbaar is alleen de Ozon variabele statistisch significant.\nVergeet niet dat we de mice-functie hebben geïnitialiseerd met een specifieke ‘seed’-instelling. Daarom zijn de resultaten enigszins afhankelijk van onze initiële keuze. Om dit effect te verminderen, kunnen we een hoger aantal datasets toerekenen, door de standaard m=5 parameter in de mice() functie als volgt te wijzigen\n\ntempData2 <- mice(data,m=50,seed=245435)\n\n\n iter imp variable\n  1   1  Ozone  Solar.R  Wind  Temp\n  1   2  Ozone  Solar.R  Wind  Temp\n  1   3  Ozone  Solar.R  Wind  Temp\n  1   4  Ozone  Solar.R  Wind  Temp\n  1   5  Ozone  Solar.R  Wind  Temp\n  1   6  Ozone  Solar.R  Wind  Temp\n  1   7  Ozone  Solar.R  Wind  Temp\n  1   8  Ozone  Solar.R  Wind  Temp\n  1   9  Ozone  Solar.R  Wind  Temp\n  1   10  Ozone  Solar.R  Wind  Temp\n  1   11  Ozone  Solar.R  Wind  Temp\n  1   12  Ozone  Solar.R  Wind  Temp\n  1   13  Ozone  Solar.R  Wind  Temp\n  1   14  Ozone  Solar.R  Wind  Temp\n  1   15  Ozone  Solar.R  Wind  Temp\n  1   16  Ozone  Solar.R  Wind  Temp\n  1   17  Ozone  Solar.R  Wind  Temp\n  1   18  Ozone  Solar.R  Wind  Temp\n  1   19  Ozone  Solar.R  Wind  Temp\n  1   20  Ozone  Solar.R  Wind  Temp\n  1   21  Ozone  Solar.R  Wind  Temp\n  1   22  Ozone  Solar.R  Wind  Temp\n  1   23  Ozone  Solar.R  Wind  Temp\n  1   24  Ozone  Solar.R  Wind  Temp\n  1   25  Ozone  Solar.R  Wind  Temp\n  1   26  Ozone  Solar.R  Wind  Temp\n  1   27  Ozone  Solar.R  Wind  Temp\n  1   28  Ozone  Solar.R  Wind  Temp\n  1   29  Ozone  Solar.R  Wind  Temp\n  1   30  Ozone  Solar.R  Wind  Temp\n  1   31  Ozone  Solar.R  Wind  Temp\n  1   32  Ozone  Solar.R  Wind  Temp\n  1   33  Ozone  Solar.R  Wind  Temp\n  1   34  Ozone  Solar.R  Wind  Temp\n  1   35  Ozone  Solar.R  Wind  Temp\n  1   36  Ozone  Solar.R  Wind  Temp\n  1   37  Ozone  Solar.R  Wind  Temp\n  1   38  Ozone  Solar.R  Wind  Temp\n  1   39  Ozone  Solar.R  Wind  Temp\n  1   40  Ozone  Solar.R  Wind  Temp\n  1   41  Ozone  Solar.R  Wind  Temp\n  1   42  Ozone  Solar.R  Wind  Temp\n  1   43  Ozone  Solar.R  Wind  Temp\n  1   44  Ozone  Solar.R  Wind  Temp\n  1   45  Ozone  Solar.R  Wind  Temp\n  1   46  Ozone  Solar.R  Wind  Temp\n  1   47  Ozone  Solar.R  Wind  Temp\n  1   48  Ozone  Solar.R  Wind  Temp\n  1   49  Ozone  Solar.R  Wind  Temp\n  1   50  Ozone  Solar.R  Wind  Temp\n  2   1  Ozone  Solar.R  Wind  Temp\n  2   2  Ozone  Solar.R  Wind  Temp\n  2   3  Ozone  Solar.R  Wind  Temp\n  2   4  Ozone  Solar.R  Wind  Temp\n  2   5  Ozone  Solar.R  Wind  Temp\n  2   6  Ozone  Solar.R  Wind  Temp\n  2   7  Ozone  Solar.R  Wind  Temp\n  2   8  Ozone  Solar.R  Wind  Temp\n  2   9  Ozone  Solar.R  Wind  Temp\n  2   10  Ozone  Solar.R  Wind  Temp\n  2   11  Ozone  Solar.R  Wind  Temp\n  2   12  Ozone  Solar.R  Wind  Temp\n  2   13  Ozone  Solar.R  Wind  Temp\n  2   14  Ozone  Solar.R  Wind  Temp\n  2   15  Ozone  Solar.R  Wind  Temp\n  2   16  Ozone  Solar.R  Wind  Temp\n  2   17  Ozone  Solar.R  Wind  Temp\n  2   18  Ozone  Solar.R  Wind  Temp\n  2   19  Ozone  Solar.R  Wind  Temp\n  2   20  Ozone  Solar.R  Wind  Temp\n  2   21  Ozone  Solar.R  Wind  Temp\n  2   22  Ozone  Solar.R  Wind  Temp\n  2   23  Ozone  Solar.R  Wind  Temp\n  2   24  Ozone  Solar.R  Wind  Temp\n  2   25  Ozone  Solar.R  Wind  Temp\n  2   26  Ozone  Solar.R  Wind  Temp\n  2   27  Ozone  Solar.R  Wind  Temp\n  2   28  Ozone  Solar.R  Wind  Temp\n  2   29  Ozone  Solar.R  Wind  Temp\n  2   30  Ozone  Solar.R  Wind  Temp\n  2   31  Ozone  Solar.R  Wind  Temp\n  2   32  Ozone  Solar.R  Wind  Temp\n  2   33  Ozone  Solar.R  Wind  Temp\n  2   34  Ozone  Solar.R  Wind  Temp\n  2   35  Ozone  Solar.R  Wind  Temp\n  2   36  Ozone  Solar.R  Wind  Temp\n  2   37  Ozone  Solar.R  Wind  Temp\n  2   38  Ozone  Solar.R  Wind  Temp\n  2   39  Ozone  Solar.R  Wind  Temp\n  2   40  Ozone  Solar.R  Wind  Temp\n  2   41  Ozone  Solar.R  Wind  Temp\n  2   42  Ozone  Solar.R  Wind  Temp\n  2   43  Ozone  Solar.R  Wind  Temp\n  2   44  Ozone  Solar.R  Wind  Temp\n  2   45  Ozone  Solar.R  Wind  Temp\n  2   46  Ozone  Solar.R  Wind  Temp\n  2   47  Ozone  Solar.R  Wind  Temp\n  2   48  Ozone  Solar.R  Wind  Temp\n  2   49  Ozone  Solar.R  Wind  Temp\n  2   50  Ozone  Solar.R  Wind  Temp\n  3   1  Ozone  Solar.R  Wind  Temp\n  3   2  Ozone  Solar.R  Wind  Temp\n  3   3  Ozone  Solar.R  Wind  Temp\n  3   4  Ozone  Solar.R  Wind  Temp\n  3   5  Ozone  Solar.R  Wind  Temp\n  3   6  Ozone  Solar.R  Wind  Temp\n  3   7  Ozone  Solar.R  Wind  Temp\n  3   8  Ozone  Solar.R  Wind  Temp\n  3   9  Ozone  Solar.R  Wind  Temp\n  3   10  Ozone  Solar.R  Wind  Temp\n  3   11  Ozone  Solar.R  Wind  Temp\n  3   12  Ozone  Solar.R  Wind  Temp\n  3   13  Ozone  Solar.R  Wind  Temp\n  3   14  Ozone  Solar.R  Wind  Temp\n  3   15  Ozone  Solar.R  Wind  Temp\n  3   16  Ozone  Solar.R  Wind  Temp\n  3   17  Ozone  Solar.R  Wind  Temp\n  3   18  Ozone  Solar.R  Wind  Temp\n  3   19  Ozone  Solar.R  Wind  Temp\n  3   20  Ozone  Solar.R  Wind  Temp\n  3   21  Ozone  Solar.R  Wind  Temp\n  3   22  Ozone  Solar.R  Wind  Temp\n  3   23  Ozone  Solar.R  Wind  Temp\n  3   24  Ozone  Solar.R  Wind  Temp\n  3   25  Ozone  Solar.R  Wind  Temp\n  3   26  Ozone  Solar.R  Wind  Temp\n  3   27  Ozone  Solar.R  Wind  Temp\n  3   28  Ozone  Solar.R  Wind  Temp\n  3   29  Ozone  Solar.R  Wind  Temp\n  3   30  Ozone  Solar.R  Wind  Temp\n  3   31  Ozone  Solar.R  Wind  Temp\n  3   32  Ozone  Solar.R  Wind  Temp\n  3   33  Ozone  Solar.R  Wind  Temp\n  3   34  Ozone  Solar.R  Wind  Temp\n  3   35  Ozone  Solar.R  Wind  Temp\n  3   36  Ozone  Solar.R  Wind  Temp\n  3   37  Ozone  Solar.R  Wind  Temp\n  3   38  Ozone  Solar.R  Wind  Temp\n  3   39  Ozone  Solar.R  Wind  Temp\n  3   40  Ozone  Solar.R  Wind  Temp\n  3   41  Ozone  Solar.R  Wind  Temp\n  3   42  Ozone  Solar.R  Wind  Temp\n  3   43  Ozone  Solar.R  Wind  Temp\n  3   44  Ozone  Solar.R  Wind  Temp\n  3   45  Ozone  Solar.R  Wind  Temp\n  3   46  Ozone  Solar.R  Wind  Temp\n  3   47  Ozone  Solar.R  Wind  Temp\n  3   48  Ozone  Solar.R  Wind  Temp\n  3   49  Ozone  Solar.R  Wind  Temp\n  3   50  Ozone  Solar.R  Wind  Temp\n  4   1  Ozone  Solar.R  Wind  Temp\n  4   2  Ozone  Solar.R  Wind  Temp\n  4   3  Ozone  Solar.R  Wind  Temp\n  4   4  Ozone  Solar.R  Wind  Temp\n  4   5  Ozone  Solar.R  Wind  Temp\n  4   6  Ozone  Solar.R  Wind  Temp\n  4   7  Ozone  Solar.R  Wind  Temp\n  4   8  Ozone  Solar.R  Wind  Temp\n  4   9  Ozone  Solar.R  Wind  Temp\n  4   10  Ozone  Solar.R  Wind  Temp\n  4   11  Ozone  Solar.R  Wind  Temp\n  4   12  Ozone  Solar.R  Wind  Temp\n  4   13  Ozone  Solar.R  Wind  Temp\n  4   14  Ozone  Solar.R  Wind  Temp\n  4   15  Ozone  Solar.R  Wind  Temp\n  4   16  Ozone  Solar.R  Wind  Temp\n  4   17  Ozone  Solar.R  Wind  Temp\n  4   18  Ozone  Solar.R  Wind  Temp\n  4   19  Ozone  Solar.R  Wind  Temp\n  4   20  Ozone  Solar.R  Wind  Temp\n  4   21  Ozone  Solar.R  Wind  Temp\n  4   22  Ozone  Solar.R  Wind  Temp\n  4   23  Ozone  Solar.R  Wind  Temp\n  4   24  Ozone  Solar.R  Wind  Temp\n  4   25  Ozone  Solar.R  Wind  Temp\n  4   26  Ozone  Solar.R  Wind  Temp\n  4   27  Ozone  Solar.R  Wind  Temp\n  4   28  Ozone  Solar.R  Wind  Temp\n  4   29  Ozone  Solar.R  Wind  Temp\n  4   30  Ozone  Solar.R  Wind  Temp\n  4   31  Ozone  Solar.R  Wind  Temp\n  4   32  Ozone  Solar.R  Wind  Temp\n  4   33  Ozone  Solar.R  Wind  Temp\n  4   34  Ozone  Solar.R  Wind  Temp\n  4   35  Ozone  Solar.R  Wind  Temp\n  4   36  Ozone  Solar.R  Wind  Temp\n  4   37  Ozone  Solar.R  Wind  Temp\n  4   38  Ozone  Solar.R  Wind  Temp\n  4   39  Ozone  Solar.R  Wind  Temp\n  4   40  Ozone  Solar.R  Wind  Temp\n  4   41  Ozone  Solar.R  Wind  Temp\n  4   42  Ozone  Solar.R  Wind  Temp\n  4   43  Ozone  Solar.R  Wind  Temp\n  4   44  Ozone  Solar.R  Wind  Temp\n  4   45  Ozone  Solar.R  Wind  Temp\n  4   46  Ozone  Solar.R  Wind  Temp\n  4   47  Ozone  Solar.R  Wind  Temp\n  4   48  Ozone  Solar.R  Wind  Temp\n  4   49  Ozone  Solar.R  Wind  Temp\n  4   50  Ozone  Solar.R  Wind  Temp\n  5   1  Ozone  Solar.R  Wind  Temp\n  5   2  Ozone  Solar.R  Wind  Temp\n  5   3  Ozone  Solar.R  Wind  Temp\n  5   4  Ozone  Solar.R  Wind  Temp\n  5   5  Ozone  Solar.R  Wind  Temp\n  5   6  Ozone  Solar.R  Wind  Temp\n  5   7  Ozone  Solar.R  Wind  Temp\n  5   8  Ozone  Solar.R  Wind  Temp\n  5   9  Ozone  Solar.R  Wind  Temp\n  5   10  Ozone  Solar.R  Wind  Temp\n  5   11  Ozone  Solar.R  Wind  Temp\n  5   12  Ozone  Solar.R  Wind  Temp\n  5   13  Ozone  Solar.R  Wind  Temp\n  5   14  Ozone  Solar.R  Wind  Temp\n  5   15  Ozone  Solar.R  Wind  Temp\n  5   16  Ozone  Solar.R  Wind  Temp\n  5   17  Ozone  Solar.R  Wind  Temp\n  5   18  Ozone  Solar.R  Wind  Temp\n  5   19  Ozone  Solar.R  Wind  Temp\n  5   20  Ozone  Solar.R  Wind  Temp\n  5   21  Ozone  Solar.R  Wind  Temp\n  5   22  Ozone  Solar.R  Wind  Temp\n  5   23  Ozone  Solar.R  Wind  Temp\n  5   24  Ozone  Solar.R  Wind  Temp\n  5   25  Ozone  Solar.R  Wind  Temp\n  5   26  Ozone  Solar.R  Wind  Temp\n  5   27  Ozone  Solar.R  Wind  Temp\n  5   28  Ozone  Solar.R  Wind  Temp\n  5   29  Ozone  Solar.R  Wind  Temp\n  5   30  Ozone  Solar.R  Wind  Temp\n  5   31  Ozone  Solar.R  Wind  Temp\n  5   32  Ozone  Solar.R  Wind  Temp\n  5   33  Ozone  Solar.R  Wind  Temp\n  5   34  Ozone  Solar.R  Wind  Temp\n  5   35  Ozone  Solar.R  Wind  Temp\n  5   36  Ozone  Solar.R  Wind  Temp\n  5   37  Ozone  Solar.R  Wind  Temp\n  5   38  Ozone  Solar.R  Wind  Temp\n  5   39  Ozone  Solar.R  Wind  Temp\n  5   40  Ozone  Solar.R  Wind  Temp\n  5   41  Ozone  Solar.R  Wind  Temp\n  5   42  Ozone  Solar.R  Wind  Temp\n  5   43  Ozone  Solar.R  Wind  Temp\n  5   44  Ozone  Solar.R  Wind  Temp\n  5   45  Ozone  Solar.R  Wind  Temp\n  5   46  Ozone  Solar.R  Wind  Temp\n  5   47  Ozone  Solar.R  Wind  Temp\n  5   48  Ozone  Solar.R  Wind  Temp\n  5   49  Ozone  Solar.R  Wind  Temp\n  5   50  Ozone  Solar.R  Wind  Temp\n\nmodelFit2 <- with(tempData2,lm(Temp~ Ozone+Solar.R+Wind))\nsummary(pool(modelFit2))\n\n         term    estimate   std.error statistic        df      p.value\n1 (Intercept) 72.60178955 2.915916315 24.898448 105.59368 0.000000e+00\n2       Ozone  0.16345639 0.026054628  6.273603  99.86352 9.122568e-09\n3     Solar.R  0.01193645 0.007134344  1.673097 120.41496 9.690433e-02\n4        Wind -0.33592048 0.222350762 -1.510768 107.41496 1.337838e-01\n\n\nNa aanpassing, krijgen we (in dit geval) min of meer dezelfde resultaten als voorheen, waarbij alleen Ozone statistische significantie vertoont.\nDe code kun je hier vinden."
  },
  {
    "objectID": "posts/2022-05-08-missende-waarden/missende-waarden.html#literatuur",
    "href": "posts/2022-05-08-missende-waarden/missende-waarden.html#literatuur",
    "title": "Missende waarden",
    "section": "Literatuur",
    "text": "Literatuur\nAlice, M. (2015). Imputing missing data with R; micepackage. R-bloggers, 4-10-2015. https://www.r-bloggers.com/2015/10/imputing-missing-data-with-r-mice-package/\nHeymans, M. en Eekhout, I. (2019). Applied Missing Data Analysis With SPSS and (R)Studio. Amsterdam. https://bookdown.org/mwheymans/bookmi/\nVan Buuren, S. and Groothuis-Oudshoorn, C.G.M. (2011).mice: Multivariate Imputation by Chained Equations in R. Journal of Statistical Software, 45(3), 1–67.\nVan Buuren (2012). Multiple imputatie in vogelvlucht. https://stefvanbuuren.name/publications/2012%20Vogelvlucht%20-%20STAtOR.pdf\nVan Buuren, S. (2018). Flexible Imputation of Missing Data. Second Edition. Chapman & Hall/CRC, Boca Raton, FL"
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html",
    "title": "Van distill naar quarto?",
    "section": "",
    "text": "Een jaar geleden besloot Danielle Navarro om weer te gaan bloggen en deze blog zette ze op: blog van Danielle Navarro. Ze koos voor distill, haar keuze. Destijds heeft zij een bewuste keuze gemaakt om distill te gebruiken als mijn blogging platform in plaats van een statische site generator zoals hugo of jekyll en ze heeft geen spijt van die keuze. Gaandeweg vond zij echter een paar dingen die haar dwars zaten bij het gebruik van distill. Het is echter nooit de moeite waard geweest om te overwegen over te stappen op iets nieuws omdat distill zoveel dingen heeft die zij waardeert. Tot nu toe dan.\nNu komt quarto binnen. Ook ik werk al enige tijd met distill. De ervaringen van Danielle herken ik sterk en daarom schrijf ik vanaf nu vanuit Danielle, maar kun je ook mijzelf lezen.\nQuarto, volop in de belangstelling nu, biedt de belofte van een cross-platform, overall format, open source publicatietool gebaseerd op pandoc. Geïntrigeerd besloot ik er een tijdje mee te spelen, en uiteindelijk nam ik de beslissing om mijn blog over te zetten van distill naar quarto. Deze post schetst mijn proces.\n(Ik ben een beetje nerveus: een blog overzetten betekent vaak dingen opnieuw programmeren. Zal het werken? Zal alles reproduceerbaar blijken te zijn? Ik hoop het…)"
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#aan-de-slag",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#aan-de-slag",
    "title": "Van distill naar quarto?",
    "section": "Aan de slag",
    "text": "Aan de slag\nHet allereerste wat ik doe is Alison Hill’s prachtige We don’t talk about quarto lezen. Als je een R markdown gebruiker bent die overweegt de sprong naar quarto te maken en haar samenvatting nog niet gelezen hebt, zul je er geen spijt van krijgen dat nu wel te doen. Het is een mooi overzicht op hoog niveau. Ik raad ook Nick Tierney’s notities aan over het maken van de overstap, die zijn ook erg behulpzaam. (Zelf dus ook Danielle Navarro’s blog goed gelezen en bewerkt en de presentatie van Mine Cetinkaya-Rundel gaf interessant.\nNa het eigen maken van deze achtergrondinformatie, ga ik naar de get started pagina op de quarto website om het installatiebestand te downloaden.\nNu ik quarto geïnstalleerd heb, ben ik in staat om het te gebruiken om een blog te maken. Mijn oude distill blog bestaat in een project map die ik Harrie's Hoekje heb genoemd, dus ik besluit de quarto versie te maken en de map HHquarto te maken.\nEr is een pagina op de quarto website die je door het proces leidt voor creating a blog blog, die ik plichtsgetrouw volg. Vanaf de terminal (Power-shell voor Windows) gebruik ik het quarto create-project commando, en er worden verschillende bestanden aangemaakt:\nquarto create-project quarto-blog --type website:blog\nCreating project at /home/danielle/GitHub/sites/quarto-blog:\n  - Created _quarto.yml\n  - Created index.qmd\n  - Created posts/welcome/index.qmd\n  - Created posts/post-with-code/index.qmd\n  - Created about.qmd\n  - Created styles.css\n  - Created posts/_metadata.yml\nKomende van een R markdown achtergrond, is dit erg vertrouwd:\n\nDe bestanden met een .qmd extensie zijn de quarto markdown documenten. Deze bevatten broncode voor de blog posts (de twee bestanden in de posts map), de home page (het index.qmd bestand in de project root map) en een standalone “over mij” pagina voor de blog (het about.qmd bestand).\nDe bestanden met een .yml extensie zijn de YAML bestanden die gebruikt worden om het blog te configureren. Dit valt in eerste instantie niet op, maar het feit dat het er twee zijn is wel belangrijk. Het _quarto.yml bestand wordt gebruikt voor instellingen die voor de hele site gelden, maar je zult vaak instellingen willen configureren die alleen voor je blog posts gelden. Deze kunnen worden ingesteld door het posts/_metadata.yml bestand te bewerken.\nHet styles.css bestand kan gebruikt worden om CSS regels op te geven die voor de hele site gelden. Ik zal later meer vertellen over stijlen."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#blog-posts-renderen",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#blog-posts-renderen",
    "title": "Van distill naar quarto?",
    "section": "Blog posts renderen",
    "text": "Blog posts renderen\nEr zijn verschillende manieren om met quarto te werken. Bijvoorbeeld, later in de post zal ik het hebben over de quarto commando-regel interface die je toestaat om met quarto te werken zonder door R of RStudio te gaan. Echter, als ik begin probeer ik de dingen eenvoudig te houden en ga ik voor de optie die mij het meest vertrouwd is: Ik gebruik RStudio.\nOm dit te doen, is het handig om een RStudio project te hebben voor mijn blog. Met behulp van het RStudio bestandsmenu, maak ik een nieuw project vanuit een bestaande directory (d.w.z. mijn HHquarto folder), die het HHquarto.Rproj bestand en andere infrastructuur levert die nodig is om met mijn nieuwe quarto blog te werken als een RStudio project. Als dat eenmaal gedaan is, kan ik een quarto bestand openen in de RStudio editor en zie ik een vertrouwd ogende interface:\n\n\n\n\n\nEen blog post geschreven in quarto markdown open in de RStudio editor. Merk op dat op de plaats waar je normaal de ‘Knit’ knop zou verwachten voor een R markdown document, er een ‘Render’ knop is. Die heeft dezelfde functie en is toegewezen aan dezelfde sneltoetsen als de knop ’Knit\n\n\n\n\nVan hieruit kan ik op de “Render” knop klikken om een enkele pagina te renderen, of ik kan naar het RStudio menu gaan en de “Render Project” optie selecteren om de hele site te bouwen. Standaard wordt de blog gebouwd in de _site map."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#aan-het-spelen",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#aan-het-spelen",
    "title": "Van distill naar quarto?",
    "section": "Aan het spelen",
    "text": "Aan het spelen\nVooruitgang! Ik maak vooruitgang. Maar voordat ik andere praktische dingen ga doen, heb ik eerst nog wat belangrijke zaken te regelen: wat rondspelen. Doelloos de functionaliteit van een nieuw gereedschap verkennen is altijd leuk en ik vind het een goede manier om mezelf met iets vertrouwd te maken. Ik ben al redelijk vertrouwd met R markdown en ik veronderstel dat de meeste lezers van deze post dat ook zullen zijn, dus voor het grootste deel zijn er geen verrassingen. Toch is het de moeite waard om mezelf de gebruikelijke vragen te stellen:\n\nKan ik voetnoten toevoegen? 1\nKunnen ze genest worden? 2\nKan ik commentaar in de kantlijn toevoegen?\n\n\n\nA comment in the margin\nAls je kijkt naar de quarto article layout documentation, ontdek ik enkele aardige kenmerken. Je kunt de :::{.class} notatie om een deel van de ‘CSS class’ toe te passen op de output, zoals hier:\n:::{.column-margin}\nA comment in the margin\n:::\nDe .column-margin code voor tekst in de kantlijn, maar er zijn verschillende andere commando’s die handig zijn als je plaatjes wilt afbeelden in de blog posts:\n\n.column-body overspant de gebruikelijke breedte van de post\n.column-body-outset strekt zich iets uit buiten de gebruikelijke breedte\n.column-page overspant de hele pagina (inclusief beide kantlijnen)\n.column-screen overspant de breedte van het scherm\n.column-screen-inset code stopt net voor de volledige schermbreedte\n\nJe kunt deze instellen binnen een chunk-optie. Bijvoorbeeld, als je column: margin als chunk-optie instelt, krijgt de uitvoer een .column-margin code en de resulterende figuur verschijnt in de marge in plaats van onder de code. Op dezelfde manier zal het instellen van column: screen als chunk optie de uitvoer een .column-screen klasse geven en de uitvoer zal de volledige breedte beslaan. Hier is een eenvoudig voorbeeld, gebaseerd op het voorbeeld in de quarto documentatie:\n\nlibrary(leaflet)\n\nWarning: package 'leaflet' was built under R version 4.1.3\n\nleaflet() %>%\n  addTiles() %>%\n  addMarkers(\n    lng=151.22251, \n    lat=-33.85943, \n    label=\"Mrs Macquarie's Chair\"\n  ) %>% \n  addProviderTiles(providers$CartoDB.Positron)\n\n\n\n\n\n\nIk moet toegeven, ik ben al een beetje verliefd."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#opmerkingen-over-de-yaml-koppen",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#opmerkingen-over-de-yaml-koppen",
    "title": "Van distill naar quarto?",
    "section": "Opmerkingen over de YAML koppen",
    "text": "Opmerkingen over de YAML koppen\nDe YAML koppen die gebruikt worden voor blogposts zijn een beetje anders in quarto dan hun equivalenten in distill waren, en het kost me even om uit te zoeken hoe ik de YAML headers van mijn oude R markdown posts moet aanpassen voor de nieuwe quarto blog. Hier is een kort overzicht. Ten eerste, sommige velden vereisen bijna geen veranderingen:\n\nHet title veld is ongewijzigd. Dat was een makkelijke!\nHet date veld is in essentie ongewijzigd, behalve het feit dat er een kleine bug lijkt te zijn in datum parsing voor blogs waarvan ik zeker weet dat die snel zal verdwijnen. Als je ISO-8601 datumformaten gebruikt zoals date: \"2022-04-20\" zal het goed gaan. 3\nHet categorieën veld neemt een lijst van waarden, die (denk ik?) niet anders is dan hoe het er eerder uitzag. Om eerlijk te zijn weet ik het niet meer omdat mijn oude blog ze niet gebruikte. Ik ben er nu mee begonnen.\n\nAndere veranderingen zijn kunstmatig: - Het description veld dat ik gebruikte op mijn oude blog doet nog steeds wat het deed: het geeft een preview tekst op de listing pagina en een samenvatting bovenaan het bestand. Er is echter ook een subtitle veld dat je voor dit doel kunt gebruiken, en de uitvoer heeft hetzelfde uiterlijk en veld als mijn oude beschrijvingen, dus ik heb besloten om al mijn oude beschrijvingsvelden om te zetten naar subtitle vermeldingen. - Om een voorbeeldafbeelding te specificeren die bij een blog post hoort, gebruik je het image veld (bijv. iets als image: thumbnail.jpg) in plaats van het preview veld uit distill. - Er is een nieuw licence veld dat het creative_commons veld uit distill vervangt. Onderaan deze post zie je een “Reuse” appendix die linkt naar een licentie bestand. Om dit te genereren, heb ik een license: \"CC BY\" regel opgenomen in de YAML.\nAndere veranderingen gaan dieper:\n\nIn distill is het mogelijk om het author veld in detail te specificeren, wat de academische conventie weerspiegelt om een auteurs affiliatie te vermelden naast hun werkgever, digitale identificeerder (‘orcid record’) en contactdetails. Quarto ondersteunt dit ook, hoewel de tags iets veranderd zijn: orcid_id is nu orcid, bijvoorbeeld. Een voorbeeld hiervan wordt verderop in dit artikel getoond.\n\nHet specificeren van de inhoudsopgave is iets anders. Net als in distill, kun je de inhoudsopgave aanzetten door toc: true als regel in de YAML header op te nemen, en het toc-depth veld in te stellen om te bepalen hoe gedetailleerd de inhoudsopgave moet zijn. Maar er zijn nieuwe opties. U kunt de tekst aanpassen die boven de inhoudsopgave verschijnt en de plaats waar deze verschijnt. Ik besluit om saai te zijn en met een aantal standaard opties te gaan: toc-title: Inhoudsopgave en toc-location: left.\nEen functie in distill die ik leuk vind is dat het een citaat genereert voor elke post. Je kunt dat ook doen in quarto, en je zult onderaan deze post zien dat ik die functie hier heb gebruikt. Maar quarto beheert dit op een andere manier dan distill, en gebruikt een YAML versie van citation style language (CSL) formattering om de citatie te definiëren. Om te zien hoe het werkt, kun je de quarto pages on citations en creating citable articles doorlezen. Het is iets uitgebreider dan de distill versie, maar veel flexibeler. Voor deze blog is het zo simpel als citation: true in de YAML, maar het kan uitgebreider en geschikt voor elk academisch citatiepatroon dat je maar wilt."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#een-nieuwe-blog-maken",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#een-nieuwe-blog-maken",
    "title": "Van distill naar quarto?",
    "section": "Een nieuwe blog maken",
    "text": "Een nieuwe blog maken\nOké. Tijd om aan de slag te gaan en de standaard-blog omvormen tot een quarto-versie van mijn distill-blog. Mijn eerste stap is het verwijderen van de twee posts die bij de standaard-blog zaten, en dan deze aanmaken.\nEen map met een index.qmd bestand is het absolute minimum dat ik nodig heb om aan de slag te gaan met een nieuwe post. Ik veronderstel dat er andere manieren zijn om dit te doen, maar wat ik eigenlijk doe is het aanmaken van de map en een leeg bestand vanaf de terminal (om redenen die alleen God kent)\nmkdir posts/2022-04-20_porting-to-quarto\ntouch posts/2022-04-20_porting-to-quarto/index.qmd\nOm eerlijk te zijn, het gebruik van de terminal was overkill. Wat ik in plaats daarvan had kunnen doen, als ik RStudio had bekeken in plaats van de terminal, is de optie “New File” gebruiken in het bestandsmenu en dan de optie “Quarto Doc” kiezen. Dat maakt een nieuw titelloos quarto document dat je kunt opslaan op de juiste locatie."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#yaml-instellingen-overnemen",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#yaml-instellingen-overnemen",
    "title": "Van distill naar quarto?",
    "section": "YAML instellingen overnemen",
    "text": "YAML instellingen overnemen\nEen handige functie in quarto websites is dat YAML velden worden overgeërfd. Bijvoorbeeld, deze post heeft zijn eigen YAML header die de volgende – en alleen de volgende – velden bevat:\ntitle: \"Een distill blog overzetten naar quarto\"\nsubtitle: | \n  Net als Danielle Navarro recent heb ik mijn blog van distill naar quarto overgezet. Ik heb haar notities gevolgd en her en der aangepast. Ook voor mij lijkt dit op een veelbelovende zet en in ieder geval is het een interessanten test op het gebied van reproduceerbaar. \n  to be an interesting reproducibility test\nauthor: Danielle Navarro. bewerking Harrie Jonkman   \ndate: \"2022-05-31\"\ncategories: [Quarto, Blogging, Reproducibility]\nimage: \"img/preview.jpg\"\nDat is een beetje eigenaardig, want veel van de metadata die nodig zijn om deze post te specificeren ontbreken. De reden dat het ontbreekt is dat ik een aantal velden in het posts/_metadata.yml bestand heb geplaatst. Deze velden worden geërfd door elke blog post. Dit is de volledige inhoud van mijn post metadata bestand:\n# Bevries computer outputs\nfreeze: true\n\n# Schakel banner stijl titelblokken in\ntitle-block-banner: true\n\n# Activeer bijlage CC-licentie\nlicense: \"CC BY\"\n\n# Default voor inhoudsopgave\ntoc: true\ntoc-title: Table of contents\ntoc-location: left\n\n# Default knitr opties\nexecute:\n  echo: true\n  message: true\n  warning: true\n\n# Default author\nauthor:\n  - name: Danielle Navarro\n    url: https://djnavarro.net\n    affiliation: Voltron Data\n    affiliation-url: https://voltrondata.com\n    orcid: 0000-0001-7648-6578\n\n# Default voor velden citeren\ncitation: true\n\n\nDe bevries optie is bijzonder makkelijk in de context van bloggen. Ik adviseer deze documentatiepagina hierover te lezen!\nDat verklaart een hoop, maar als je goed kijkt zul je je realiseren dat er niets in deze velden staat dat het uitvoerformaat specificeert! In Rmarkdown zou ik hiervoor een output veld hebben opgenomen, maar in quarto heet het relevante veld format. Omdat de output voor de hele site geldt, staat dat deel van de YAML header in het _quarto.yml bestand. De relevante regels van dat bestand zijn:\nformat:\n  html:\n    theme: ember.scss\n    css: styles.css\nIk kom hier later op terug. Voor nu is het genoeg om te erkennen dat dit aangeeft dat alle pagina’s op deze site moeten worden gerenderd naar HTML documenten, en met behulp van de ember.scss en styles.css bestanden de blog stijl te specificeren."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#converteren-van-mijn-oude-posts",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#converteren-van-mijn-oude-posts",
    "title": "Van distill naar quarto?",
    "section": "Converteren van mijn oude posts",
    "text": "Converteren van mijn oude posts\nDe tijd is aangebroken voor een beetje handwerk. Hoewel quarto compatibel is met de meeste bestaande R markdown en ik er waarschijnlijk mee weg kan komen om ze ongemoeid te laten, verwacht ik dat ik op de langere termijn naar andere talen zal overstappen, dus het spreekt me aan om nu van de gelegenheid gebruik te maken om alles over te zetten naar quarto. Het hernoemen van alle index.Rmd bestanden naar index.qmd bestanden is eenvoudig genoeg en kan programmatisch worden gedaan. Maar de meeste van mijn bewerkingen vereisen een kleine hoeveelheid handmatig knutselwerk bij elke post. Niet veel, want het is vooral een kwestie van het hernoemen van een paar YAML velden. Gezien het feit dat er maar een stuk of 20 posts overgezet moeten worden, besluit ik dat het gemakkelijker is om het handmatig te doen dan om te proberen een script te schrijven om de taak te automatiseren. Ik heb het in een middag gedaan (Nou, Danielle dan ben je sneller dan mij. Mij kostte het wel enkele dagen)."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#styleren-van-de-nieuwe-blog",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#styleren-van-de-nieuwe-blog",
    "title": "Van distill naar quarto?",
    "section": "Styleren van de nieuwe blog",
    "text": "Styleren van de nieuwe blog\nTot nu toe heeft het gebruik van quarto erg “distill-achtig” gevoeld. De structuur van de blog voelt vertrouwd aan, de YAML koppen zijn vergelijkbaar in de geest (hoewel verschillend in de details), enzovoort. Als het aankomt op het aanpassen van het uiterlijk van de blog, lijkt het helemaal niet op distill, en voelt het meer als eenvoudige R markdown-sites. Quarto websites zijn bootstrap gebaseerd, en zoals besproken op de quarto theming page, komen ze met dezelfde thema’s die je misschien kent van R markdown. Als je bijvoorbeeld beslist, zoals ik deed, dat je een heel eenvoudig wit thema wil, dan zou je het “litera” thema kunnen kiezen. Om dit op je blog toe te passen, hoef je er alleen maar voor te zorgen dat je _quarto.yml bestand de volgende regels bevat:\nformat:\n  html:\n    theme: litera\n    css: styles.css\nDit zorgt ervoor dat de uitvoer zal worden weergegeven als HTML objecten, gebruikmakend van het litera bootswatch thema en het toepassen van aangepaste CSS regels die je toevoegt in het styles.css bestand.\nEen erg leuke eigenschap van quarto, als je SASS kunt gebruiken om stijlen te definiëren en iets weet over hoe de bootstrap SASS bestanden zijn georganiseerd,4 is dat het je toestaat je eigen .scss bestand te schrijven om je blog thema preciezer te definiëren, waarbij je toegang hebt tot bootstrap parameters enzovoort. Ik zou je sterk aanraden om eerst meer te lezen over het quarto theming system voordat je zelf met dit aspect aan de slag gaat, maar als je meer kennis (of meer domheid) hebt dan ik, dan lees je hier hoe ik mijn blog heb opgezet. Ten eerste, in plaats van te verwijzen naar het litera thema, verwijst de YAML in mijn _quarto.yml bestand naar mijn eigen aangepaste .scss bestand:\nformat:\n  html:\n    theme: ember.scss\n    css: styles.css\nDe inhoud van de ember.scss file ziet er (bij Danielle) als volgt uit:\n/*-- scss:defaults --*/\n\n// use litera as the base\n$theme: \"litera\" !default;\n\n// import google fonts\n@import 'https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap';\n@import 'https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap';\n\n// use Atkinson Hyperlegible font if available\n$font-family-sans-serif:  \"Atkinson Hyperlegible\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\" !default;\n\n/*-- scss:rules --*/\n\n// litera is serif by default: revert to san-serif\np {\n  font-family: $font-family-sans-serif;\n}\nZoals je kunt zien, doe ik op dit moment niet veel anders dan wat kleine aanpassingen aan het litera thema, maar er is potentieel zo veel meer mee te doen dan ik heb gedaan bij het opzetten van deze blog. Ik ben van plan om hier later meer aan te sleutelen!"
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#een-rss-feed-toevoegen",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#een-rss-feed-toevoegen",
    "title": "Van distill naar quarto?",
    "section": "Een RSS feed toevoegen",
    "text": "Een RSS feed toevoegen\nMijn oude distill blog had een RSS feed, en hoewel ik erken dat het steeds meer een esoterische functie is die de meeste mensen niet gebruiken, heb ik een voorliefde voor RSS. Quarto ondersteunt dit, maar het is niet standaard ingeschakeld. Wat ik moet doen is de YAML aanpassen in het index.qmd bestand dat correspondeert met de homepage, want dat is waar ik mijn primaire lijst van berichten heb. Daarin zie ik een listing veld. Alles wat ik hoef te doen is feed: true eronder te zetten en er is nu een RSS feed voor de site:\ntitle: \"Notes from a data witch\"\nsubtitle: A data science blog by Danielle Navarro\nlisting:\n  feed: true\n  contents: posts\nDe quarto sectie over feeds geeft meer informatie hierover."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#uitzetten-van-de-site",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#uitzetten-van-de-site",
    "title": "Van distill naar quarto?",
    "section": "Uitzetten van de site",
    "text": "Uitzetten van de site\nHet voorbereiden van de site om deze uit te zetten is relatief pijnloos. Ik vond het nuttig om de quarto website optie pagina te lezen voordat ik dit deed, omdat het een heleboel instellingen noemt om aan te sleutelen, meestal in het _quarto.yml bestand. Ik kies er bijvoorbeeld voor om de navigatiebalk aan te passen, de voorbeeldafbeeldingen van de sociale media, enzovoort. Uiteindelijk bereik ik het punt waar ik tevreden ben en ga ik verder met de implementatie.\nGelukkig valt er over het uitzetproces zelf niet veel te zeggen. De quarto deployment pagina bespreekt verschillende opties voor hoe je dit kunt doen. De meeste van mijn websites worden uitgerold via GitHub Pages of via Netlify. Dit is een Netlify site, dus ik volg de instructies daar en alles gaat soepel. Dit brengt me echter wel bij een ander onderwerp…"
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#netlify-herleidt",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#netlify-herleidt",
    "title": "Van distill naar quarto?",
    "section": "Netlify herleidt",
    "text": "Netlify herleidt\nIk heb mijn blog op een bepaalde manier gestructureerd. Net als de standaard quarto blog, staan alle posts in de posts map, en ze hebben een systematische naam: ze hebben eerst een ISO-8601 geformatteerde datum, en dan een semantische slug. Dus de volledige URL voor deze blog post is:\nblog.djnavarro.net/posts/2022-04-20_porting-to-quarto\nDat is handig voor archiveringsdoeleinden en om alles netjes geordend te houden in mijn projectmap, maar het is ook een beetje onhandig voor het delen van links. In de praktijk is het “posts” gedeelte een beetje overbodig, en ik ga nooit twee keer dezelfde slug gebruiken, dus is het handig om het zo in te stellen dat er ook een kortere URL is voor de post,\nblog.djnavarro.net/porting-to-quarto\nen dat deze korte URL automatisch naar de langere herleidt.\nAangezien ik van plan ben om deze blog uit te rollen naar Netlify, moet ik ervoor zorgen dat wanneer de site gebouwd wordt, er een _redirects bestand wordt aangemaakt in de site map. Dit bestand moet één regel per redirect bevatten, met als eerste het “redirect from” pad, gevolgd door het “redirect to” pad. Hier is hoe die regel eruit ziet voor deze post:\n/porting-to-quarto /posts/2022-04-20_porting-to-quarto\nIk ben niet van plan om deze regels handmatig toe te voegen, dus wat ik in plaats daarvan doe is een R chunk toevoegen aan het index.qmd bestand dat correspondeert met de startpagina van de blog, met de volgende code:\n# lijst namen van de post folders\nposts <- list.dirs(\n  path = here::here(\"posts\"),\n  full.names = FALSE,\n  recursive = FALSE\n)\n\n# extraheer de slugs\nslugs <- gsub(\"^.*_\", \"\", posts)\n\n# regels om een netlify _redirect file toe te voegen\nredirects <- paste0(\"/\", slugs, \" \", \"/posts/\", posts)\n\n# Schrijf de _redirect file\nwriteLines(redirects, here::here(\"_site\", \"_redirects\"))\nElke keer als deze site herbouwd wordt – wat meestal inhoudt dat de home page herbouwd wordt omdat die de lijst met berichten bevat – wordt het _redirects bestand vernieuwd. Er is misschien een schonere manier, maar dit werkt."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#quarto-cli",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#quarto-cli",
    "title": "Van distill naar quarto?",
    "section": "The quarto CLI",
    "text": "The quarto CLI\nIets wat ik eerder vergat te melden. Ongeveer halverwege het proces van het aanpassen van mijn oude posts om ze geschikt te maken voor de quarto-blog, heb ik besloten om RStudio niet langer te gebruiken voor de rendering, en heb ik wat tijd besteed om mezelf vertrouwd te maken met de quarto-command line interface. Ik heb nog geen specifieke beslissingen genomen over hoe mijn lange termijn workflow met quarto eruit gaat zien, maar ik vond het wel nuttig om een gevoel te krijgen voor het concept van quarto als een standalone installatie. Ik ga hier niet in detail treden, maar even kort: aan de terminal kan ik zien dat ik een aantal help opties heb,\n\nquarto help\n\n  Usage:   quarto \n  Version: 0.9.282\n                  \n\n  Description:\n\n    Quarto CLI\n\n  Options:\n\n    -h, --help     - Show this help.                            \n    -V, --version  - Show the version number for this program.  \n\n  Commands:\n\n    render          [input] [args...]  - Render input file(s) to various document types.                                                \n    serve           [input]            - Serve an interactive document.                                                                 \n    create-project  [dir]              - Create a project for rendering multiple documents                                              \n    preview         [file] [args...]   - Render and preview a Quarto document or website project. Automatically reloads the browser when\n    convert         [input]            - Convert documents to alternate representations.                                                \n    capabilities                       - Query for current capabilities (output formats, engines, kernels etc.)                         \n    check           [target]           - Check and verify correct functioning of Quarto installation and computation engines.           \n    inspect         [path]             - Inspect a Quarto project or input path. Inspecting a project returns its config and engines.   \n    tools           [command] [tool]   - Manage the installation, update, and uninstallation of useful tools.                           \n    help            [command]          - Show this help or the help of a sub-command.\n    \nVan daaruit kan ik de help documentatie voor het quarto render commando bekijken door het volgende in te typen,\n\nquarto render help\n\nenzovoort. Het doorbladeren van deze documentatie naast alle uitstekende inhoud op de quarto-website is een handige manier om extra opties te vinden. Als ik de huidige post zou willen renderen, en mijn terminal bevond zich momenteel in de hoofdmap van het project (d.w.z. mijn quarto-blog map), dan kan ik het als volgt renderen:\n\nquarto render posts/2022-04-20_porting-to-quarto/index.qmd\n\nDe mogelijkheid om dit netjes vanaf de terminal te doen lijkt een handige eigenschap van quarto, hoewel ik moet toegeven dat ik nog niet zeker weet hoe ik het zal gebruiken."
  },
  {
    "objectID": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#epiloog",
    "href": "posts/2022-05-31-van-distill-naar-quarto/van-distill-naar-quarto.html#epiloog",
    "title": "Van distill naar quarto?",
    "section": "Epiloog",
    "text": "Epiloog\nToen ik aan dit proces begon was ik er niet helemaal zeker van of ik door zou zetten en de blog daadwerkelijk zou overschakelen naar quarto. De distill-blog heeft me het afgelopen tijd goed gediend en ik hou er niet van om dingen te repareren als ze niet kapot zijn. Hoe langer ik echter met quarto speelde, hoe meer het me beviel, en het proces was veel minder pijnlijk dan ik vreesde dat het zou zijn. Ik heb het gevoel dat het de dingen heeft behouden die ik leuk vind aan distill, maar deze netjes heeft geïntegreerd met andere functies (bijv. de bootstrap grid!) die ik echt miste in distill. Zo nu en dan kom ik wat kleine eigenaardigheden tegen waar sommige ruwe kantjes van quarto nog zichtbaar zijn – het is nog steeds een nieuwe tool – maar ik geniet er erg van.\nMaar hier is Harrie zelf weer. Ik twijfel nog. Vooralsnog blijf ik met distill mijn blog schrijven, maar zal wel nog wat meer meer quarto oefenen."
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html",
    "title": "ggplot stap voor stap",
    "section": "",
    "text": "De afgelopen maand toch nog weer eens naar datavisualisatie gekeken en hoe je dat met R het beste kunt doen. Twee boeken nogeens gelezen hierover. Allereerst het boek van Rob Kabacoff Data Visualization with R. Het is een handige introducte op ggploten vooral een handige tutorial voor het visualiseren van data met R. Daarnaast het boek van Clause Wilke Fundamentals of Data Visualization dat meer een algemene reflectie is op data visualisatie. Het ga je op verschillende manieren van data naar visualisatie, wat zijn de onderliggende principes en waaraan moeten we bij datavisualisatie vooral denken. Toch heb ik de afgelopen maand vooral veel geleerd van Cédric Scherer. Ik zag dat hij op de conferentie van R binnenkort een inleiding geeft op het onderwerp datavisualisatie en zo zag ik via zijn Github site verschillend materiaal over datavisualisatie. Mooie en duidelijke inleidingen en twee ervan heb ik in het Nederlands overgezet. Hier vind je in ieder geval een algemene inleiding op ggplot. zie"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#cédrics-inleiding",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#cédrics-inleiding",
    "title": "ggplot stap voor stap",
    "section": "Cédrics inleiding",
    "text": "Cédrics inleiding\nTerug in 2016, moest ik (Cédric vanaf hier) mijn PhD inleidende lezing voorbereiden en begon ik ggplot2 te gebruiken om mijn gegevens te visualiseren. Ik hield nooit van de syntaxis en stijl van basisplots in R, dus ik was snel verliefd op ggplot. Vooral handig was zijn ‘faceting utility’. Maar omdat ik weinig tijd had, plotte ik deze figuren met vallen en opstaan en met behulp van veel googlen. De bron waar ik altijd op terugkwam was een blog post genaamd Beautiful plotting in R: A ggplot2 cheatsheet by Zev Ross, voor het laatst bijgewerkt in januari 2016.\nNa het geven van de lezing, die een aantal fatsoenlijke plots bevatte dankzij de blog post, besloot ik om deze tutorial stap-voor-stap door te nemen. Ik heb er zoveel van geleerd en ben direct begonnen met het aanpassen van de codes. In de loop van de tijd heb ik extra code snippets, grafiektypes en bronnen toegevoegd.\nOmdat het blogartikel van Zev Ross al enkele jaren niet meer werd bijgewerkt en dit stap voor stap een unieke versie van een tutorial werd, besloot ik om de bijgewerkte versie op mijn GitHub te hosten. Nu vindt het zijn juiste plaats op deze homepage! (Plus ik heb een groot aantal updates toegevoegd-om er maar een paar te noemen: - De fantastische patchwork, ggtext en ggforce pakketten.\n- Hoe om te gaan met aangepaste lettertypen en kleuren.\n- Een verzameling van R pakketten op maat gemaakt om interactieve grafieken te maken.\n- En verschillende andere soorten grafieken, waaronder taartdiagrammen (omdat iedereen van taartdiagrammen houdt.\n\n\n\nGrafieken die we gaan maken\n\n\nGrote veranderingen die ik heb aangebracht:\n\nde R-stijlgids volgen (bv. van Hadley Wickham, Google of de stijlgidsen van de Coding Club),\n\nom de stijl en esthetiek van plots te veranderen (bijv. as-titels, legenda’s en mooie kleuren voor alle plots, niet alleen sommige),\n\nom een bijgewerkte versie te hebben die de veranderingen in ggplot2 bijhoudt (huidige versie: 3.3.2),\n\nom gegevensimport aan te passen (GitHub bron),\n\nom extra tips toe te voegen over een breed scala aan onderwerpen, waaronder bijvoorbeeld grafiekkeuze, kleurenpaletten, aanpassen van titels, toevoegen van lijnen, aanpassen van legenda’s, annotaties met labels, pijlen en boxen, multi-panel plots, interactieve visualisaties, …"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#voorbereiding",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#voorbereiding",
    "title": "ggplot stap voor stap",
    "section": "Voorbereiding",
    "text": "Voorbereiding\n\nU kunt het Rmarkdown-script met de code die in deze blogpost is uitgevoerd hier vinden.\n\nU kunt ook het R script met alleen de code hier downloaden.\n\nU dient de volgende pakketten te installeren om de volledige tutorial te kunnen uitvoeren:\n\n{ggplot2}, onderdeel van de {tidyverse} pakketverzameling\n\n{tidyverse} pakket verzameling, namelijk\n\n{dplyr} voor het ordenen van gegevens\n\n{tibble} voor moderne dataframes\n\n{tidyr} voor het opschonen van gegevens\n\n{forcats} voor het hanteren van factoren\n\n{colorspace} voor het manipuleren van kleuren\n\n{corrr} voor het berekenen van correlatiematrices\n\n{cowplot} voor het samenstellen van ggplots\n\n{ggdark} voor het thematiseren en inverteren van kleuren\n\n{ggforce} voor sina plots en andere coole dingen\n\n{ggrepel} voor mooie tekstlabels\n\n{ggridges} voor ridge plots\n\n{ggsci} voor mooie kleurenpaletten\n\n{ggtext} voor geavanceerde tekst rendering\n\n{ggthemes} voor extra thema’s\n\n{grid} voor het maken van grafische objecten\n\n{gridExtra} voor extra functies voor “raster”-grafieken\n{patchwork} voor multi-paneel plots\n\n{rcartocolor} voor geweldige kleurenpaletten\n\n{scico} voor perceptuele uniforme paletten\n\n{showtext} voor aangepaste lettertypen\n\n{shiny} voor interactieve apps\n\neen aantal pakketten voor interactieve visualisaties\n- {charter}\n- {echarts4r}\n- {ggiraph}\n- {highcharter}\n- {plotly}\n\n# Pakketten wel installeren als je ze niet hebt\n# Dat kan goed met Pacman, dat moet wel geinstalleerd zijn\npacman::p_load(\n  tidyverse, \n  akima,\n  colorspace, \n  corrr,  \n  cowplot,\n  ggdark, \n  ggforce,\n  ggiraph,\n  ggrepel, \n  ggridges, \n  ggsci,\n  ggtext, \n  ggthemes, \n  grid, \n  gridExtra,\n  hrbrthemes,\n  patchwork,\n  rcartocolor, \n  scico, showtext, \n  shiny,\n  plotly, \n  highcharter, \n  echarts4r)\n\n(Om pedagogische redenen en als mensen naar een plot springen, laadt Cédric het benodigde pakket naast {ggplot2} in de betreffende sectie)."
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#de-dataset",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#de-dataset",
    "title": "ggplot stap voor stap",
    "section": "De dataset",
    "text": "De dataset\nDe studie die we gebruiken is National Morbidity and Mortality Air Pollution Study (NMMAPS). Om de plots hanteerbaar te maken, beperken we de gegevens tot Chicago en 1997-2000. Voor meer details over deze dataset, raadpleeg Roger Peng’s boek Statistical Methods in Environmental Epidemiology with R. Je kunt de gegevens die we in deze tutorial gebruiken hier downloaden (maar dat hoeft niet).\nWe kunnen de data importeren in onze R sessie, bijvoorbeeld met read_csv() uit het readr pakket. Om later bij de gegevens te kunnen, slaan we ze op in een variabele genaamd chic met behulp van de toewijzingspijl: <-.\n\nchic <- readr::read_csv(\"https://raw.githubusercontent.com/z3tt/ggplot-courses/main/data/chicago-nmmaps-custom.csv\")\n\nRows: 1461 Columns: 11\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr  (3): city, season, month\ndbl  (7): temp, o3, dewpoint, pm10, yday, month_numeric, year\ndate (1): date\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nDe :: wordt naamruimte genoemd en kan worden gebruikt om toegang te krijgen tot een functie zonder het pakket te laden. Hier zou je ook library(readr) eerst kunnen uitvoeren en daarna chic <- read_csv(…).\n\nLaten we zien hoe de dataset eruit ziet.\n\ntibble::glimpse(chic)\n\nRows: 1,461\nColumns: 11\n$ city          <chr> \"chic\", \"chic\", \"chic\", \"chic\", \"chic\", \"chic\", \"chic\", ~\n$ date          <date> 1997-01-01, 1997-01-02, 1997-01-03, 1997-01-04, 1997-01~\n$ temp          <dbl> 36.0, 45.0, 40.0, 51.5, 27.0, 17.0, 16.0, 19.0, 26.0, 16~\n$ o3            <dbl> 5.659256, 5.525417, 6.288548, 7.537758, 20.760798, 14.94~\n$ dewpoint      <dbl> 37.500, 47.250, 38.000, 45.500, 11.250, 5.750, 7.000, 17~\n$ pm10          <dbl> 13.052268, 41.948600, 27.041751, 25.072573, 15.343121, 9~\n$ season        <chr> \"Winter\", \"Winter\", \"Winter\", \"Winter\", \"Winter\", \"Winte~\n$ yday          <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1~\n$ month         <chr> \"Jan\", \"Jan\", \"Jan\", \"Jan\", \"Jan\", \"Jan\", \"Jan\", \"Jan\", ~\n$ month_numeric <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,~\n$ year          <dbl> 1997, 1997, 1997, 1997, 1997, 1997, 1997, 1997, 1997, 19~\n\n\n\nhead(chic, 10)\n\n# A tibble: 10 x 11\n   city  date        temp    o3 dewpoint  pm10 season  yday month month_~1  year\n   <chr> <date>     <dbl> <dbl>    <dbl> <dbl> <chr>  <dbl> <chr>    <dbl> <dbl>\n 1 chic  1997-01-01  36    5.66    37.5  13.1  Winter     1 Jan          1  1997\n 2 chic  1997-01-02  45    5.53    47.2  41.9  Winter     2 Jan          1  1997\n 3 chic  1997-01-03  40    6.29    38    27.0  Winter     3 Jan          1  1997\n 4 chic  1997-01-04  51.5  7.54    45.5  25.1  Winter     4 Jan          1  1997\n 5 chic  1997-01-05  27   20.8     11.2  15.3  Winter     5 Jan          1  1997\n 6 chic  1997-01-06  17   14.9      5.75  9.36 Winter     6 Jan          1  1997\n 7 chic  1997-01-07  16   11.9      7    20.2  Winter     7 Jan          1  1997\n 8 chic  1997-01-08  19    8.68    17.8  33.1  Winter     8 Jan          1  1997\n 9 chic  1997-01-09  26   13.4     24    12.1  Winter     9 Jan          1  1997\n10 chic  1997-01-10  16   10.4      5.38 24.8  Winter    10 Jan          1  1997\n# ... with abbreviated variable name 1: month_numeric"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#het-ggplot2-pakket",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#het-ggplot2-pakket",
    "title": "ggplot stap voor stap",
    "section": "Het ggplot2 pakket",
    "text": "Het ggplot2 pakket\n\nggplot2 is a systeem voor het maken van grafieken gebaseerd op The Grammar of Graphics. Je levert de gegevens aan, vertelt ggplot2 hoe variabelen af te beelden met een bepaalde esthetiek, welke grafische technieken te gebruiken en het zorgt voor de details.\n\nEen ggplot is opgebouwd uit een paar basis elementen:\n\nData: De ruwe data die je wil plotten.\n\n**Geometries* geom_: De geometrische vormen die de gegevens zullen weergeven.\n\nAesthetics aes(): Esthetica van de geometrische en statistische objecten, zoals positie, kleur, grootte, vorm en transparantie.\n\nScales scale_: Kaarten tussen de gegevens en de esthetische dimensies, zoals gegevensbereik naar plotbreedte of factorwaarden naar kleuren.\n\nStatistical transformations stat_: Statistische samenvattingen van de gegevens, zoals kwantielen, passende curven, en sommen.\n\nCoordinate system coord_: De transformatie die wordt gebruikt om gegevenscoördinaten om te zetten in het vlak van de gegevensrechthoek.\n\nFacets facet_: De ordening van de gegevens in een raster van plots.\n\nVisual themes theme(): De algemene visuele standaardinstellingen van een plot, zoals achtergrond, rasters, assen, standaard lettertype, afmetingen en kleuren.\n\n\nHet aantal elementen kan variëren, afhankelijk van hoe u ze groepeert en aan wie u het vraagt."
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#een-standaard-ggplot",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#een-standaard-ggplot",
    "title": "ggplot stap voor stap",
    "section": "Een standaard ggplot",
    "text": "Een standaard ggplot\nAllereerst, om de functionaliteit van ggplot2 te kunnen gebruiken, moeten we het pakket laden (dat we ook kunnen laden via tidyverse suite):\n\n#library(ggplot2)\nlibrary(tidyverse)\n\nDe syntax van ggplot2 is anders dan die van basic R. Volgens de basiselementen heeft een standaard ggplot drie dingen nodig die je moet specificeren: de gegevens, de esthetiek en een geometrie.\nWe beginnen altijd met het definiëren van een plot-object door ggplot(data = df) aan te roepen, wat ggplot2 alleen vertelt dat we met die data gaan werken. In de meeste gevallen wil je twee variabelen plotten-één op de x-as en één op de y-as. Dit zijn positie-esthetica en dus voegen we aes(x = var1, y = var2) toe aan de ggplot() aanroep (ja, de aes() staat voor esthetica). Er zijn echter ook gevallen waarin men één of zelfs drie of meer variabelen moet specificeren.\n\nWe specificeren de gegevens buiten aes() en voegen de variabelen toe waarnaar ggplot de esthetica binnen aes() tot uitdrukking brengt.\n\nHier maken we de variabele datum zichtbaar naar de x-positie en de variabele temp naar de y-positie. Later zullen we ook de variabelen toewijzen aan allerlei andere esthetica zoals kleur, grootte en vorm.\n\n(g <- ggplot(chic, aes(x = date, y = temp)))\n\n\n\n\nHm, alleen een paneel wordt aangemaakt als je dit uitvoert. Waarom? Dat komt omdat ggplot2 niet weet hoe we de gegevens willen plotten-we moeten nog een geometrie opgeven!\nMet ggplot2 kun je het huidige ggobject opslaan in een variabele van jouw keuze door het toe te wijzen aan een variabele, in ons geval genaamd g. Je kunt dit ggobject later uitbreiden door andere lagen toe te voegen, hetzij allemaal tegelijk of door het toe te wijzen aan dezelfde of een andere variabele.\n\nDoor haakjes te gebruiken tijdens het toewijzen van een object, zal het object onmiddellijk worden afgedrukt (in plaats van g <- ggplot(...) en dan g te schrijven schrijven we gewoon (g <- ggplot(...))).\n\nEr zijn vele, vele verschillende geometrieën (geoms genoemd omdat elke functie gewoonlijk begint met geom_) die je standaard aan een ggplot kunt toevoegen (zie hier voor een volledige lijst) en nog meer die door uitbreidingspakketten worden aangeboden (zie hier voor een verzameling van uitbreidingspakketten). Laten we ggplot2 vertellen welke stijl we willen gebruiken, bijvoorbeeld door geom_pint() toe te voegen om een scatter plot te maken:\n\ng + geom_point()\n\n\n\n\nNooi! Maar deze data kunnen ook gevisualiseerd worden als een lijnplot (niet optimaal, maar mensen doen dit soort dingen de hele tijd). Dus voegen we simpelweg geom_line() toe en voilá:\n\ng + geom_line()\n\n\n\n\nJe kunt ook verschillende geometrische lagen combineren - en dit is waar de magie en het plezier begint!\n\ng + geom_line() + geom_point()\n\n\n\n\nDat is het voor nu over geometrieën. Geen zorgen, we gaan later nog verschillende plot types leren.\n\nVerander de eigenschappen van geometrieën\nBinnen het geom_* commando, kun je al visuele esthetiek manipuleren, zoals de kleur, vorm, en grootte van je punten. Laten we alle punten in grote vuurrode diamanten veranderen!\n\ng + geom_point(color = \"firebrick\", shape = \"diamond\", size = 2)\n\n\n\n\n\nggplot2 begrijpt zowel color als colour als de korte versie col.\n\n*Je kunt voorgedefinieerde kleuren gebruiken (hier is een volledige lijst) of hex-kleurcodes, en zelfs RGB/RGBA kleuren gebruiken met rgb() functie.\nElke geom komt met z’n eigen eigenschappen (genoemd arguments) en hetzelfde argument kan in iets anders veranderen afhankelijk van de geom die je gebruikt.\n\ng + geom_point(color = \"firebrick\", shape = \"diamond\", size = 2) +\n    geom_line(color = \"firebrick\", linetype = \"dotted\", size = .3)\n\n\n\n\n\n\nVerander het standaard ggplot2-thema\nEn om nog wat meer van ggplot’s veelzijdigheid te illustreren, laten we ons ontdoen van het grijzige standaard ggplot2 uiterlijk door een ander ingebouwd thema in te stellen, b.v. theme_bw()-door theme_set() op te roepen zullen alle volgende plots hetzelfde zwart-wit thema hebben. De rode punten zien er nu veel beter uit!\n\ntheme_set(theme_bw())\n\ng + geom_point(color = \"firebrick\")\n\n\n\n\nMeer informatie over het gebruik van ingebouwde thema’s en het aanpassen van thema’s vind je in “Working with Themes”. Vanaf het volgende hoofdstuk, zullen we ook de theme() functie gebruiken om bepaalde elementen van het thema aan te passen.\n\ntheme() is een essentieel commando om handmatig allerlei thema-elementen (teksten, rechthoeken, en lijnen) aan te passen.\n\nOm te zien welke details van een ggplot thema kunnen worden aangepast, kijk hier - en neem even de tijd, dit is een lange lijst."
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-assen",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-assen",
    "title": "ggplot stap voor stap",
    "section": "Werken met assen",
    "text": "Werken met assen\n\nVerander astitels\nLaten we wat goed geschreven labels toevoegen aan de assen. Hiervoor voegen we labs() toe met een tekenreeks voor elk label dat we willen veranderen (hier x en y):\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\n\n\n\nJe kunt ook elke astitel toevoegen via xlab() en ylab(). *\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  xlab(\"Jaar\") +\n  ylab(\"Temperatuur (°F)\")\n\n\n\n\nNormaal kan je ook symbolen specificeren door gewoon het symbool zelf toe te voegen, maar onderstaande code laat ook toe om niet alleen symbolen toe te voegen, maar bv. superscripts:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = expression(paste(\"Temperatuur (\", degree ~ F, \")\"^\"(Hey, waarom zouden we metrische eenheden gebruiken?!)\")))\n\n\n\n\n\n\nVergroot de ruimte tussen assen en as-titels\ntheme() is een essentieel commando om bepaalde thema-elementen aan te passen (teksten en titels, kaders, symbolen, achtergronden, …). We gaan ze veel gebruiken! Voor nu gaan we tekstelementen wijzigen. We kunnen de eigenschappen van alle of bepaalde tekstelementen (hier as-titels) wijzigen door het overschrijven van het standaard element_text() binnen de theme() aanroep:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.title.x = element_text(vjust = 0, size = 15),\n        axis.title.y = element_text(vjust = 2, size = 15))\n\n\n\n\nvjust verwijst naar de verticale uitlijning, die gewoonlijk tussen 0 en 1 ligt, maar je kunt ook waarden buiten dat bereik opgeven. Merk op dat, hoewel we de as-titel op de y-as horizontaal verplaatsen, we vjust moeten specificeren (wat correct is vanuit het perspectief van het label). Je kunt de afstand ook veranderen door de marge van beide tekst elementen op te geven:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.title.x = element_text(margin = margin(t = 10), size = 15),\n        axis.title.y = element_text(margin = margin(r = 10), size = 15))\n\n\n\n\nDe labels t en r in het margin() object verwijzen naar boven en rechts, respectievelijk. Je kunt de vier marges ook opgeven als margin(t, r, b, l). Merk op dat we nu de rechtermarge moeten veranderen om de ruimte op de y-as aan te passen, niet de ondermarge.\n\nEen goede manier om de volgorde van de marges te onthouden is “t-r-ou-b-l-e”.\n\n\n\nWijzig de esthetiek van de as-titels\nWe gebruiken weer de theme() functie en wijzigen het element axis.title en/of de ondergeschikte elementen axis.title.x en axis.title.y. Binnen de element_text() kunnen we bijvoorbeeld de standaardwaarden voor size, color, en face overschrijven:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.title = element_text(size = 15, color = \"firebrick\",\n                                  face = \"italic\"))\n\n\n\n\nHet face argument kan worden gebruikt om het lettertype vet or schuin of zelfd bold.italic(vet.schuin) te krijgen.\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.title.x = element_text(color = \"sienna\", size = 15),\n        axis.title.y = element_text(color = \"orangered\", size = 15))\n\n\n\n\n\nJe kunt ook een combinatie gebruiken van axis.title en axis.title.y, omdat axis.title.x de waarden erft van axis.title. Zie hieronder.\n\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.title = element_text(color = \"sienna\", size = 15),\n        axis.title.y = element_text(color = \"orangered\", size = 15))\n\n\n\n\nMen kan sommige eigenschappen voor beide assen wijzigen en andere slechts voor één of eigenschappen voor elke as afzonderlijk:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.title = element_text(color = \"sienna\", size = 15, face = \"bold\"),\n        axis.title.y = element_text(face = \"bold.italic\"))\n\n\n\n\n\n\nVerander de aesthetics van de astekst\nOp dezelfde manier kun je ook het uiterlijk van de as-tekst (hier de getallen) veranderen door axis.text en/of de ondergeschikte elementen axis.text.x en axis.text.y te gebruiken:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.text = element_text(color = \"dodgerblue\", size = 12),\n        axis.text.x = element_text(face = \"italic\"))\n\n\n\n\n\n\nRoteer astekst\nDoor een angle op te geven kun je alle tekstelementen draaien. Met hjust en vjust kun je de positie van de tekst achteraf horizontaal (0 = left, 1 = right) en verticaal (0 = top, 1 = bottom) aanpassen:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature (°F)\") +\n  theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1, size = 12))\n\n\n\n\n\n\nAstekst en tekens weghalen\nEr zal niet snel een reden voor zijn—maar zo werkt het:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(axis.ticks.y = element_blank(),\n        axis.text.y = element_blank())\n\n\n\n\nIk heb drie thema-elementen geïntroduceerd - tekst, lijnen en rechthoeken - maar eigenlijk is er nog een: element_blank() dat het element verwijdert (en dus niet als een officieel element wordt beschouwd).\n\nAls je van een theme-element af wilt, is het element altijd element_blank().\n\n\n\nHaal astitels weg\nWe zouden opnieuw theme_blank() kunnen gebruiken, maar het is veel eenvoudiger om gewoon het label te verwijderen in de labs() (of xlab()) aanroep:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = NULL, y = \"\")\n\n\n\n\n\nMerk op dat NULL het element verwijdert (vergelijkbaar met element_blank()) terwijl lege aanhalingstekens \"\" de spatiëring voor de as-titel behouden en gewoon niets afdrukken.\n\n\n\nAsbereik beperken\nSoms wil je een bepaald bereik van je gegevens nader bekijken. Je kunt dit doen zonder je gegevens te splitsen:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  ylim(c(0, 50))\n\nWarning: Removed 777 rows containing missing values (geom_point).\n\n\n\n\n\nAls alternatief kun je scale_y_continuous(limits = c(0, 50)) of coord_cartesian(ylim = c(0, 50)) gebruiken. De eerste verwijdert alle datapunten buiten het bereik, terwijl de tweede het zichtbare gebied aanpast en vergelijkbaar is met ylim(c(0, 50)). Je kunt je afvragen: Dus uiteindelijk leveren beide hetzelfde op. Niet echt, er is een belangrijk verschil-vergelijk de twee volgende plots:\nPlaatje2.PNG)\nJe hebt misschien gezien dat er links een lege buffer is rond de y-grens, terwijl er rechts punten tot aan de grens en zelfs verder worden uitgezet. Dit illustreert perfect het subsetting (links) versus het zoomen (rechts). Om te tonen waarom dit belangrijk is, laten we eens kijken naar een ander grafiektype, een box plot:\n\nOmdat scale_x|y_continuous() de data eerst subset, krijgen we totaal verschillende (en verkeerde, tenminste als dit niet je doel was) schattingen voor de boxp-lots! Ik hoop dat je nu niet terug hoeft te gaan naar je oude scripts om te controleren of je misschien je data hebt gemanipuleerd tijdens het plotten en verkeerde samenvattende statistieken hebt gerapporteerd in je rapport, paper of thesis…\n\n\nForceer Plot om te starten bij Origin\nVerwant hiermee, je kan R forceren om de grafiek te plotten startend bij de oorsprong:\n\nlibrary(tidyverse)\n\nchic_high <- dplyr::filter(chic, temp > 25, o3 > 20)\n\nggplot(chic_high, aes(x = temp, y = o3)) +\n  geom_point(color = \"darkcyan\") +\n  labs(x = \"Temperatuur hoger dan 25°F\",\n       y = \"Ozon hoger dan 20 ppb\") +\n  expand_limits(x = 0, y = 0)\n\n\n\n\n\nGebruik vancoord_cartesian(xlim = c(0, NA), ylim = c(0, NA)) levert hetzelfde resultaat op.\n\n\nlibrary(tidyverse)\n\nchic_high <- dplyr::filter(chic, temp > 25, o3 > 20)\n\nggplot(chic_high, aes(x = temp, y = o3)) +\n  geom_point(color = \"darkcyan\") +\n  labs(x = \"Temperatuur hoger dan25°F\",\n       y = \"Ozon hoger dan 20 ppb\") +\n  coord_cartesian(xlim = c(0, NA), ylim = c(0, NA))\n\n\n\n\nMaar we kunnen het ook forceren om letterlijk bij het begin te beginnen.\n\nggplot(chic_high, aes(x = temp, y = o3)) +\n  geom_point(color = \"darkcyan\") +\n  labs(x = \"Temperatuur hoger dan 25°F\",\n       y = \"Ozon hoger dan 20 ppb\") +\n  expand_limits(x = 0, y = 0) +\n  coord_cartesian(expand = FALSE, clip = \"off\")\n\n\n\n\n\nHet argument clip = \"off\" in elk coördinatensysteem, altijd beginnend met coord_*, stelt je in staat om buiten het paneelgebied te tekenen.\n\nHier zorg ik ervoor dat de tikmerken op c(0, 0) niet weggesneden worden. Voor meer details zie ook Twitter thread door Claus Wilke.\n\n\nAssen met dezelfde schalen\nLaten we ter demonstratie de temperatuur uitzetten tegen de temperatuur met wat willekeurige ruis. De coord_equal() is een coördinatensysteem met een gespecificeerde verhouding die het aantal eenheden op de y-as weergeeft dat gelijk is aan één eenheid op de x-as.\nDe standaardwaarde, ratio = 1, zorgt ervoor dat één eenheid op de x-as even lang is als één eenheid op de y-as:\n\nggplot(chic, aes(x = temp, y = temp + rnorm(nrow(chic), sd = 20))) +\n  geom_point(color = \"sienna\") +\n  labs(x = \"Temperatuur (°F)\", y = \"Temperatuur (°F) + random ruis\") +\n  xlim(c(0, 100)) + ylim(c(0, 150)) +\n  coord_fixed()\n\nWarning: Removed 56 rows containing missing values (geom_point).\n\n\n\n\n\nVerhoudingen hoger dan één maken eenheden op de y-as langer dan eenheden op de x-as, en omgekeerd:\n\nggplot(chic, aes(x = temp, y = temp + rnorm(nrow(chic), sd = 20))) +\n  geom_point(color = \"sienna\") +\n  labs(x = \"Temperatuur (°F)\", y = \"Temperatuur (°F) + random ruis\") +\n  xlim(c(0, 100)) + ylim(c(0, 150)) +\n  coord_fixed(ratio = 1/5)\n\nWarning: Removed 49 rows containing missing values (geom_point).\n\n\n\n\n\n\n\nGebruik een functie om labels te veranderen\nSoms is het handig om uw labels een beetje te wijzigen, bijvoorbeeld door eenheden of procenttekens toe te voegen zonder ze aan uw gegevens toe te voegen. In dat geval kun je een functie gebruiken:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = NULL) +\n  scale_y_continuous(label = function(x) {return(paste(x, \"Graden Fahrenheit\"))})"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#met-titels-werken",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#met-titels-werken",
    "title": "ggplot stap voor stap",
    "section": "Met titels werken",
    "text": "Met titels werken\n\nEen titel toevoegen\nWe kunnen een titel toevoegen via de ggtitle() functie:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  ggtitle(\"Temperaturen in Chicago\")\n\n\n\n\nAls alternatief kun je labs() gebruiken. Hier kun je meerdere argumenten toevoegen, bijvoorbeeld een ondertitel, een onderschrift en een tag (en ook as-titels zoals eerder getoond):\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\",\n       title = \"Temperaturen in Chicago\",\n       subtitle = \"Seizoenspatroon van dagelijkse temperaturen van 1997 tot 2001\",\n       caption = \"Data: NMMAPS\",\n       tag = \"Figuur 1\")\n\n\n\n\n\n\nTitel vet maken & spatie toevoegen aan de basislijn\nNogmaals, omdat we de eigenschappen van een themaelement willen wijzigen, gebruiken we de theme() functie en zoals voor de tekstelementen axis.title en axis.text wijzigen we het lettertype en de marge. Alle volgende wijzigingen van thema-elementen werken niet alleen voor de titel, maar voor alle andere labels zoals plot.subtitle, plot.caption, plot.caption, legend.title, legend.text, axis.title en axis.text.\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\",\n       title = \"Temperaturen in Chicago\") +\n  theme(plot.title = element_text(face = \"bold\",\n                                  margin = margin(10, 0, 10, 0),\n                                  size = 14))\n\n\n\n\n\nEen mooie manier om de volgorde van de marge-argumenten te onthouden is “t-r-oub-l-e”.\n\n\n\nPositie van titels aanpassen\nDe algemene uitlijning (links, midden, rechts) wordt geregeld met hjust (dat staat voor horizontale aanpassing):\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = NULL,\n       title = \"Temperaturen in Chicago\",\n       caption = \"Data: NMMAPS\") +\n  theme(plot.title = element_text(hjust = 1, size = 16, face = \"bold.italic\"))\n\n\n\n\nNatuurlijk is het daar ook mogelijk om de verticale uitlijning aan te passen, geregeld door vjust.\nDe gebruiker de uitlijning van de titel, ondertitel en bijschrift opgeven op basis van het paneelgebied (de standaard) of de plotmarge via plot.title.position en plot.caption.position. De laatste optie is in de meeste gevallen de betere keuze en veel mensen waren erg blij met deze nieuwe functie, omdat met name bij zeer lange y-as labels de uitlijning er verschrikkelijk uitziet:\n\n(g <- ggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  scale_y_continuous(label = function(x) {return(paste(x, \"Graden Fahrenheit\"))}) +\n  labs(x = \"Jaar\", y = NULL,\n       title = \"Temperaturen in Chicago 1997-2001 \n       in Graden Fahrenheit\",\n       caption = \"Data: NMMAPS\") +\n  theme(plot.title = element_text(size = 14, face = \"bold.italic\"),\n       plot.caption = element_text(hjust = 0)))\n\n\n\n\n\ng + theme(plot.title.position = \"plot\",\n          plot.caption.position = \"plot\")\n\n\n\n\n\n\nGebruik een niet traditioneel lettertype in jouw titel\nJe kunt ook verschillende lettertypes gebruiken, niet alleen het standaard lettertype dat door ggplot wordt geleverd (en dat verschilt van besturingssysteem tot besturingssysteem). Er zijn verschillende pakketten die je helpen om lettertypes te gebruiken die op je machine geïnstalleerd zijn (en die je misschien gebruikt in je office programma). Hier gebruik ik het showtext pakket dat het makkelijk maakt om verschillende types lettertypes (TrueType, OpenType, Type 1, web fonts, etc.) te gebruiken in R plots. Nadat we het pakket hebben geladen, moet je het lettertype importeren dat ook op je apparaat moet zijn geïnstalleerd. Ik gebruik regelmatig Google fonts dat geïmporteerd kan worden met de functie font_add_google() maar je kunt ook andere lettertypen toevoegen met font_add(). (Merk op dat zelfs in het geval van het gebruik van Google fonts je het font moet installeren - en Rstudio opnieuw moet opstarten - om het font te kunnen gebruiken).\n\nlibrary(showtext)\nfont_add_google(\"Playfair Display\", ## name of Google font\n                \"Playfair\")  ## name that will be used in R\nfont_add_google(\"Bangers\", \"Bangers\")\n\nNu kunnen we die lettertype families gebruiken met - ja, je raadt het al - theme():\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\",\n       title = \"Temperaturen in Chicago\",\n       subtitle = \"Dagelijkese temperaturen in °F van 1997 tot 2001\") +\n  theme(plot.title = element_text(family = \"Bangers\", hjust = .5, size = 25),\n        plot.subtitle = element_text(family = \"Playfair\", hjust = .5, size = 15))\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nJe kunt ook een niet-standaard lettertype instellen voor alle tekstelementen van jouw plots, voor meer details zie “Working with themes”. Ik ga Roboto Condensed gebruiken als het nieuwe lettertype voor alle volgende plots.\n\nfont_add_google(\"Roboto Condensed\", \"Roboto Condensed\")\ntheme_set(theme_bw(base_size = 12, base_family = \"Roboto Condensed\"))\n\n(Voorheen gebruikte deze handleiding het extrafont pakket, dat het tot vorig jaar prima deed. Plotseling kon ik geen nieuwe lettertypen meer toevoegen en nadat ik een nieuwe laptop had, vond het pakket helemaal geen lettertypen meer… Ik stel nu meestal het ragg pakket voor. Het is me echter niet gelukt om het te laten werken voor mijn homepage dus gebruik ik het showtext pakket dat ook geweldig is met het enige verschil dat je het lettertype dat je wilt gebruiken expliciet moet importeren met showtext. Het lijkt er echter op dat er enkele technische details zijn die niet optimaal door showtext worden opgelost, zodat je het pakket misschien als allerlaatste redmiddel wilt gebruiken.).\n\n\nAfstand veranderen in multi-line tekst\nJe kunt het lineheight argument gebruiken om de afstand tussen de regels te veranderen. In dit voorbeeld, heb ik de regels samengeknepen (lineheight < 1).\n\n\nWijzig de spatiëring in meer-regelige tekst\nJe kunt het lineheight argument gebruiken om de afstand tussen de regels te veranderen. In dit voorbeeld, heb ik de regels samengeknepen (lineheight < 1).\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature (°F)\") +\n  ggtitle(\"Temperatures in Chicago\\nfrom 1997 to 2001\") +\n  theme(plot.title = element_text(lineheight = .8, size = 16))\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#met-legendas-werken",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#met-legendas-werken",
    "title": "ggplot stap voor stap",
    "section": "Met legenda’s werken",
    "text": "Met legenda’s werken\nWe zullen de plot een kleurcode geven op basis van het seizoen. Of om het op een meer ggplot-achtige manier te zeggen: we koppelen de variabele season aan de aesthetic color. Een leuke eigenschap van ggplot2 is dat het standaard een legenda toevoegt wanneer het een variabele aan een esthetiek koppelt. Je kunt zien dat de titel van de legenda standaard is wat we in het kleur argument hebben opgegeven:\n\nggplot(chic,\n       aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\nDe legenda uitzetten\nEen van de eerste vragen is vaak: “Hoe kan ik de legenda uitzetten?”.\nHet is vrij eenvoudig en werkt altijd met theme(legend.position = \"none\"):\n\nggplot(chic,\n       aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.position = \"none\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nJe kunt ook guides(color = \"none\") of scale_color_discrete(guide = \"none\") gebruiken, afhankelijk van het specifieke geval. Terwijl de verandering van het thema-element alle legenda’s in een keer verwijdert, kunt je met de laatstgenoemde opties bepaalde legenda’s verwijderen terwijl sommige andere behouden blijven:\n\nggplot(chic,\n       aes(x = date, y = temp,\n           color = season, shape = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  guides(color = \"none\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nHier, bijvoorbeeld, behouden we de legende voor de vormen terwijl we die voor de kleuren weggooien.\n\n\nVerwijder legenda titels\nZoals we al geleerd hebben, gebruik element_blank() om niets te tekenen:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.title = element_blank())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\nJe kunt hetzelfde bereiken door de legendanaam op NULL te zetten, ofwel via scale_color_discrete(name = NULL) of labs(color = NULL).\n\n\n\nLegenda positie veranderen\nAls men de legenda niet rechts wil plaatsen, gebruikt men legend.position als argument in theme. Mogelijke posities zijn “boven”, “rechts” (wat de standaard is), “onder”, en “links”.You can achieve the same by setting the legend name to NULL, either via scale_color_discrete(name = NULL) or labs(color = NULL).\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.position = \"top\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nJe kunt de legenda ook binnen het paneel plaatsen door een vector op te geven met relatieve x en y coördinaten variërend van 0 (links of onder) tot 1 (rechts of boven):\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\",\n       color = NULL) +\n  theme(legend.position = c(.15, .15),\n        legend.background = element_rect(fill = \"transparent\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nHier overschrijf ik ook de standaard witte legende achtergrond met een transparante vulling om er zeker van te zijn dat de legende geen data punten verbergt.\n\n\nLegenda richting wijzigen\nZoals je gezien hebt, is de legende-richting standaard verticaal, maar horizontaal als je de “top” of “bottom” positie kiest. Maar u kunt de richting ook veranderen zoals u wilt:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.position = c(.5, .97),\n        legend.background = element_rect(fill = \"transparent\")) +\n  guides(color = guide_legend(direction = \"horizontal\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nStijl van de legende titel veranderen\nU kunt het uiterlijk van de legendatitel veranderen door het thema-element legend.title aan te passen:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.title = element_text(family = \"Playfair\",\n                                    color = \"chocolate\",\n                                    size = 14, face = \"bold\"))\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nTitel legenda wijzigen\nDe eenvoudigste manier om de titel van de legenda te veranderen is de labs() laag:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\",\n       color = \"Seizoenen\\ngeïndiceerd\\ndoor kleuren:\") +\n  theme(legend.title = element_text(family = \"Playfair\",\n                                    color = \"chocolate\",\n                                    size = 14, face = \"bold\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nDe legenda details kunnen worden veranderd via scale_color_discrete(name = \"title\") of guides(color = guide_legend(\"title\")):\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.title = element_text(family = \"Playfair\",\n                                    color = \"chocolate\",\n                                    size = 14, face = \"bold\")) +\n  scale_color_discrete(name = \"Seizoenen\\ngeïndiceerd\\ndoor kleuren:\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nVerander de volgorde van de legenda toetsen\nWe kunnen dit bereiken door de niveaus van season te veranderen:\n\nchic$season <-\n  factor(chic$season,\n         levels = c(\"Winter\", \"Spring\", \"Summer\", \"Autumn\"))\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nLegendalabels veranderen\nWe gaan de seizoenen vervangen door de maanden die ze bestrijken door een vector van namen op te geven in de scale_color_discrete() aanroep:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  scale_color_discrete(\n    name = \"Seasons:\",\n    labels = c(\"Mar—May\", \"Jun—Aug\", \"Sep—Nov\", \"Dec—Feb\")\n  ) +\n  theme(legend.title = element_text(\n    family = \"Playfair\", color = \"chocolate\", size = 14, face = 2\n  ))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nAchtergrondvakken in de legenda wijzigen\nOm de achtergrondkleur (vulling) van de legenda toetsen te veranderen, passen we de instelling voor het thema element legend.key aan:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature (°F)\") +\n  theme(legend.key = element_rect(fill = \"darkgoldenrod1\"),\n        legend.title = element_text(family = \"Playfair\",\n                                    color = \"chocolate\",\n                                    size = 14, face = 2)) +\n  scale_color_discrete(\"Seasons:\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nAls je ze helemaal weg wilt hebben, gebruik dan fill = NA of fill = \"transparent\".\n\n\nFormaat van de legenda-symbolen wijzigen\nPunten in de legenda kunnen een beetje verloren gaan met de standaard grootte, vooral zonder de kaders. Om de standaardgrootte op te heffen gebruikt men weer de guides laag zoals hier:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.key = element_rect(fill = NA),\n        legend.title = element_text(color = \"chocolate\",\n                                    size = 14, face = 2)) +\n  scale_color_discrete(\"Seasons:\") +\n  guides(color = guide_legend(override.aes = list(size = 6)))\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nLaat een laag uit de legende\nLaten we zeggen dat je twee verschillende geoms hebt gemapt op dezelfde variabele. Bijvoorbeeld, kleur als esthetiek voor zowel een puntlaag als een tapijtlaag van dezelfde gegevens. Standaard komen zowel de punten als de “lijn” zo in de legenda terecht:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  geom_rug()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nJe kunt show.legend = FALSE gebruiken om een laag in de legenda uit te schakelen:\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  geom_rug(show.legend = FALSE)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nHandmatig toevoegen van legenda items\nggplot2 voegt niet automatisch een legenda toe, tenzij je de esthetiek (kleur, grootte etc.) aan een variabele koppelt. Er zijn echter momenten dat ik een legenda wil hebben, zodat het duidelijk is wat je aan het plotten bent.\nHier is de standaard:\n\nggplot(chic, aes(x = date, y = o3)) +\n  geom_line(color = \"gray\") +\n  geom_point(color = \"darkorange2\") +\n  labs(x = \"Jaar\", y = \"Ozon\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nWe kunnen een legenda forceren door een leidraad naar een variabele te mappen. We mappen de lijnen en de punten met aes() en we mappen niet naar een variabele in onze dataset, maar naar een enkele string (zodat we voor elk maar één kleur krijgen).\n\nggplot(chic, aes(x = date, y = o3)) +\n  geom_line(aes(color = \"line\")) +\n  geom_point(aes(color = \"points\")) +\n  labs(x = \"Jaar\", y = \"Ozon\") +\n  scale_color_discrete(\"Type:\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nWe komen in de buurt, maar dit is niet wat we willen. We willen grijs en rood! Om de kleur te veranderen, gebruiken we scale_color_manual(). Daarnaast veranderen we de legenda met de guide() functie.\nVoila! We hebben nu een plot met grijze lijnen en rode punten, en een enkele grijze lijn en een enkel rood punt als legenda symbolen:\n\nggplot(chic, aes(x = date, y = o3)) +\n  geom_line(aes(color = \"line\")) +\n  geom_point(aes(color = \"points\")) +\n  labs(x = \"Jaar\", y = \"Ozon\") +\n  scale_color_manual(name = NULL,\n                     guide = \"legend\",\n                     values = c(\"points\" = \"darkorange2\",\n                                \"line\" = \"gray\")) +\n  guides(color = guide_legend(override.aes = list(linetype = c(1, 0),\n                                                  shape = c(NA, 16))))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nGebruik andere legenda stijlen\nDe standaard-legenda voor categorische variabelen zoals season is een guide_legend() zoals je in verschillende eerdere voorbeelden hebt gezien. Als je een continue variabele mapt naar een esthetiek, zal ggplot2 standaard geen guide_legend() gebruiken maar guide_colorbar() (of guide_colourbar()):\n\nggplot(chic,\n       aes(x = date, y = temp, color = temp)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\", color = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nEchter, door guide_legend() te gebruiken kun je de legenda dwingen om discrete kleuren te tonen voor een gegeven aantal breuken zoals in het geval van een categorische variabele:\n\nggplot(chic,\n       aes(x = date, y = temp, color = temp)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\", color = \"Temperatuur (°F)\") +\n  guides(color = guide_legend())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nJe kunt ook binned scales gebruiken:\n\nggplot(chic,\n       aes(x = date, y = temp, color = temp)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\", color = \"Temperatuur (°F)\") +\n  guides(color = guide_bins())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n… of schalen als discrete colorbars:\n\nggplot(chic,\n       aes(x = date, y = temp, color = temp)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\", color = \"Temperatuur (°F)\") +\n  guides(color = guide_colorsteps())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-achtergronden-rasterlijnen",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-achtergronden-rasterlijnen",
    "title": "ggplot stap voor stap",
    "section": "Werken met Achtergronden & Rasterlijnen",
    "text": "Werken met Achtergronden & Rasterlijnen\nEr zijn manieren om het hele uiterlijk van uw plot te veranderen met één functie (zie “Working with themes” sectie hieronder) maar als je alleen de kleuren van sommige elementen wilt veranderen, kunt je dat ook doen.\n\nDe achtergrondkleur van het paneel veranderen\nOm de achtergrondkleur (vulling) van het paneelgebied (d.w.z. het gebied waar de gegevens worden uitgezet) te veranderen, moet het thema-element panel.background worden aangepast:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"#1D8565\", size = 2) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(panel.background = element_rect(\n    fill = \"#64D2AA\", color = \"#64D2AA\", size = 2)\n  )\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nMerk op dat de echte kleur - de omtrek van de achtergrond van het paneel - niet verandert, ook al hebben we die gespecificeerd. Dit komt omdat er een laag bovenop de panel.background zit, namelijk panel.border. Zorg er wel voor dat je hier een transparante vulling gebruikt, anders worden je gegevens verborgen achter deze laag. In het volgende voorbeeld illustreer ik dat door een semitransparante hex kleur te gebruiken voor het fill argument in element_rect:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"#1D8565\", size = 2) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(panel.border = element_rect(\n    fill = \"#64D2AA99\", color = \"#64D2AA\", size = 2))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nRasterlijnen veranderen\nEr zijn twee soorten rasterlijnen: grote rasterlijnen die de vinkjes aangeven en kleine rasterlijnen tussen de grote rasterlijnen. Je kunt deze allemaal veranderen door de standaardwaarden voor panel.grid te overschrijven of voor elke set rasterlijnen afzonderlijk, panel.grid.major en panel.grid.minor.\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(panel.grid.major = element_line(color = \"gray10\", size = .5),\n        panel.grid.minor = element_line(color = \"gray70\", size = .25))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nJe kunt zelfs instellingen opgeven voor de vier verschillende niveaus:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(panel.grid.major = element_line(size = .5, linetype = \"dashed\"),\n        panel.grid.minor = element_line(size = .25, linetype = \"dotted\"),\n        panel.grid.major.x = element_line(color = \"red1\"),\n        panel.grid.major.y = element_line(color = \"blue1\"),\n        panel.grid.minor.x = element_line(color = \"red4\"),\n        panel.grid.minor.y = element_line(color = \"blue4\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nEn natuurlijk kun je sommige of alle rasterlijnen verwijderen als je dat wilt:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(panel.grid.minor = element_blank())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(panel.grid = element_blank())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nAfstand tussen rasterlijnen wijzigen\nBovendien kun je ook de onderbrekingen tussen de grote en kleine rasterlijnen bepalen:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  scale_y_continuous(breaks = seq(0, 100, 10),\n                     minor_breaks = seq(0, 100, 2.5))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nVerander de achtergrondkleur van de plot\nOp dezelfde manier, om de achtergrondkleur (vulling) van het plot gebied te veranderen, moet men het theme element plot.background aanpassen:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(plot.background = element_rect(fill = \"gray60\",\n                                       color = \"gray30\", size = 2))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nJe kunt een unieke achtergrondkleur krijgen door ofwel dezelfde kleuren in panel.background en plot.background te zetten, of door de achtergrondvulling van het paneel op \"transparent\" of NA te zetten:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(panel.background = element_rect(fill = NA),\n        plot.background = element_rect(fill = \"gray60\",\n                                       color = \"gray30\", size = 2))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nWerken met marges\nSoms is het handig om een beetje ruimte toe te voegen aan de plotmarge. Net als bij de vorige voorbeelden kunnen we een argument gebruiken voor de theme() functie. In dit geval is het argument plot.margin. Zoals in het vorige voorbeeld hebben we de standaard marge al geïllustreerd door de achtergrondkleur te veranderen met plot.background.\nLaten we nu extra ruimte toevoegen aan zowel links als rechts. Het argument, plot.margin, kan overweg met verschillende eenheden (cm, inches, etc.) maar vereist het gebruik van de functie unit uit het pakket grid om de eenheden te specificeren. Je kunt ofwel dezelfde waarde opgeven voor alle zijden (het makkelijkst via rep(x, 4)) of bepaalde afstanden voor elk. Hier gebruik ik een marge van 1 cm aan de boven- en onderkant, 3 cm marge aan de rechterkant, en 8 cm marge aan de linkerkant.\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(plot.background = element_rect(fill = \"gray60\"),\n        plot.margin = margin(t = 1, r = 3, b = 1, l = 8, unit = \"cm\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDe volgorde van de margezijden is boven, rechts, onder, links-een mooie manier om deze volgorde te onthouden is “trouble dat sorteert de eerste letter van de vier zijden.\n\nJe kunt ook unit() gebruiken in plaats van margin().\n\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(plot.background = element_rect(fill = \"gray60\"),\n        plot.margin = unit(c(1, 3, 1, 8), \"cm\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-multi-paneel-plots",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-multi-paneel-plots",
    "title": "ggplot stap voor stap",
    "section": "Werken met multi-paneel plots",
    "text": "Werken met multi-paneel plots\nHet ggplot2 pakket heeft twee mooie functies voor het maken van multi-panel plots, facets genaamd. Ze zijn verwant maar een beetje verschillend: facet_wrap creëert in wezen een lint van plots gebaseerd op een enkele variabele terwijl facet_grid een raster van twee variabelen overspant.\n\nMaak een raster van kleine veelvouden gebaseerd op twee variabelen\nIn het geval van twee variabelen, doet facet_grid het werk. Hier bepaalt de volgorde van de variabelen het aantal rijen en kolommen:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  facet_grid(year ~ season)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nOm van rij- naar kolomindeling te veranderen kun je facet_grid(year ~ season) veranderen in facet_grid(season ~ year).\n\n\nMaak kleine veelvouden gebaseerd op één variabele\nfacet_wrap maakt een facet van een enkele variabele, geschreven met een tilde ervoor: facet_wrap(~ variable). Het uiterlijk van deze subplots wordt geregeld door de argumenten ncol en nrow:\n\ng <-\n  ggplot(chic, aes(x = date, y = temp)) +\n    geom_point(color = \"chartreuse4\", alpha = .3) +\n    labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))\n\ng + facet_wrap(~ year)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDienovereenkomstig kunt je de plots rangschikken zoals je wilt, in plaats van als een matrix in één rij…\n\ng + facet_wrap(~ year, nrow = 1)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n… of zelfs als een asymmetrisch raster van percelen:\n\ng + facet_wrap(~ year, ncol = 3) + theme(axis.title.x = element_text(hjust = .15))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nAssen vrij laten lopen\nDe standaard voor multi-panel plots in ggplot2 is om gelijkwaardige schalen te gebruiken in elk paneel. Maar soms wil je toestaan dat de gegevens van een paneel zelf de schaal bepalen. Dit is vaak geen goed idee omdat het de gebruiker een verkeerde indruk kan geven over de data. Maar soms is het wel degelijk nuttig en om dit te doen kunt u scales = \"free\" instellen:\n\ng + facet_wrap(~ year, nrow = 2, scales = \"free\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nMerk op dat zowel de x-as als de y-as verschillen in hun bereik!\n\n\nGebruik facet_wrap met twee variabelen\nDe functie facet_wrap kan ook twee variabelen aannemen:\n\ng + facet_wrap(year ~ season, nrow = 4, scales = \"free_x\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nBij het gebruik van facet_wrap heeft u nog steeds controle over het ontwerp van het grid: u kunt het aantal plots per rij en kolom herschikken en u kunt ook alle assen vrij laten rondlopen. In tegenstelling hiermee neemt facet_grid ook een free argument, maar laat het alleen per kolom of rij vrij rondlopen:\n\ng + facet_grid(year ~ season, scales = \"free_x\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nStijl van strookteksten wijzigen\nDoor thema te gebruiken, kunt u het uiterlijk van de strook tekst (d.w.z. de titel voor elk facet) en de strook tekstvakken wijzigen:\n\ng + facet_wrap(~ year, nrow = 1, scales = \"free_x\") +\n  theme(strip.text = element_text(face = \"bold\", color = \"chartreuse4\",\n                                  hjust = 0, size = 20),\n        strip.background = element_rect(fill = \"chartreuse3\", linetype = \"dotted\"))\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDe volgende two functions adapted from this answer by Claus Wilke, maakt de auteur van het ggtext pakket het mogelijk om specifieke labels te markeren in combinatie met element_textbox() dat wordt geleverd door ggtext.\n\nlibrary(ggtext)\nlibrary(rlang)\n\nWarning: package 'rlang' was built under R version 4.1.3\n\n\n\nAttaching package: 'rlang'\n\n\nThe following objects are masked from 'package:purrr':\n\n    %@%, as_function, flatten, flatten_chr, flatten_dbl, flatten_int,\n    flatten_lgl, flatten_raw, invoke, splice\n\nelement_textbox_highlight <- function(..., hi.labels = NULL, hi.fill = NULL,\n                                      hi.col = NULL, hi.box.col = NULL, hi.family = NULL) {\n  structure(\n    c(element_textbox(...),\n      list(hi.labels = hi.labels, hi.fill = hi.fill, hi.col = hi.col, hi.box.col = hi.box.col, hi.family = hi.family)\n    ),\n    class = c(\"element_textbox_highlight\", \"element_textbox\", \"element_text\", \"element\")\n  )\n}\n\nelement_grob.element_textbox_highlight <- function(element, label = \"\", ...) {\n  if (label %in% element$hi.labels) {\n    element$fill <- element$hi.fill %||% element$fill\n    element$colour <- element$hi.col %||% element$colour\n    element$box.colour <- element$hi.box.col %||% element$box.colour\n    element$family <- element$hi.family %||% element$family\n  }\n  NextMethod()\n}\n\nNu kun je het gebruiken en bijvoorbeeld alle strookteksten opgeven:\n\ng + facet_wrap(year ~ season, nrow = 4, scales = \"free_x\") +\n  theme(\n    strip.background = element_blank(),\n    strip.text = element_textbox_highlight(\n      family = \"Playfair\", size = 12, face = \"bold\",\n      fill = \"white\", box.color = \"chartreuse4\", color = \"chartreuse4\",\n      halign = .5, linetype = 1, r = unit(5, \"pt\"), width = unit(1, \"npc\"),\n      padding = margin(5, 0, 3, 0), margin = margin(0, 1, 3, 1),\n      hi.labels = c(\"1997\", \"1998\", \"1999\", \"2000\"),\n      hi.fill = \"chartreuse4\", hi.box.col = \"black\", hi.col = \"white\"\n    )\n  )\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(aes(color = season == \"Summer\"), alpha = .3) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  facet_wrap(~ season, nrow = 1) +\n  scale_color_manual(values = c(\"gray40\", \"firebrick\"), guide = \"none\") +\n  theme(\n    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),\n    strip.background = element_blank(),\n    strip.text = element_textbox_highlight(\n      size = 12, face = \"bold\",\n      fill = \"white\", box.color = \"white\", color = \"gray40\",\n      halign = .5, linetype = 1, r = unit(0, \"pt\"), width = unit(1, \"npc\"),\n      padding = margin(2, 0, 1, 0), margin = margin(0, 1, 3, 1),\n      hi.labels = \"Summer\", hi.family = \"Bangers\",\n      hi.fill = \"firebrick\", hi.box.col = \"firebrick\", hi.col = \"white\"\n    )\n  )\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nEen paneel van verschillende plots maken\nEr zijn verschillende manieren om plots te combineren. De makkelijkste aanpak is volgens mij het patchwork package van Thomas Lin Pedersen:\n\np1 <- ggplot(chic, aes(x = date, y = temp,\n                       color = season)) +\n        geom_point() +\n        geom_rug() +\n        labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\np2 <- ggplot(chic, aes(x = date, y = o3)) +\n        geom_line(color = \"gray\") +\n        geom_point(color = \"darkorange2\") +\n        labs(x = \"Jaar\", y = \"Ozon\")\n\nlibrary(patchwork)\np1 + p2\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nWe kunnen de volgorde veranderen door beide plots te “verdelen” (en let op de uitlijning, ook al heeft de ene een legende en de andere niet!):\n\np1 / p2\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nEn ook geneste plots zijn mogelijk!\n\n(g + p2) / p1\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n(Let op de uitlijning van de plots, hoewel slechts één plot een legenda heeft).\nAls alternatief biedt het cowplot package van Claus Wilke de functionaliteit om meerdere plots te combineren (en vele andere goede utilities):\n\nlibrary(cowplot)\nplot_grid(plot_grid(g, p1), p2, ncol = 1)\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family\n'Roboto Condensed' not found in PostScript font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily 'Roboto Condensed' not found in PostScript font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n… en ook doet gridExtra package het goed:\n\nlibrary(gridExtra)\ngrid.arrange(g, p1, p2,\n             layout_matrix = rbind(c(1, 2), c(3, 3)))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nHetzelfde idee van het definiëren van een lay-out kan worden gebruikt met patchwork, waarmee complexe composities kunnen worden gemaakt:\n\nlayout <- \"\nAABBBB#\nAACCDDE\n##CCDD#\n##CC###\n\"\n\np2 + p1 + p1 + g + p2 +\n  plot_layout(design = layout)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-kleuren",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-kleuren",
    "title": "ggplot stap voor stap",
    "section": "Werken met kleuren",
    "text": "Werken met kleuren\nVoor eenvoudige toepassingen is het werken met kleuren in ggplot2 rechttoe rechtaan. Voor een meer gevorderde behandeling van het onderwerp moet je waarschijnlijk Hadley’s boek aanschaffen, dat een goede dekking heeft. Andere goede bronnen zijn het R Cookbook en de `color sectie in de R Graph Gallery door Yan Holtz.\nEr zijn twee belangrijke verschillen als het gaat om kleuren in ggplot2. Beide argumenten, color en fill, kunnen\n\ngespecificeerd als enkele kleur of\n\ntoegekend aan variabelen.\n\nZoals je in het begin van deze tutorial al hebt gezien, worden variabelen die binnen de aesthetiek vallen gecodeerd door variabelen en die erbuiten vallen zijn eigenschappen die niets met de variabelen te maken hebben. Deze complete nonsens plot met het aantal records per jaar en seizoen illustreert dat feit:\n\nggplot(chic, aes(year)) +\n  geom_bar(aes(fill = season), color = \"grey\", size = 2) +\n  labs(x = \"Jaar\", y = \"Observaties\", fill = \"Seizoen:\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\nAfzonderlijke kleuren specificeren\nStatische, enkele kleuren zijn eenvoudig te gebruiken. We kunnen een enkele kleur specificeren voor een geom:\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"steelblue\", size = 2) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n… en in het geval dat het beide biedt, een color (omtrekkleur) en een fill (vulkleur):\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(shape = 21, size = 2, stroke = 1,\n             color = \"#3cc08f\", fill = \"#c08f3c\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nTian Zheng van Columbia heeft een handige [PDF van R kleuren] gemaakt (http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). Natuurlijk kun je ook hex kleurcodes opgeven (gewoon als strings zoals in het voorbeeld hierboven), maar ook RGB of RGBA waarden (via de rgb() functie: rgb(red, green, blue, alpha)).\n\n\nKleuren toewijzen aan variabelen\nIn ggplot2 worden kleuren die aan variabelen zijn toegekend, gewijzigd via de functies scale_color_* en scale_fill_*. Om kleuren te gebruiken met uw gegevens, moet u vooral weten of u te maken heeft met een categorische of continue variabele. Het kleurenpalet moet worden gekozen afhankelijk van het type variabele, waarbij sequentiële of divergerende kleurenpaletten worden gebruikt voor continue variabelen en kwalitatieve kleurenpaletten voor categorische variabelen:\n\n\n\nHands on data visualization by Jack Dougherty and Ilya Ilyankou\n\n\n\n\nKwalitatieve variabelen\nKwalitatieve of categorische variabelen staan voor soorten gegevens die in groepen (categorieën) kunnen worden ingedeeld. De variabele kan verder worden gespecificeerd als nominaal, ordinaal, en binair (dichotomisch). Voorbeelden van kwalitatieve/categorische variabelen zijn:\n\n\n\nGemaakt door Allison Horst\n\n\nHet standaard categorisch kleurenpalet ziet er als volgt uit:\n\n(ga <- ggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\", color = NULL))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nHandmatig kwalitatieve kleuren kiezen\nJe kunt je eigen set kleuren kiezen en ze toewijzen aan een categorische variabele via de functie scale_*_manual() (de * kan color, colour, of fill zijn). Het aantal gespecificeerde kleuren moet overeenkomen met het aantal categorieën:\n\nga + scale_color_manual(values = c(\"dodgerblue4\",\n                                   \"darkolivegreen4\",\n                                   \"darkorchid3\",\n                                   \"goldenrod1\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nGebruik Ingebouwde Kwalitatieve Kleurenpaletten\nDe ColorBrewer palettes is een populair online hulpmiddel voor het selecteren van kleurenschema’s voor kaarten. De verschillende kleurensets zijn ontworpen om aantrekkelijke kleurenschema’s te maken met een gelijkaardig uitzicht, variërend van drie tot twaalf. Deze paletten zijn beschikbaar als ingebouwde functies in het ggplot2 pakket en kunnen worden toegepast door scale_*_brewer() aan te roepen:\n\nga + scale_color_brewer(palette = \"Set1\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\nJe kunt alle beschikbare kleurenpaletten bekijken via RColorBrewer::display.brewer.all().\n\nEr zijn veel uitbreidingspakketten die extra kleurpaletten bieden. Het gebruik ervan verschilt afhankelijk van de manier waarop het pakket is ontworpen. Voor een uitgebreid overzicht van kleurenpaletten die in R beschikbaar zijn, zie de collection provided by Emil Hvitfeldt. Men kan ook zijn paletteer package gebruiken, een uitgebreide verzameling van kleurenpaletten in R die een consistente syntax gebruikt.\nVoorbeelden:\nHet ggthemes package bijvoorbeeld geeft R gebruikers toegang tot de Tableau kleuren. Tableau is een beroemde visualisatie software met een bekend kleuren palet.\n\nlibrary(ggthemes)\nga + scale_color_tableau()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nHet ggsci package biedt kleurenpaletten voor wetenschappelijke tijdschriften en sci-fi thema’s. Wil je een plot met kleuren die eruit zien alsof ze gepubliceerd zijn in Science of Nature? Hier ga je!\n\nlibrary(ggsci)\ng1 <- ga + scale_color_aaas()\ng2 <- ga + scale_color_npg()\n\nlibrary(patchwork)\n(g1 + g2) * theme(legend.position = \"top\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nKwantitatieve variabelen\nKwantitatieve variabelen vertegenwoordigen een meetbare grootheid en zijn dus numeriek. Kwantitatieve gegevens kunnen verder worden ingedeeld in continue of discrete gegevens:\n\n\n\nGemaakt door Allison Horst\n\n\nIn ons voorbeeld veranderen we de variabele die we willen kleuren in ozon, een continue variabele die sterk gerelateerd is aan temperatuur (hogere temperatuur = hogere ozon). De functie scale_*_gradient() is een sequentiële gradiënt terwijl scale_*_gradient2() divergerend is.\nHier is het standaard ggplot2 sequentieel kleurenschema voor continue variabelen:\n\ngb <- ggplot(chic, aes(x = date, y = temp, color = temp)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\", color = \"Temperatuur (°F):\")\n\ngb + scale_color_continuous()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nDeze code laat dezelfde plot zien:\n\ngb + scale_color_gradient()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nEn hier is het divergerende standaard kleurschema:\n\nmid <- mean(chic$temp)  ## midpoint\n\ngb + scale_color_gradient2(midpoint = mid)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nHandmatig een sequentieel kleurenschema instellen\nJe kunt handmatig geleidelijk veranderende kleurenpaletten instellen voor continue variabelen via scale_*_gradient():\n\ngb + scale_color_gradient(low = \"darkkhaki\",\n                          high = \"darkgreen\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nTemperatuurgegevens zijn normaal verdeeld, dus wat denk je van een divergerende kleurenschema (in plaats van sequentieel)… Voor divergerende kleuren kun je de scale_*_gradient2() functie gebruiken:\n\ngb + scale_color_gradient2(midpoint = mid, low = \"#dd8a0b\",\n                           mid = \"grey92\", high = \"#32a676\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nHet mooie Viridis Kleurenpalet\nDe viridis kleurenpaletten maken jouw plots niet alleen mooi en goed waarneembaar, maar ook gemakkelijker te lezen door mensen met kleurenblindheid en goed af te drukken in grijstinten. U kunt testen hoe uw grafieken er onder verschillende vormen van kleurenblindheid uitzien met het dichromate pakket.\nEn ze worden nu ook geleverd met ggplot2! De volgende multi-panel plot illustreert drie van de vier viridis paletten:\n\np1 <- gb + scale_color_viridis_c() + ggtitle(\"'viridis' (default)\")\np2 <- gb + scale_color_viridis_c(option = \"inferno\") + ggtitle(\"'inferno'\")\np3 <- gb + scale_color_viridis_c(option = \"plasma\") + ggtitle(\"'plasma'\")\np4 <- gb + scale_color_viridis_c(option = \"cividis\") + ggtitle(\"'cividis'\")\n\nlibrary(patchwork)\n(p1 + p2 + p3 + p4) * theme(legend.position = \"bottom\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nHet is ook mogelijk om de viridis kleurenpaletten te gebruiken voor discrete variabelen:\n\nga + scale_color_viridis_d(guide = \"none\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nKwantitatieve kleurenpaletten uit uitbreidingspakketten gebruiken\nDe vele uitbreidingspakketten bieden niet alleen bijkomende categorische kleurenpaletten, maar ook sequentiële, divergerende en zelfs cyclische paletten. Nogmaals, ik verwijs je naar de geweldige verzameling geleverd door Emil Hvitfeldt voor een overzicht.\nVoorbeelden:\nHet rcartocolors pakket koppelt het prachtige CARTOcolors aan ggplot2 en bevat verschillende van mijn meest gebruikte paletten:\n\nlibrary(rcartocolor)\ng1 <- gb + scale_color_carto_c(palette = \"BurgYl\")\ng2 <- gb + scale_color_carto_c(palette = \"Earth\")\n\n(g1 + g2) * theme(legend.position = \"bottom\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nHet scico pakket biedt toegang tot de kleurenpaletten ontwikkeld door Fabio Crameri. Deze kleurenpaletten zijn niet alleen mooi en vaak ongebruikelijk, maar ook een goede keuze omdat ze ontwikkeld zijn om perceptueel uniform en geordend te zijn. Bovendien werken ze ook voor mensen met een kleurentekort en in grijstinten:\n\nlibrary(scico)\ng1 <- gb + scale_color_scico(palette = \"berlin\")\ng2 <- gb + scale_color_scico(palette = \"hawaii\", direction = -1)\n\n(g1 + g2) * theme(legend.position = \"bottom\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nKleurpaletten naderhand aanpassen\nSinds de laatste versie van ggplot2 3.0.0, kan men de esthetiek van de lagen wijzigen nadat ze zijn toegewezen aan de gegevens. Of zoals ggplot2 het zegt: “Gebruik after_scale() om de evaluatie van de mapping te markeren voor nadat de gegevens zijn geschaald.”\nDus waarom niet meteen de aangepaste kleuren gebruiken? Aangezien ggplot2 slechts één kleur en één vul schaal kan behandelen, is dit een interessante functionaliteit. Kijk eens naar het volgende voorbeeld waar we invert_color() uit het ggdark [package] gebruiken (https://github.com/nsgrantham/ggdark):\n\nggplot(chic, aes(date, temp, color = temp)) +\n  geom_point(size = 5) +\n  geom_point(aes(color = temp,\n                 color = after_scale(invert_color(color))),\n             size = 2) +\n  scale_color_scico(palette = \"hawaii\", guide = \"none\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning: Duplicated aesthetics after name standardisation: colour\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nHet achteraf veranderen van het kleurenschema is vooral leuk met functies uit de ggdark en colorspace pakketten, namelijk invert_color(), lighten(), darken() en desature(). Je kunt deze functies zelfs combineren. Hier plotten we een boxplot met beide argumenten, color en fill:\n\nlibrary(colorspace)\n\nggplot(chic, aes(date, temp)) +\n  geom_boxplot(aes(color = season,\n                   fill = after_scale(desaturate(lighten(color, .6), .6))),\n               size = 1) +\n  scale_color_brewer(palette = \"Dark2\", guide = \"none\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nMerk op dat je de kleur en/of vulling moet opgeven in de aes() van de respectievelijke geom_*() of stat_*() om after_scale() te laten werken.\n\nDit lijkt een beetje ingewikkeld voor nu-je zou gewoon de color en fill schalen voor beide kunnen gebruiken. Ja, dat is waar, maar denk eens aan gevallen waarin je meerdere color en/of fill schalen nodig hebt. In zo’n geval zou het onzinnig zijn om de fill schaal te bezetten met een iets donkerder versie van het palet dat voor color wordt gebruikt."
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-themas",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-themas",
    "title": "ggplot stap voor stap",
    "section": "Werken met Thema’s",
    "text": "Werken met Thema’s\n\nDe algemene uitzetstijl veranderen\nU kunt het uiterlijk van de plot veranderen door thema’s te gebruiken. ggplot2 wordt geleverd met acht ingebouwde thema’s:\n\n\n\nDe acht ingebouwde thema’s\n\n\nEr zijn verschillende pakketten die aanvullende thema’s leveren, sommige zelfs met verschillende standaard kleurenpaletten. Jeffrey Arnold heeft bijvoorbeeld de bibliotheek ggthemes samengesteld met verschillende aangepaste thema’s die populaire ontwerpen imiteren. Voor een lijst kunt u de ggthemes package site bezoeken. Zonder enige codering kun je gewoon verschillende stijlen aanpassen, waarvan sommige bekend staan om hun stijl en esthetiek.\nHier is een voorbeeld van het kopiëren van de plotting style in het The Economist magazine door gebruik te maken van theme_economist() en scale_color_economist():\n\nlibrary(ggthemes)\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  ggtitle(\"Ups en downs van Chicago's dagelijkse temperaturen\") +\n  theme_economist() +\n  scale_color_economist(name = NULL)\n\n\n\n\nEen ander voorbeeld is de plottenstijl van Tufte, een minimaal inktthema gebaseerd op Edward Tufte’s boek The Visual Display of Quantitative Information. Dit is het boek dat Minard’s grafiek van Napoleon’s opmars naar Rusland populair maakte als een van de beste statistische tekeningen ooit gemaakt. Tufte’s plots werden beroemd door het purisme in hun stijl. Maar kijk zelf maar:\n\nchic_2000 <- filter(chic, year == 2000)\n\nggplot(chic_2000, aes(x = temp, y = o3)) +\n  geom_point() +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozon\") +\n  ggtitle(\"Temperatuur en Ozon niveaus in het jaar 2000 in Chicago\") +\n  theme_tufte()\n\n\n\n\nIk heb het aantal datapunten hier beperkt, gewoon om in Tufte’s minimalistische stijl te passen. Als je van deze manier van plotten houdt, kijk dan eens naar deze blog entry over het maken van verschillende Tufte plots in R.\nEen ander mooi pakket met moderne thema’s en een preset van niet-standaard lettertypen is het hrbrthemes pakket door Bob Rudis met verschillende lichte maar ook donkere thema’s:\n\nlibrary(hrbrthemes)\n\nggplot(chic, aes(x = temp, y = o3)) +\n  geom_point(aes(color = dewpoint), show.legend = FALSE) +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozon\") +\n  ggtitle(\"Temperatuur en Ozonniveaus in Chicago\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nVerander het lettertype van alle tekstelementen\nHet is ongelofelijk eenvoudig om de instellingen van alle tekst elementen in een keer te veranderen. Alle thema’s komen met een argument genaamd basis_familie:\n\ng <- ggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\",\n       title = \"Temperaturen in Chicago\")\n\ng + theme_bw(base_family = \"Playfair\")\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nVerander de grootte van alle tekst elementen\nDe thema_*() functies hebben ook een aantal andere basis_* argumenten. Als je het standaard thema bekijkt (zie hoofdstuk “Maak en gebruik je eigen thema” hieronder) zul je zien dat de grootte van alle elementen relatief (rel()) is ten opzichte van de base_size. Als gevolg hiervan kunt u eenvoudig de base_size veranderen als u de leesbaarheid van uw plots wilt vergroten:\n\ng + theme_bw(base_size = 20, base_family = \"Roboto Condensed\")\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nDe grootte van alle lijn- en rechthoekelementen wijzigen\nOp dezelfde manier kun je de grootte van alle elementen van het type lijn en recht wijzigen:\n\ng + theme_bw(base_line_size = 1, base_rect_size = 1)\n\n\n\n\n\n\nMaak je eigen thema\nAls je het thema voor een hele sessie wilt veranderen, kun je theme_set gebruiken zoals in theme_set(theme_bw()). Het standaard thema heet theme_gray. Als je je eigen aangepaste thema wilt maken, zou je de code direct uit het grijze thema kunnen halen en aanpassen. Merk op dat de rel() functie de maten verandert ten opzichte van de base_size.\n\ntheme_gray\n\nfunction (base_size = 11, base_family = \"\", base_line_size = base_size/22, \n    base_rect_size = base_size/22) \n{\n    half_line <- base_size/2\n    t <- theme(line = element_line(colour = \"black\", size = base_line_size, \n        linetype = 1, lineend = \"butt\"), rect = element_rect(fill = \"white\", \n        colour = \"black\", size = base_rect_size, linetype = 1), \n        text = element_text(family = base_family, face = \"plain\", \n            colour = \"black\", size = base_size, lineheight = 0.9, \n            hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), \n            debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, \n        axis.line.y = NULL, axis.text = element_text(size = rel(0.8), \n            colour = \"grey30\"), axis.text.x = element_text(margin = margin(t = 0.8 * \n            half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * \n            half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * \n            half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * \n            half_line/2), hjust = 0), axis.ticks = element_line(colour = \"grey20\"), \n        axis.ticks.length = unit(half_line/2, \"pt\"), axis.ticks.length.x = NULL, \n        axis.ticks.length.x.top = NULL, axis.ticks.length.x.bottom = NULL, \n        axis.ticks.length.y = NULL, axis.ticks.length.y.left = NULL, \n        axis.ticks.length.y.right = NULL, axis.title.x = element_text(margin = margin(t = half_line/2), \n            vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line/2), \n            vjust = 0), axis.title.y = element_text(angle = 90, \n            margin = margin(r = half_line/2), vjust = 1), axis.title.y.right = element_text(angle = -90, \n            margin = margin(l = half_line/2), vjust = 0), legend.background = element_rect(colour = NA), \n        legend.spacing = unit(2 * half_line, \"pt\"), legend.spacing.x = NULL, \n        legend.spacing.y = NULL, legend.margin = margin(half_line, \n            half_line, half_line, half_line), legend.key = element_rect(fill = \"grey95\", \n            colour = NA), legend.key.size = unit(1.2, \"lines\"), \n        legend.key.height = NULL, legend.key.width = NULL, legend.text = element_text(size = rel(0.8)), \n        legend.text.align = NULL, legend.title = element_text(hjust = 0), \n        legend.title.align = NULL, legend.position = \"right\", \n        legend.direction = NULL, legend.justification = \"center\", \n        legend.box = NULL, legend.box.margin = margin(0, 0, 0, \n            0, \"cm\"), legend.box.background = element_blank(), \n        legend.box.spacing = unit(2 * half_line, \"pt\"), panel.background = element_rect(fill = \"grey92\", \n            colour = NA), panel.border = element_blank(), panel.grid = element_line(colour = \"white\"), \n        panel.grid.minor = element_line(size = rel(0.5)), panel.spacing = unit(half_line, \n            \"pt\"), panel.spacing.x = NULL, panel.spacing.y = NULL, \n        panel.ontop = FALSE, strip.background = element_rect(fill = \"grey85\", \n            colour = NA), strip.text = element_text(colour = \"grey10\", \n            size = rel(0.8), margin = margin(0.8 * half_line, \n                0.8 * half_line, 0.8 * half_line, 0.8 * half_line)), \n        strip.text.x = NULL, strip.text.y = element_text(angle = -90), \n        strip.text.y.left = element_text(angle = 90), strip.placement = \"inside\", \n        strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(half_line/2, \n            \"pt\"), strip.switch.pad.wrap = unit(half_line/2, \n            \"pt\"), plot.background = element_rect(colour = \"white\"), \n        plot.title = element_text(size = rel(1.2), hjust = 0, \n            vjust = 1, margin = margin(b = half_line)), plot.title.position = \"panel\", \n        plot.subtitle = element_text(hjust = 0, vjust = 1, margin = margin(b = half_line)), \n        plot.caption = element_text(size = rel(0.8), hjust = 1, \n            vjust = 1, margin = margin(t = half_line)), plot.caption.position = \"panel\", \n        plot.tag = element_text(size = rel(1.2), hjust = 0.5, \n            vjust = 0.5), plot.tag.position = \"topleft\", plot.margin = margin(half_line, \n            half_line, half_line, half_line), complete = TRUE)\n    ggplot_global$theme_all_null %+replace% t\n}\n<bytecode: 0x000000002620d618>\n<environment: namespace:ggplot2>\n\n\nLaten we nu de standaard themafunctie wijzigen en het resultaat bekijken:\n\ntheme_custom <- function (base_size = 12, base_family = \"Roboto Condensed\") {\n  half_line <- base_size/2\n  theme(\n    line = element_line(color = \"black\", size = .5,\n                        linetype = 1, lineend = \"butt\"),\n    rect = element_rect(fill = \"white\", color = \"black\",\n                        size = .5, linetype = 1),\n    text = element_text(family = base_family, face = \"plain\",\n                        color = \"black\", size = base_size,\n                        lineheight = .9, hjust = .5, vjust = .5,\n                        angle = 0, margin = margin(), debug = FALSE),\n    axis.line = element_blank(),\n    axis.line.x = NULL,\n    axis.line.y = NULL,\n    axis.text = element_text(size = base_size * 1.1, color = \"gray30\"),\n    axis.text.x = element_text(margin = margin(t = .8 * half_line/2),\n                               vjust = 1),\n    axis.text.x.top = element_text(margin = margin(b = .8 * half_line/2),\n                                   vjust = 0),\n    axis.text.y = element_text(margin = margin(r = .8 * half_line/2),\n                               hjust = 1),\n    axis.text.y.right = element_text(margin = margin(l = .8 * half_line/2),\n                                     hjust = 0),\n    axis.ticks = element_line(color = \"gray30\", size = .7),\n    axis.ticks.length = unit(half_line / 1.5, \"pt\"),\n    axis.ticks.length.x = NULL,\n    axis.ticks.length.x.top = NULL,\n    axis.ticks.length.x.bottom = NULL,\n    axis.ticks.length.y = NULL,\n    axis.ticks.length.y.left = NULL,\n    axis.ticks.length.y.right = NULL,\n    axis.title.x = element_text(margin = margin(t = half_line),\n                                vjust = 1, size = base_size * 1.3,\n                                face = \"bold\"),\n    axis.title.x.top = element_text(margin = margin(b = half_line),\n                                    vjust = 0),\n    axis.title.y = element_text(angle = 90, vjust = 1,\n                                margin = margin(r = half_line),\n                                size = base_size * 1.3, face = \"bold\"),\n    axis.title.y.right = element_text(angle = -90, vjust = 0,\n                                      margin = margin(l = half_line)),\n    legend.background = element_rect(color = NA),\n    legend.spacing = unit(.4, \"cm\"),\n    legend.spacing.x = NULL,\n    legend.spacing.y = NULL,\n    legend.margin = margin(.2, .2, .2, .2, \"cm\"),\n    legend.key = element_rect(fill = \"gray95\", color = \"white\"),\n    legend.key.size = unit(1.2, \"lines\"),\n    legend.key.height = NULL,\n    legend.key.width = NULL,\n    legend.text = element_text(size = rel(.8)),\n    legend.text.align = NULL,\n    legend.title = element_text(hjust = 0),\n    legend.title.align = NULL,\n    legend.position = \"right\",\n    legend.direction = NULL,\n    legend.justification = \"center\",\n    legend.box = NULL,\n    legend.box.margin = margin(0, 0, 0, 0, \"cm\"),\n    legend.box.background = element_blank(),\n    legend.box.spacing = unit(.4, \"cm\"),\n    panel.background = element_rect(fill = \"white\", color = NA),\n    panel.border = element_rect(color = \"gray30\",\n                                fill = NA, size = .7),\n    panel.grid.major = element_line(color = \"gray90\", size = 1),\n    panel.grid.minor = element_line(color = \"gray90\", size = .5,\n                                    linetype = \"dashed\"),\n    panel.spacing = unit(base_size, \"pt\"),\n    panel.spacing.x = NULL,\n    panel.spacing.y = NULL,\n    panel.ontop = FALSE,\n    strip.background = element_rect(fill = \"white\", color = \"gray30\"),\n    strip.text = element_text(color = \"black\", size = base_size),\n    strip.text.x = element_text(margin = margin(t = half_line,\n                                                b = half_line)),\n    strip.text.y = element_text(angle = -90,\n                                margin = margin(l = half_line,\n                                                r = half_line)),\n    strip.text.y.left = element_text(angle = 90),\n    strip.placement = \"inside\",\n    strip.placement.x = NULL,\n    strip.placement.y = NULL,\n    strip.switch.pad.grid = unit(0.1, \"cm\"),\n    strip.switch.pad.wrap = unit(0.1, \"cm\"),\n    plot.background = element_rect(color = NA),\n    plot.title = element_text(size = base_size * 1.8, hjust = .5,\n                              vjust = 1, face = \"bold\",\n                              margin = margin(b = half_line * 1.2)),\n    plot.title.position = \"panel\",\n    plot.subtitle = element_text(size = base_size * 1.3,\n                                 hjust = .5, vjust = 1,\n                                 margin = margin(b = half_line * .9)),\n    plot.caption = element_text(size = rel(0.9), hjust = 1, vjust = 1,\n                                margin = margin(t = half_line * .9)),\n    plot.caption.position = \"panel\",\n    plot.tag = element_text(size = rel(1.2), hjust = .5, vjust = .5),\n    plot.tag.position = \"topleft\",\n    plot.margin = margin(base_size, base_size, base_size, base_size),\n    complete = TRUE\n  )\n}\n\n\nJe kunt alleen de standaardwaarden overschrijven voor alle elementen die je wilt veranderen. Hier heb ik ze allemaal opgesomd, zodat je kunt zien dat je letterlijk alles kunt veranderen!\n\nKijk eens naar de gewijzigde esthetiek met de nieuwe look van het paneel en de rasterlijnen, alsook de assen, teksten en titels:\n\ntheme_set(theme_custom())\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() + labs(x = \"Jaar\", y = \"Temperatuur (°F)\") + guides(color = FALSE)\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDeze manier om het plotontwerp te veranderen wordt sterk aanbevolen! Het stelt je in staat om snel elk element van jouw plots te veranderen door het eenmaal te veranderen. Je kunt binnen enkele seconden al uw resultaten in een congruente stijl plotten en het aan andere behoeften aanpassen (b.v. een presentatie met grotere lettergrootte of tijdschriftvereisten).\n\n\nHet huidige thema bijwerken\nJe kunt ook snelle veranderingen instellen met theme_update():\n\ntheme_custom <- theme_update(panel.background = element_rect(fill = \"gray60\"))\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() + labs(x = \"Jaar\", y = \"Temperatuur (°F)\") + guides(color = FALSE)\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nVoor verdere oefeningen gaan we ons eigen thema gebruiken met een witte vulling en zonder de kleine rasterlijnen:\n\ntheme_custom <- theme_update(panel.background = element_rect(fill = \"white\"),\n                             panel.grid.major = element_line(size = .5),\n                             panel.grid.minor = element_blank())"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-lijnen",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-lijnen",
    "title": "ggplot stap voor stap",
    "section": "Werken met lijnen",
    "text": "Werken met lijnen\n\nHorizontaal of verticaal lijnen toevoegen aan een plot\nHet kan zijn dat je een bepaald bereik of een bepaalde drempel wilt markeren, wat je kunt doen door een lijn te plotten op gedefinieerde coördinaten met geom_hline() (voor “horizontale lijnen”) of geom_vline() (voor “verticale lijnen”):\n\nggplot(chic, aes(x = date, y = temp, color = o3)) +\n  geom_point() +\n  geom_hline(yintercept = c(0, 73)) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\ng <- ggplot(chic, aes(x = temp, y = dewpoint)) +\n  geom_point(color = \"dodgerblue\", alpha = .5) +\n  labs(x = \"Temperatuur (°F)\", y = \"Dauwpunt\")\n\ng +\n  geom_vline(aes(xintercept = median(temp)), size = 1.5,\n             color = \"firebrick\", linetype = \"dashed\") +\n  geom_hline(aes(yintercept = median(dewpoint)), size = 1.5,\n             color = \"firebrick\", linetype = \"dashed\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nAls je een lijn wilt toevoegen waarvan de helling niet 0 of 1 is, dan moet je geom_abline() gebruiken. Dit is bijvoorbeeld het geval als je een regressielijn wilt toevoegen met de argumenten intercept en helling:\n\nreg <- lm(dewpoint ~ temp, data = chic)\n\ng +\n  geom_abline(intercept = coefficients(reg)[1],\n              slope = coefficients(reg)[2],\n              color = \"darkorange2\", size = 1.5) +\n  labs(title = paste0(\"y = \", round(coefficients(reg)[2], 2),\n                      \" * x + \", round(coefficients(reg)[1], 2)))\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nLater zullen we leren hoe we met één commando een lineaire fit kunnen toevoegen met stat_smooth(method = \"lm\"). Er kunnen echter andere redenen zijn om een lijn met een gegeven helling toe te voegen en dit is hoe men dat doet.\n\n\nEen lijn toevoegen binnen een Plot\nDe vorige benaderingen besloegen altijd het hele bereik van het plotpaneel. Soms oms wil je alleen een bepaald gebied markeren of lijnen gebruiken voor annotaties. In dit geval is geom_linerange() er om te helpen:\n\ng +\n  ## vertical line\n  geom_linerange(aes(x = 50, ymin = 20, ymax = 55),\n                 color = \"steelblue\", size = 2) +\n  ## horizontal line\n  geom_linerange(aes(xmin = -Inf, xmax = 25, y = 0),\n                 color = \"red\", size = 1)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nOf je kunt geom_segment() gebruiken om lijnen te tekenen met een helling verschillend van 0 en 1:\n\ng +\n  geom_segment(aes(x = 50, xend = 75,\n                   y = 20, yend = 45),\n               color = \"purple\", size = 2)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nKromme lijnen en pijlen toevoegen aan een Plot\ngeom_curve() voegt krommen toe. Nou ja, en rechte lijnen als je wilt:\n\ng +\n  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),\n             size = 2, color = \"tan\") +\n  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),\n             curvature = -0.7, angle = 45,\n             color = \"darkgoldenrod1\", size = 1) +\n  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),\n             curvature = 0, size = 1.5)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDezelfde geom kan worden gebruikt om pijlen te tekenen:\n\ng +\n  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),\n             size = 2, color = \"tan\",\n             arrow = arrow(length = unit(0.07, \"npc\"))) +\n  geom_curve(aes(x = 5, y = 55, xend = 70, yend = 5),\n             curvature = -0.7, angle = 45,\n             color = \"darkgoldenrod1\", size = 1,\n             arrow = arrow(length = unit(0.03, \"npc\"),\n                           type = \"closed\",\n                           ends = \"both\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-tekst",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-tekst",
    "title": "ggplot stap voor stap",
    "section": "Werken met tekst",
    "text": "Werken met tekst\n\nLabels toevoegen aan uw gegevens\nSoms willen wij onze gegevenspunten labelen. Om overlapping en verdringing door tekstlabels te voorkomen, gebruiken we een 1% steekproef van de originele data, die gelijkelijk de vier seizoenen vertegenwoordigt. We gebruiken geom_label() dat een nieuwe esthetiek bevat, genaamd label:\n\nset.seed(2020)\n\nlibrary(dplyr)\nsample <- chic %>%\n  dplyr::group_by(season) %>%\n  dplyr::sample_frac(0.01)\n\n## code without pipes:\n## sample <- sample_frac(group_by(chic, season), .01)\n\nggplot(sample, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  geom_label(aes(label = season), hjust = .5, vjust = -.5) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  xlim(as.Date(c('1997-01-01', '2000-12-31'))) +\n  ylim(c(0, 90)) +\n  theme(legend.position = \"none\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nOké, het vermijden van overlappende labels is niet gelukt. Maar maak je geen zorgen, we gaan het in een minuutje oplossen!\n\nJe kunt ook geom_text() gebruiken als je niet van kaders rond je labels houdt.\n\n\nggplot(sample, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  geom_text(aes(label = season), fontface = \"bold\",\n            hjust = .5, vjust = -.25) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  xlim(as.Date(c('1997-01-01', '2000-12-31'))) +\n  ylim(c(0, 90)) +\n  theme(legend.position = \"none\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nEen cool ding is het ggrepel pakket dat geoms levert voor ggplot2 om overlappende tekst af te stoten zoals in onze voorbeelden hierboven. We vervangen gewoon geom_text() door geom_text_repel() en geom_label() door geom_label_repel():\n\nlibrary(ggrepel)\n\nggplot(sample, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  geom_label_repel(aes(label = season), fontface = \"bold\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.position = \"none\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nHet ziet er misschien mooier uit met gevulde vakjes, dus we mappen season naar fill in plaats van naar color en stellen een witte kleur in voor de tekst:\n\nggplot(sample, aes(x = date, y = temp)) +\n  geom_point(data = chic, size = .5) +\n  geom_point(aes(color = season), size = 1.5) +\n  geom_label_repel(aes(label = season, fill = season),\n                   color = \"white\", fontface = \"bold\",\n                   segment.color = \"grey30\") +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  theme(legend.position = \"none\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDit werkt ook voor de pure tekst labels door gebruik te maken van geom_text_repel(). Kijk eens naar alle gebruiksvoorbeelden.\n\n\nTekst annotaties toevoegen\nEr zijn verschillende manieren waarop je annotaties kunt toevoegen aan een ggplot. We kunnen weer geom_text() of geom_label() gebruiken:\n\ng <-\n  ggplot(chic, aes(x = temp, y = dewpoint)) +\n  geom_point(alpha = .5) +\n  labs(x = \"Temperatuur (°F)\", y = \"Dauwpunt\")\n\ng +\n  geom_text(aes(x = 25, y = 60,\n                label = \"Dit is een bruikbare annotatie\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nEchter, nu heeft ggplot één tekstlabel getekend per datapunt - dat zijn 1.461 labels en je ziet er maar één! Je kunt dit oplossen door het stat argument op \"unique\" te zetten:\n\ng +\n  geom_text(aes(x = 25, y = 60,\n                label = \"Dit is een bruikbare annotatie\"),\n            stat = \"unique\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nTussen haakjes, natuurlijk kun je de eigenschappen van de weergegeven tekst veranderen:\n\ng +\n  geom_text(aes(x = 25, y = 60,\n                label = \"Dit is een bruikbare annotatie\"),\n            stat = \"unique\", family = \"Bangers\",\n            size = 7, color = \"darkcyan\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nAls je een van de facetfuncties gebruikt om uw gegevens te visualiseren, kunt je in de problemen komen. Eén ding is dat je de annotatie misschien maar één keer wilt opnemen:\n\nann <- data.frame(\n  o3 = 30,\n  temp = 20,\n  season = factor(\"Summer\", levels = levels(chic$season)),\n  label = \"Hier is genoeg ruimte \\nvoor wat annotaties.\"\n)\n\ng <-\n  ggplot(chic, aes(x = o3, y = temp)) +\n  geom_point() +\n  labs(x = \"Ozon\", y = \"Temperatuur (°F)\")\n\ng +\n  geom_text(data = ann, aes(label = label),\n            size = 7, fontface = \"bold\",\n            family = \"Roboto Condensed\") +\n  facet_wrap(~season)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nEen andere uitdaging zijn facetten in combinatie met vrije schalen die in uw tekst kunnen snijden:\n\ng +\n  geom_text(aes(x = 23, y = 97,\n                label = \"Dit is geen bruikbare annotatie\"),\n            size = 5, fontface = \"bold\") +\n  scale_y_continuous(limits = c(NA, 100)) +\n  facet_wrap(~season, scales = \"free_x\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nEen oplossing is om vooraf het middelpunt van de as, hier x, te berekenen:\n\nlibrary(tidyverse)\n(ann <-\n  chic %>%\n  group_by(season) %>%\n  summarize(o3 = min(o3, na.rm = TRUE) +\n              (max(o3, na.rm = TRUE) - min(o3, na.rm = TRUE)) / 2))\n\n# A tibble: 4 x 2\n  season    o3\n  <fct>  <dbl>\n1 Winter  21.5\n2 Spring  31.0\n3 Summer  29.2\n4 Autumn  23.3\n\n\n… en gebruik de geaggregeerde gegevens om de plaatsing van de annotatie te specificeren:\n\ng +\n  geom_text(data = ann,\n            aes(x = o3, y = 97,\n                label = \"Dit is een bruikbare annotatie\"),\n            size = 5, fontface = \"bold\") +\n  scale_y_continuous(limits = c(NA, 100)) +\n  facet_wrap(~season, scales = \"free_x\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nEr is echter een eenvoudiger aanpak (wat betreft het vastleggen van de coordinaten)-maar het duurt ook even om de code uit het hoofd te kennen. Het grid pakket in combinatie met ggplot2’s annotation_custom() stelt je in staat om de locatie te specificeren op basis van geschaalde coördinaten waarbij 0 laag is en 1 hoog. grobTree() creëert een raster grafisch object en textGrob creëert het tekst grafisch object. De waarde hiervan is vooral duidelijk wanneer je meerdere plots hebt met verschillende schalen.\n\nlibrary(grid)\nmy_grob <- grobTree(textGrob(\"Deze tekst blijft op de plaats staan!\",\n                             x = .1, y = .9, hjust = 0,\n                             gp = gpar(col = \"black\",\n                                       fontsize = 15,\n                                       fontface = \"bold\")))\n\ng +\n  annotation_custom(my_grob) +\n  facet_wrap(~season, scales = \"free_x\") +\n  scale_y_continuous(limits = c(NA, 100))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nMarkdown en HTML rendering gebruiken voor annotaties\nWe gebruiken opnieuw Claus Wilke’s ggtext package dat is ontworpen voor verbeterde tekst renderingondersteuning voor ggplot2. Het ggtext pakket definieert twee nieuwe themaelementen, element_markdown() en element_textbox(). Het pakket biedt ook extra geoms. geom_richtext() is een vervanging voor geom_text() en geom_label() en rendert tekst als markdown…\n\nlibrary(ggtext)\n\nlab_md <- \"De **temperatuur** in *°F* versus **ozonniveau** in *ppm*\"\n\ng +\n  geom_richtext(aes(x = 35, y = 3, label = lab_md),\n                stat = \"unique\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n… of html:\n\nlab_html <- \"&#9733; De <b style='color:red;'>temperatuur</b> in <i>°F</i> versus <b style='color:blue;'>ozonniveau</b>in <i>ppm</i> &#9733;\"\n\ng +\n  geom_richtext(aes(x = 33, y = 3, label = lab_html),\n                stat = \"unique\")\n\nWarning in text_info(label, fontkey, fontfamily, fontface, fontsize, cache):\nunable to translate '<U+2605>png111.0396692913386' to native encoding\n\n\nWarning in text_info_cache[[key]] <- info: unable to translate\n'<U+2605>png111.0396692913386' to native encoding\n\n\nWarning in text_info(label, fontkey, fontfamily, fontface, fontsize, cache):\nunable to translate '<U+2605>png111.0396692913386' to native encoding\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDe geom komt met een heleboel details die je kunt aanpassen, zoals de hoek (wat niet mogelijk is in de standaard geom_text() en geom_label()), eigenschappen van het vak en eigenschappen van de tekst.\n\ng +\n  geom_richtext(aes(x = 10, y = 25, label = lab_md),\n                stat = \"unique\", angle = 30,\n                color = \"white\", fill = \"steelblue\",\n                label.color = NA, hjust = 0, vjust = 0,\n                family = \"Playfair Display\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nDe andere geom uit het ggtext pakket is geom_textbox(). Deze geom maakt het mogelijk om strings dynamisch te verpakken, wat erg handig is voor langere annotaties, zoals infoboxen en ondertitels.\n\nlab_long <- \"**Lorem ipsum dolor**<br><i style='font-size:8pt;color:red;'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.<br>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</i>\"\n\ng +\n  geom_textbox(aes(x = 40, y = 10, label = lab_long),\n               width = unit(15, \"lines\"), stat = \"unique\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nMerk op dat het niet mogelijk is om het tekstvak te draaien (altijd horizontaal) of om de uitlijning van de tekst te veranderen (altijd links uitgelijnd)."
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-coördinaten",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-coördinaten",
    "title": "ggplot stap voor stap",
    "section": "Werken met Coördinaten",
    "text": "Werken met Coördinaten\n\nEen plot omdraaien\nHet is ongelooflijk eenvoudig om een plot om te draaien. Hier heb ik de coord_flip() toegevoegd, alles is wat je nodig hebt om de plot om te draaien. Dit is vooral zinvol wanneer je geom’s gebruikt om categorische data weer te geven, bijvoorbeeld staafdiagrammen of, zoals in het volgende voorbeeld, box and whiskers plots:\n\nggplot(chic, aes(x = season, y = o3)) +\n  geom_boxplot(fill = \"indianred\") +\n  labs(x = \"Seizoen\", y = \"Ozon\") +\n  coord_flip()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\nSinds ggplot2 versie 3.0.0 is het ook mogelijk om geom’s horizontaal te tekenen via het argument orientation = \"y\". Uitklappen om voorbeeld te zien.\n\n\n\nFixeer een As\nJe kunt de hoogte-breedte verhouding van het Cartesisch coördinatenstelsel vastzetten en letterlijk een fysieke weergave van de eenheden langs de x- en y-assen afdwingen:\n\nggplot(chic, aes(x = temp, y = o3)) +\n  geom_point() +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozonniveau\") +\n  scale_x_continuous(breaks = seq(0, 80, by = 20)) +\n  coord_fixed(ratio = 1)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nThis way one can ensure not only a fixed step length on the axes but also that the exported plot looks as expected. However, your saved plot likely contains a lot of white space in case you do not use a suitable aspect ratio:\n\nggplot(chic, aes(x = temp, y = o3)) +\n  geom_point() +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozon\\nniveau\") +\n  scale_x_continuous(breaks = seq(0, 80, by = 20)) +\n  coord_fixed(ratio = 1/3) +\n  theme(plot.background = element_rect(fill = \"grey80\"))\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nEen as omkeren\nJe kunt een as ook eenvoudig omkeren met scale_x_reverse() of scale_y_reverse(), respectievelijk:\n\nggplot(chic, aes(x = date, y = temp, color = o3)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature (°F)\") +\n  scale_y_reverse()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\nMerk op dat dit alleen werkt voor continue data. Als je discrete data wilt omdraaien, gebruik dan de fct_rev() functie uit het forcats pakket.\n\n\n\nTransformeer een As\n… of transformeer de standaard lineaire afbeelding door scale_y_log10() of scale_y_sqrt() te gebruiken. Als voorbeeld, hier is een log10-getransformeerde as (die NA’s introduceert in dit geval, dus wees voorzichtig):\n\nggplot(chic, aes(x = date, y = temp, color = o3)) +\n  geom_point() +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  scale_y_log10(lim = c(0.1, 100))\n\nWarning in self$trans$transform(x): NaNs produced\n\n\nWarning: Transformation introduced infinite values in continuous y-axis\n\n\nWarning: Removed 3 rows containing missing values (geom_point).\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nEen Plot Circulariseren\nHet is ook mogelijk om het coördinatenstelsel te circulariseren (polariseren?) door coord_polar() op te roepen.\n\nlibrary(tidyverse)\n\nchic %>%\n  dplyr::group_by(season) %>%\n  dplyr::summarize(o3 = median(o3)) %>%\n  ggplot(aes(x = season, y = o3)) +\n    geom_col(aes(fill = season), color = NA) +\n    labs(x = \"\", y = \"Mediaan Ozonniveau\") +\n    coord_polar() +\n    guides(fill = FALSE)\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nMet dit coördinatenstelsel kunnen ook cirkeldiagrammen worden getekend:\n\nchic_sum <-\n  chic %>%\n  dplyr::mutate(o3_avg = median(o3)) %>%\n  dplyr::filter(o3 > o3_avg) %>%\n  dplyr::mutate(n_all = n()) %>%\n  dplyr::group_by(season) %>%\n  dplyr::summarize(rel = n() / unique(n_all))\n\nggplot(chic_sum, aes(x = \"\", y = rel)) +\n  geom_col(aes(fill = season), width = 1, color = NA) +\n  labs(x = \"\", y = \"Proportie dagen boven\\nhet mediaan Ozonniveau\") +\n  coord_polar(theta = \"y\") +\n  scale_fill_brewer(palette = \"Set1\", name = \"Season:\") +\n  theme(axis.ticks = element_blank(),\n        panel.grid = element_blank())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nIk stel voor om altijd ook te kijken naar het resultaat van dezelfde code in een Cartesisch coördinatensysteem, wat de standaard is, om de logica achter coord_polar() en theta te begrijpen:\n\nggplot(chic_sum, aes(x = \"\", y = rel)) +\n  geom_col(aes(fill = season), width = 1, color = NA) +\n  labs(x = \"\", y = \"Proportie dagen boven \\nhet mediaan Ozonniveau\") +\n  #coord_polar(theta = \"y\") +\n  scale_fill_brewer(palette = \"Set1\", name = \"Season:\") +\n  theme(axis.ticks = element_blank(),\n        panel.grid = element_blank())\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-grafiek-typen",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-grafiek-typen",
    "title": "ggplot stap voor stap",
    "section": "Werken met Grafiek Typen",
    "text": "Werken met Grafiek Typen\n\nAlternatieven voor een Box Plot\nBox plots zijn geweldig, maar ze kunnen zo ontzettend saai zijn. En zelfs als je gewend bent om naar box plots te kijken, bedenk dan dat er veel mensen naar uw plot kunnen kijken die nog nooit een box and whisker plot hebben gezien. pand for a short recap on box and whiskers plots.\nEr zijn alternatieven, maar eerst plotten we een gewone boxplot:\n\ng <-\n  ggplot(chic, aes(x = season, y = o3,\n                   color = season)) +\n    labs(x = \"Seizoen\", y = \"Ozon\") +\n    scale_color_brewer(palette = \"Dark2\", guide = \"none\")\n\ng + geom_boxplot()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\n1. Alternatief: Uitzetten van punten\nLaten we gewoon elk gegevenspunt van de ruwe gegevens uitzetten:\n\ng + geom_point()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nNiet alleen saai, maar ook niet informatief. Om de plot te verbeteren, zou men transparantie kunnen toevoegen om overplotting tegen te gaan:\n\ng + geom_point(alpha = .1)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nTransparantie instellen is hier echter moeilijk, omdat ofwel de overlapping nog te groot is, ofwel de extreme waarden niet zichtbaar zijn. Slecht, dus laten we iets anders proberen.\n\n\n2. Alternatief: Jitter de punten\nProbeer een beetje jitter toe te voegen aan de data. Ik hou hiervan voor interne visualisatie, maar wees voorzichtig met jittering omdat je opzettelijk ruis toevoegt aan je data en dit kan resulteren in een verkeerde interpretatie van je data.\n\ng + geom_jitter(width = .3, alpha = .5)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\n3. Alternatief: Vioolplots\nVioolplots, vergelijkbaar met boxplots behalve dat u een kerneldichtheid gebruikt om te tonen waar u de meeste gegevens hebt, zijn een nuttige visualisatie.\n\ng + geom_violin(fill = \"gray80\", size = 1, alpha = .5)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\n4. Alternatief: Vioolplots combineren met Jitter\nWe kunnen natuurlijk beide combineren, geschatte dichtheden en de ruwe datapunten:\n\ng + geom_violin(fill = \"gray80\", size = 1, alpha = .5) +\n    geom_jitter(alpha = .25, width = .3) +\n    coord_flip()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nHet ggforce pakket biedt zogenaamde sina functies waarbij de breedte van de jitter wordt geregeld door de dichtheidsverdeling van de gegevens-dat maakt de jittering een beetje visueel aantrekkelijker:\n\nlibrary(ggforce)\n\ng + geom_violin(fill = \"gray80\", size = 1, alpha = .5) +\n    geom_sina(alpha = .25) +\n    coord_flip()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\n5. Alternatief: Vioolplots combineren met boxplots\nOm de kwantielen gemakkelijk te kunnen schatten, kunnen wij de box van de boxplot ook binnen de violen plaatsen om het 25%-kwartiel, de mediaan en het 75%-kwartiel aan te geven:\n\ng + geom_violin(aes(fill = season), size = 1, alpha = .5) +\n    geom_boxplot(outlier.alpha = 0, coef = 0,\n                 color = \"gray40\", width = .2) +\n    scale_fill_brewer(palette = \"Dark2\", guide = \"none\") +\n    coord_flip()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nEen deken maken voor een plot\nEen deken geeft de gegevens van één kwantitatieve variabele weer, weergegeven als markeringen langs een as. In de meeste gevallen wordt het gebruikt als aanvulling op scatter plots of heatmaps om de algemene verdeling van één of beide variabelen te visualiseren:\n\nggplot(chic, aes(x = date, y = temp,\n                 color = season)) +\n  geom_point(show.legend = FALSE) +\n  geom_rug(show.legend = FALSE) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point(show.legend = FALSE) +\n  geom_rug(sides = \"r\", alpha = .3, show.legend = FALSE) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nEen correlatiematrix maken\nEr zijn verschillende pakketten die het mogelijk maken om correlatiematrix-plots te maken, sommige gebruiken ook de ggplot2 infrastructuur en geven dus ggplots terug. Ik ga je tonen hoe dit te doen zonder extensiepakketten.\nDe eerste stap is het maken van de correlatiematrix. Hier gebruiken we het corrr pakket dat goed werkt met pipes, maar er zijn ook vele andere. We gebruiken Pearson omdat alle variabelen redelijk normaal verdeeld zijn (maar je kunt Spearman overwegen als je variabelen een ander patroon volgen). Merk op dat aangezien een correlatiematrix overbodige informatie bevat, we de helft ervan op NA zetten.\n\nlibrary(tidyverse)\n\ncorm <-\n  chic %>%\n  select(temp, dewpoint, pm10, o3) %>%\n  corrr::correlate(diagonal = 1) %>%\n  corrr::shave(upper = FALSE)\n\n\nCorrelation method: 'pearson'\nMissing treated using: 'pairwise.complete.obs'\n\n\nNow we put the resulting matrix in long format using the pivot_longer() function from the tidyr package. We also directly format the labels and place empty quotes for the upper triangle. Note that I use sprintf() to ensure that the label always display two digits.\ncorm <- corm %>%\n  pivot_longer(\n    cols = -term,\n    names_to = \"colname\",\n    values_to = \"corr\"\n  ) %>%\n  mutate(\n    rowname = fct_inorder(term),\n    colname = fct_inorder(colname),\n    label = ifelse(is.na(corr), \"\", sprintf(\"%1.2f\", corr))\nFor the plot we will use geom_tile() for the heatmap and geom_text() for the labels:\nggplot(corm, aes(rowname, fct_rev(colname),\n                 fill = corr)) +\n  geom_tile() +\n  geom_text(aes(label = label)) +\n  coord_fixed() +\n  labs(x = NULL, y = NULL)\nI like to have a diverging color palette—it is important that the scale is centered at zero correlation!—with white indicating missing data. Also I like to have no grid lines and padding around the heatmap as well as labels that are colored depending on the underlying fill:\nggplot(corm, aes(rowname, fct_rev(colname),\n                 fill = corr)) +\n  geom_tile() +\n  geom_text(aes(\n    label = label,\n    color = abs(corr) < .75\n  )) +\n  coord_fixed(expand = FALSE) +\n  scale_color_manual(\n    values = c(\"white\", \"black\"),\n    guide = \"none\"\n  ) +\n  scale_fill_distiller(\n    palette = \"PuOr\", na.value = \"white\",\n    direction = 1, limits = c(-1, 1),\n    name = \"Pearson\\nCorrelation:\"\n  ) +\n  labs(x = NULL, y = NULL) +\n  theme(panel.border = element_rect(color = NA, fill = NA),\n        legend.position = c(.85, .8))\n\n\nEen Contourplot maken\nContourplots zijn een mooie manier om een reeks waarden weer te geven. Men kan ze gebruiken om gegevens te rangschikken en zo de dichtheid van waarnemingen te tonen:\n\nggplot(chic, aes(temp, o3)) +\n  geom_density_2d() +\n  labs(x = \"Temperatuur (°F)\", x = \"Ozonniveau\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\nggplot(chic, aes(temp, o3)) +\n  geom_density_2d_filled(show.legend = FALSE) +\n  coord_cartesian(expand = FALSE) +\n  labs(x = \"Temperatuur (°F)\", x = \"Ozonniveau\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nMaar nu plotten wij driedimensionale gegevens. Wij gaan de drempelwaarden voor het dauwpunt (d.w.z. de temperatuur waarbij waterdamp in de lucht condenseert tot vloeibare dauw) in relatie tot de temperatuur en de ozonconcentratie uitzetten:\n\n## interpolate data\nlibrary(akima)\nfld <- with(chic, interp(x = temp, y = o3, z = dewpoint))\n\n## prepare data in long format\nlibrary(reshape2)\n\n\nAttaching package: 'reshape2'\n\n\nThe following object is masked from 'package:tidyr':\n\n    smiths\n\ndf <- melt(fld$z, na.rm = TRUE)\nnames(df) <- c(\"x\", \"y\", \"Dewpoint\")\n\ng <- ggplot(data = df, aes(x = x, y = y, z = Dewpoint))  +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozonniveau\",\n       color = \"Dauwpunt\")\n\ng + stat_contour(aes(color = ..level.., fill = Dewpoint))\n\nWarning: Ignoring unknown aesthetics: fill\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nVerrassing! Zoals het is gedefinieerd, is het getrokken punt in de meeste gevallen gelijk aan de gemeten temperatuur.\nDe lijnen geven verschillende niveaus van dauwpunten aan, maar dit is geen mooie plot en ook moeilijk te lezen door ontbrekende randen. Laten we een tegel-plot proberen met gebruikmaking van het viridis kleurenpalet om het dauwpunt van elke combinatie van ozon-niveau en temperatuur te coderen:\n\ng + geom_tile(aes(fill = Dewpoint)) +\n    scale_fill_viridis_c(option = \"inferno\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nHoe ziet het eruit als we een contourplot en een tegelplot combineren om het gebied onder de contourlijnen op te vullen?\n\ng + geom_tile(aes(fill = Dewpoint)) +\n    stat_contour(color = \"white\", size = .7, bins = 5) +\n    scale_fill_viridis_c()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nMaak een Heatmap\nNet als bij onze eerste isolijnenkaarten, kunnen we eenvoudig de aantallen of dichtheden van punten weergeven, gekwantificeerd naar een hexagonaal raster via geom_hex():\n\nggplot(chic, aes(temp, o3)) +\n  geom_hex() +\n  scale_fill_distiller(palette = \"YlOrRd\", direction = 1) +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozonniveau\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nVaak verschijnen er witte lijnen in de resulterende plot. Men kan dat verhelpen door ook kleur toe te wijzen aan ofwel ..count.. (de standaard) of ..density…..\n\nggplot(chic, aes(temp, o3)) +\n  geom_hex(aes(color = ..count..)) +\n  scale_fill_distiller(palette = \"YlOrRd\", direction = 1) +\n  scale_color_distiller(palette = \"YlOrRd\", direction = 1) +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozonniveau\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n… of door voor alle zeshoekige cellen dezelfde kleur als omlijning in te stellen:\n\nggplot(chic, aes(temp, o3)) +\n  geom_hex(color = \"grey\") +\n  scale_fill_distiller(palette = \"YlOrRd\", direction = 1) +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozonniveau\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nMen kan ook de standaard binning wijzigen om het aantal hexagonale cellen in of uit te breiden:\n\nggplot(chic, aes(temp, o3, fill = ..density..)) +\n  geom_hex(bins = 50, color = \"grey\") +\n  scale_fill_distiller(palette = \"YlOrRd\", direction = 1) +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozonniveau\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nAls je een regelmatig raster wilt hebben, kun je ook geom_bin2d() gebruiken, dat de data samenvat tot rechthoekige raster cellen gebaseerd op bins:\n\nggplot(chic, aes(temp, o3, fill = ..density..)) +\n  geom_bin2d(bins = 15, color = \"grey\") +\n  scale_fill_distiller(palette = \"YlOrRd\", direction = 1) +\n  labs(x = \"Temperatuur (°F)\", y = \"Ozonniveau\")\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\n\nMaak een Ridge Plot\nRidge(line) plots zijn een nieuw type plots dat op dit moment erg populair is.\nHoewel je deze plots kunt maken met basic ggplot2 commands heeft de populariteit geleid tot een pakket dat het maken van deze plots makkelijker maakt: ggridges. We gaan dit pakket hier gebruiken.\n\nlibrary(ggridges)\nggplot(chic, aes(x = temp, y = factor(year))) +\n   geom_density_ridges(fill = \"gray90\") +\n   labs(x = \"Temperatuur (°F)\", y = \"Jaar\")\n\nPicking joint bandwidth of 5.23\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nJe kunt de overlap en de trailing tails eenvoudig opgeven met de argumenten rel_min_height en scale, respectievelijk. Het pakket wordt ook geleverd met een eigen thema (maar ik bouw liever mijn eigen thema, zie hoofdstuk [“Maak en gebruik je eigen thema”]](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/#themes). Bovendien veranderen we de kleuren op basis van jaartal om het aantrekkelijker te maken.\n\nggplot(chic, aes(x = temp, y = factor(year), fill = year)) +\n  geom_density_ridges(alpha = .8, color = \"white\",\n                      scale = 2.5, rel_min_height = .01) +\n  labs(x = \"Temperatuur (°F)\", y = \"Jaar\") +\n  guides(fill = FALSE) +\n  theme_ridges()\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\nPicking joint bandwidth of 5.23\n\n\n\n\n\nJe kan ook de overlapping wegwerken door waarden lager dan 1 te gebruiken voor het schalingsargument (maar dit is op één of andere manier in tegenspraak met het idee van ridge plots…). Hier is een voorbeeld dat bovendien gebruik maakt van het viridis kleurverloop en het in-build thema:\n\nggplot(chic, aes(x = temp, y = season, fill = ..x..)) +\n  geom_density_ridges_gradient(scale = .9, gradient_lwd = .5,\n                               color = \"black\") +\n  scale_fill_viridis_c(option = \"plasma\", name = \"\") +\n  labs(x = \"Temperatuur (°F)\", y = \"Seizoen\") +\n  theme_ridges(font_family = \"Roboto Condensed\", grid = FALSE)\n\nPicking joint bandwidth of 2.99\n\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nWe kunnen ook verschillende groepen per richel vergelijken en ze inkleuren volgens hun groep. Dit volgt het idee van Marc Belzunces.\n\nlibrary(tidyverse)\n\n## only plot extreme season using dplyr from the tidyverse\nggplot(data = filter(chic, season %in% c(\"Summer\", \"Winter\")),\n         aes(x = temp, y = year, fill = paste(year, season))) +\n  geom_density_ridges(alpha = .7, rel_min_height = .01,\n                      color = \"white\", from = -5, to = 95) +\n  scale_fill_cyclical(breaks = c(\"1997 Summer\", \"1997 Winter\"),\n                      labels = c(`1997 Summer` = \"Zomer\",\n                                 `1997 Winter` = \"Winter\"),\n                      values = c(\"tomato\", \"dodgerblue\"),\n                      name = \"Seizoen:\", guide = \"legend\") +\n  theme_ridges(grid = FALSE) +\n  labs(x = \"Temperatuur (°F)\", y = \"Jaar\")\n\nPicking joint bandwidth of 3.17\n\n\n\n\n\nHet ggridges pakket is ook nuttig om histogrammen voor verschillende groepen te maken met stat = \"binline\" in het geom_density_ridges() commando:\n\nggplot(chic, aes(x = temp, y = factor(year), fill = year)) +\n  geom_density_ridges(stat = \"binline\", bins = 25, scale = .9,\n                      draw_baseline = FALSE, show.legend = FALSE) +\n  theme_minimal() +\n  labs(x = \"Temperatuur (°F)\", y = \"Seizoen\")"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-linten-auc-ci-enz.",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-linten-auc-ci-enz.",
    "title": "ggplot stap voor stap",
    "section": "Werken met linten (AUC, CI, enz.)",
    "text": "Werken met linten (AUC, CI, enz.)\nDit is geen perfecte dataset om dit te demonstreren, maar het gebruik van linten kan nuttig zijn. In dit voorbeeld zullen we een 30-daags lopend gemiddelde maken met behulp van de filter() functie, zodat ons lint niet te veel ruis bevat.\n\nchic$o3run <- as.numeric(stats::filter(chic$o3, rep(1/30, 30), sides = 2))\n\nggplot(chic, aes(x = date, y = o3run)) +\n   geom_line(color = \"chocolate\", lwd = .8) +\n   labs(x = \"Jaar\", y = \"Ozon\")\n\nWarning: Removed 29 row(s) containing missing values (geom_path).\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nHoe ziet het eruit als we het gebied onder de kromme invullen met de geom_ribbon() functie?\n\nggplot(chic, aes(x = date, y = o3run)) +\n   geom_ribbon(aes(ymin = 0, ymax = o3run),\n               fill = \"orange\", alpha = .4) +\n   geom_line(color = \"chocolate\", lwd = .8) +\n   labs(x = \"Jaar\", y = \"Ozon\")\n\nWarning: Removed 29 row(s) containing missing values (geom_path).\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\nLeuk om de area under the curve (AUC) aan te geven, maar dit is niet de conventionele manier om geom_ribbon() te gebruiken.\n\nEn eigenlijk een mooiere manier om hetzelfde te bereiken is geom_area().\n\nIn plaats daarvan tekenen we een lint dat ons één standaardafwijking boven en onder onze gegevens geeft:\n\nchic$mino3 <- chic$o3run - sd(chic$o3run, na.rm = TRUE)\nchic$maxo3 <- chic$o3run + sd(chic$o3run, na.rm = TRUE)\n\nggplot(chic, aes(x = date, y = o3run)) +\n   geom_ribbon(aes(ymin = mino3, ymax = maxo3), alpha = .5,\n               fill = \"darkseagreen3\", color = \"transparent\") +\n   geom_line(color = \"aquamarine4\", lwd = .7) +\n   labs(x = \"Jaar\", y = \"Ozon\")\n\nWarning: Removed 29 row(s) containing missing values (geom_path).\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-afvlakkingen",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-afvlakkingen",
    "title": "ggplot stap voor stap",
    "section": "Werken met afvlakkingen",
    "text": "Werken met afvlakkingen\nHet is verbazend eenvoudig om afvlakkingen toe te voegen aan uw gegevens met ggplot2.\n\nStandaard: Een LOESS of GAM afvlakking toevoegen\nJe kunt eenvoudig stat_smooth() gebruiken - zelfs een formule is niet nodig. Dit voegt een LOESS (locally weighted scatter plot smoothing, method = \"loess\") toe als je minder dan 1000 punten hebt of een GAM (generalized additive model, method = \"gam\") anders. Omdat we meer dan 1000 punten hebben, is de afvlakking gebaseerd op een GAM:\n\nggplot(chic, aes(x = date, y = temp)) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  stat_smooth() +\n  geom_point(color = \"gray40\", alpha = .5)\n\n`geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\nIn de meeste gevallen wil men dat de punten boven op het lint liggen, dus zorg ervoor dat u de afvlakking altijd oproept voordat u de punten toevoegt.\n\n\n\nEen lineaire afvlakking toevoegen\nDe standaardinstelling is een LOESS of GAM afvlakking, maar het is ook eenvoudig om een standaard lineaire fit toe te voegen:\n\n# Anders dan bij Cédric zat Deaths als y variabele er niet in, vandaar dewpoint\nggplot(chic, aes(x = temp, y = dewpoint)) +\n   labs(x = \"Temperatuur (°F)\", y = \"Dauw\") +\n   stat_smooth(method = \"lm\", se = FALSE,\n               color = \"firebrick\", size = 1.3) +\n   geom_point(color = \"gray40\", alpha = .5)\n\n`geom_smooth()` using formula 'y ~ x'\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\n\nDe formule voor afvlakken specificeren\nMet ggplot2 kunt u het model opgeven dat u wilt gebruiken. Misschien wilt u een polynomiale regressie?\n\nggplot(chic, aes(x = o3, y = temp))+\n  labs(x = \"Ozonniveau\", y = \"Temperatuur (°F)\") +\n  geom_smooth(\n    method = \"lm\",\n    formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),\n    color = \"black\",\n    fill = \"firebrick\"\n  ) +\n  geom_point(color = \"gray40\", alpha = .3)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\n\n\n\n\nHuh, geom_smooth()? Er is een belangrijk verschil tussen geom en stat lagen, maar hier maakt het echt niet uit welke je gebruikt. Vergroot om beide te vergelijken.\n\nLaten we zeggen dat je de GAM-dimensie wilt vergroten (wat extra wiggles toevoegen aan de smooth):\n\ncols <- c(\"darkorange2\", \"firebrick\", \"dodgerblue3\")\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"gray40\", alpha = .3) +\n  labs(x = \"Jaar\", y = \"Temperatuur (°F)\") +\n  stat_smooth(aes(col = \"1000\"),\n              method = \"gam\",\n              formula = y ~ s(x, k = 1000),\n              se = FALSE, size = 1.3) +\n  stat_smooth(aes(col = \"100\"),\n              method = \"gam\",\n              formula = y ~ s(x, k = 100),\n              se = FALSE, size = 1) +\n  stat_smooth(aes(col = \"10\"),\n              method = \"gam\",\n              formula = y ~ s(x, k = 10),\n              se = FALSE, size = .8) +\n  scale_color_manual(name = \"k\", values = cols)\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-interactieve-diagrammen",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#werken-met-interactieve-diagrammen",
    "title": "ggplot stap voor stap",
    "section": "Werken met interactieve diagrammen",
    "text": "Werken met interactieve diagrammen\nDe volgende verzameling bevat bibliotheken die kunnen worden gebruikt in combinatie met ggplot2 of op zichzelf om interactieve visualisaties te maken in R (vaak gebruikmakend van bestaande JavaScript bibliotheken).\n\nCombinatie van {ggplot2} en {shiny}\nshiny is een pakket van RStudio dat het ongelooflijk gemakkelijk maakt om interactieve webapplicaties te bouwen met R. Voor een introductie en live voorbeelden, bezoek de Shiny homepage.\nOm de gebruiksmogelijkheden te bekijken, kun je de Hello Shiny voorbeelden bekijken. Dit is de eerste:\n# Dit moet je zelf even runnen\nlibrary(shiny)\nrunExample(\"01_hello\")\nNatuurlijk kun je ggplots gebruiken in deze apps. Dit voorbeeld demonstreert de mogelijkheid om wat interactieve gebruikerservaring toe te voegen:\n#Deze ook\nrunExample(\"04_mpg\")"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#plot.ly-via-plotly-en-ggplot2",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#plot.ly-via-plotly-en-ggplot2",
    "title": "ggplot stap voor stap",
    "section": "Plot.ly via plotly en ggplot2",
    "text": "Plot.ly via plotly en ggplot2\nPlot.ly is een tool voor het maken van online, interactieve grafieken en web apps. Met het plotly pakket kunt je deze direct vanuit uw ggplot2 plots maken en de workflow is verrassend eenvoudig en kan worden gedaan vanuit R. Het is echter mogelijk dat sommige van uw thema-instellingen worden gewijzigd en achteraf handmatig moeten worden aangepast. Ook is het helaas niet eenvoudig om facets of echte multi-panel plots te maken die mooi schalen.\n\ng <- ggplot(chic, aes(date, temp)) +\n  geom_line(color = \"grey\") +\n  geom_point(aes(color = season)) +\n  scale_color_brewer(palette = \"Dark2\", guide = \"none\") +\n  labs(x = NULL, y = \"Temperatuur (°F)\") +\n  theme_bw()\n\n\nlibrary(plotly)\n\nggplotly(g)\n\n\n\n\n\nHier, bijvoorbeeld, behoudt het de algemene thema-instelling maar voegt de legende opnieuw toe.\n\nggiraph en ggplot2\nggiraph is een R pakket waarmee je dynamische ggplot2 grafieken kunt maken. Hiermee kun je tooltips, animaties en JavaScript acties aan de grafieken toevoegen. Het pakket maakt het ook mogelijk om grafische elementen te selecteren bij gebruik in Shiny applicaties.\n\nlibrary(ggiraph)\n\ng <- ggplot(chic, aes(date, temp)) +\n  geom_line(color = \"grey\") +\n  geom_point_interactive(\n    aes(color = season, tooltip = season, data_id = season)\n  ) +\n  scale_color_brewer(palette = \"Dark2\", guide = \"none\") +\n  labs(x = NULL, y = \"Temperatuur (°F)\") +\n  theme_bw()\n\ngirafe(ggobj = g)\n\n\n\n\n\n\n\nHighcharts via highcharter\nHighcharts, een software bibliotheek voor interactieve grafieken, is een andere visualisatie bibliotheek geschreven in puur JavaScript dat is overgezet naar R. Het pakket highcharter maakt het mogelijk om ze te gebruiken-maar wees ervan bewust dat Highcharts alleen gratis is in geval van niet-commercieel gebruik.\n\nlibrary(highcharter)\n\nhchart(chic, \"scatter\", hcaes(x = date, y = temp, group = season))\n\n\n\n\n\n\n\nEcharts via echarts4r\nApache ECharts is een gratis, krachtige bibliotheek voor grafieken en visualisatie die een eenvoudige manier biedt om intuïtieve, interactieve en sterk aanpasbare grafieken te bouwen. Hoewel het is geschreven in JavaScript, kan men het gebruiken in R via de echarts4r library met dank aan John Coene. Bekijk de indrukwekkende voorbeeld galerij of deze twee apps (App 1 en App 2) die gebruik maken van de echarts4r functionaliteit.\n\nlibrary(echarts4r)\n\nchic %>%\n  e_charts(date) %>%\n  e_scatter(temp, symbol_size = 7) %>%\n  e_visual_map(temp) %>%\n  e_y_axis(name = \"Temperatuur (°F)\") %>%\n  e_legend(FALSE)\n\n\n\n\n\n\n\nChart.js via charter\ncharter is een ander pakket ontwikkeld door John Coene dat het gebruik van een JavaScript visualisatie bibliotheek in R mogelijk maakt. Het pakket maakt het mogelijk om interactieve plots te bouwen met behulp van het Charts.js framework.\nlibrary(charter)\n# This example doesn't work in RMarkdown\n\nchic$date_num <- as.numeric(chic$date)\n## doesn't work with class date\n\nchart(data = chic, caes(date_num, temp)) %>%\n  c_scatter(caes(color = season, group = season)) %>%\n  c_colors(RColorBrewer::brewer.pal(4, name = \"Dark2\"))"
  },
  {
    "objectID": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#opmerkingen-tips-hulpbronnen",
    "href": "posts/2022-06-27-ggplot-stap-voor-stap/ggplot-stap-voor-stap.html#opmerkingen-tips-hulpbronnen",
    "title": "ggplot stap voor stap",
    "section": "Opmerkingen, tips & hulpbronnen",
    "text": "Opmerkingen, tips & hulpbronnen\n\nggplot2 gebruiken in lussen en functies\nDe raster-gebaseerde grafische functies in lattice en ggplot2 maken een grafiek object. Wanneer je deze functies interactief gebruikt op de command line, wordt het resultaat automatisch afgedrukt, maar in source() of binnen je eigen functies heb je een expliciet print() statement nodig, d.w.z. print(g) in de meeste van onze voorbeelden. Zie ook de [Q&A pagina van R}(https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-do-lattice_002ftrellis-graphics-not-work_003f).\n\n\nAanvullende bronnen\n\nggplot2: Elegant Graphics for Data Analysis” van Hadley Wickham, verkrijgen via open-access!\n\n“Fundamentals of Data Visualization” by Claus O. Wilke over datavisualisatie in algemeen maar ook met gebruik van ggplot2. (Je kunt de codes op zijn Github profile vinden.)\n\n“Cookbook for R” by Winston Chang met codes voor het produceren van R plots\n\nGallerie van de Top 50 ggplot2 visualizations\nGallerie van ggplot2 extensie pakketten\n\nHow to extend ggplot2 by Hadley Wickham\n\nDe fantastische R4DS Online Learning Community die hulp en begeleiding biedt voor alles wat te maken heeft met de inhoud van de “R for Data Science” book by Hadley Wickham\n\n#TidyTuesday(https://github.com/rfordatascience/tidytuesday), een wekelijks sociaal data project met de nadruk op ggplots-check ook #TidyTuesday on Twitter and this collection of contributions by Neil Grantham\n\nEen tweedelige, 4.5-urige tutorialseries van Thomas Linn Pedersen ([Deel 1}(https://www.youtube.com/watch?v=h29g21z0a68) | Deel 2)"
  }
]